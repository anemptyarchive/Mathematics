---
title: "円関数の可視化"
author: "@anemptyarchive\\thanks{\\url{https://www.anarchive-beta.com/}}"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: TRUE       # 目次
    toc_depth: 5    # 目次の見出しレベル
    toc_float: TRUE # 目次のスクロール追跡
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, error = FALSE, warning = FALSE # メッセージを非表示
)
```

----

【編集履歴】

- 2023/01/07：「三角関数の可視化」を追加
- 2023/01/09：「sin関数の可視化」を追加
- 2023/01/15：「sin関数の変形の可視化」を追加
- 2023/01/29：「cos関数の可視化」を追加
- 2023/05/01：「円周の作図」を更新して独立
- 2023/05/03：「tan関数の可視化」を追加
- 2023/05/07：「sin関数の可視化」を更新
- 2023/05/10：「cos関数の可視化」を更新
- 2023/05/22：「cot関数の可視化」を追加
- 2023/06/28：「sec関数の可視化」を追加
- 2023/07/03：「csc関数の可視化」を追加
- 2023/07/09：「三角関数の可視化」を「円関数の可視化」に更新

----


# 円周の作図

　ggplot2パッケージを利用して、円周(circumference)のグラフを作成します。また、円座標系(circular coordinates)をグラフで確認します。\
　詳しい計算については「Matplotlibによる円周の作図」も参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
```

```{r, echo=FALSE}
###資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\
\


## 定義式の確認

　まずは、円の定義式を確認します。\
\

　点 $(a, b)$ を中心とする半径 $r$ の円は、次の式で定義されます。

$$
(x - a)^2 + (y - b)^2
    = r^2
$$

　平面上の座標(x軸とy軸の値)は、それぞれ次の式で計算できます。

$$
\begin{cases}
    x = a + r \cos \theta \\
    y = b + r \sin \theta
\end{cases}
$$

　$\sin \theta$ はサイン関数、$\cos \theta$ はコサイン関数です。$\theta$ は、中心と点 $(a + r, b)$ を結ぶ線分(原点を中心としたときのx軸の正の部分)と、中心と点 $(x, y)$ を結ぶ線分のなす角の角度に対応します。(正確には、なす角は $180^{\circ}$ 以下の正の値なので、なす角ではないと思いますが適切な呼び方が分かりません。)\
　点 $(x, y)$ は、中心からのユークリッドノルム $\|(x - a, y - b)\| = \sqrt{(x - a)^2 + (y - b)^2}$ が $r$ の点です。\

　原点 $(0, 0)$ を中心とする($a = 0, b = 0$ の)場合は、次の式になります。

$$
x^2 + y^2
    = r^2
$$

　座標は、それぞれ次の式で計算できます。

$$
\begin{cases}
    x = r \cos \theta \\
    y = r \sin \theta
\end{cases}
$$

\ 

　原点を中心とする単位円(半径が1の円)の場合は、次の式になります。

$$
x^2 + y^2
    = 1
$$

　座標は、それぞれ次の式で計算できます。

$$
\begin{cases}
    x = \cos \theta \\
    y = \sin \theta
\end{cases}
$$

\ 

　これらの式を使ってグラフを作成します。\
\


## 円の描画

　次は、円のグラフを作成します。\
\

　円を描画するためのデータフレームを作成します。

```{r}
# 中心の座標を指定
a <- 5
b <- 6

# 半径を指定
r <- 2

# 円の描画用
circle_df <- tibble::tibble(
  theta_deg = seq(from = 0, to = 360, length.out = 361), # 度数法
  theta_rad = theta_deg / 180 * pi, # 弧度法
  x = a + r * cos(theta_rad), 
  y = b + r * sin(theta_rad)
)
circle_df
```

　半径 $r$ を`r`、円の中心のx軸の値 $a$ を`a`、y軸の値 $b$ を`b`として値を指定して、円周上の点の座標を計算します。\
　度数法における角度 $0^{\circ} \leq \theta^{\circ} \leq 360^{\circ}$ の範囲の値を作成して`theta_deg`列とします。\
　`theta_deg`列を用いて、弧度法における角度(ラジアン)を $\theta = \theta^{\circ} \frac{2 \pi}{360}$ で計算して`theta_rad`列とします。$\pi$ は円周率で、`pi`で扱えます。$0^{\circ} = 0 \frac{\pi}{180} = 0$、$360^{\circ} = 360 \frac{\pi}{180} = 2 \pi$ なので、ラジアンは、$0 \leq \theta \leq 2 \pi$ の範囲の値になります。詳しくは「度数法と弧度法の関係」で確認します。\
　`theta_rad`列を用いて、x軸の値 $x = a + r \cos \theta$ とy軸の値 $y = b + r \sin \theta$ を計算して`x, y`列とします。\

　あるいは、ラジアンを作成して、座標を計算します。

```{r}
# 円周の座標を計算
circle_df <- tibble::tibble(
  theta_rad = seq(from = 0, to = 2*pi, length.out = 361), # ラジアン
  x = a + r * cos(theta_rad), 
  y = b + r * sin(theta_rad)
)
circle_df
```

　ラジアンとして用いる $0 \leq \theta \leq 2 \pi$の範囲の値を作成して、同様に座標を計算します。\

　円周のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y, linetype = "circle")) + # 円周
  geom_segment(mapping = aes(x = a, y = b, xend = a+r, yend = b)) + # 半径
  geom_text(mapping = aes(x = a+0.5*r, y = b), 
            label = "r", parse = TRUE, 
            size = 5, hjust = 0.5, vjust = -0.5) + # 半径ラベル
  geom_point(mapping = aes(x = a, y = b), 
             size = 3) + # 中心点
  geom_text(mapping = aes(x = a, y = b), 
            label = "O", parse = TRUE, 
            size = 5, hjust = 0.5, vjust = -0.5) + # 中心ラベル
  scale_linetype_manual(breaks = "circle", values = "solid",
                        label = expression((x - a)^2 + (y - b)^2 == r^2), 
                        name = "formula") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "circle", 
       subtitle = paste0("O=(a, b)=(", a, ", ", b, "), r=", r), 
       x = expression(x == a + r~cos~theta), 
       y = expression(y == b + r~sin~theta))
```

　横軸を $a + r \cos \theta$、縦軸を $b + r \sin \theta$ として、(`geom_line()`ではなく)`geom_path()`で円を描画します。綺麗な円を描画するには、`coord_***()`の`ratio`引数に`1`を指定します。\
　また半径の目安として、(なす角が0の)中心と円周上の点を結ぶ線分を`geom_segment()`で描画しています。\
　数式を表示する場合は、`expression()`の記法で指定します。\

　原点を中心とする半径 $r$ の円全体をx軸方向に $a$、y軸方向に $b$ 移動したグラフになります。\
\

　以上で、円を描画できました。\
\


## 度数法と弧度法の関係

　最後に、度数法における角度と弧度法における角度(ラジアン)の関係をグラフで確認します。\
\


### グラフの作成

　度数法と弧度法の関係を角度目盛を表示したグラフで確認します。\
\

　円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  theta = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(theta), 
  y = r * sin(theta)
)
circle_df
```

　「円の描画」のときと同様にして、円周の座標を計算します。ただし簡単のため、原点を中心とします。\

　角度に関する目盛やラベルを描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
tick_vec <- seq(from = 0, to = 2*denom-1, by = 1)

# 角度目盛ラベルの描画用
rad_label_df <- tibble::tibble(
  theta_deg = tick_vec / denom * 180, # 度数法
  theta_rad = tick_vec / denom * pi, # 弧度法
  x = r * cos(theta_rad), 
  y = r * sin(theta_rad), 
  deg_label = paste0(theta_deg, "*degree"), # 度数法用ラベル
  rad_label = paste0("frac(", tick_vec, ", ", denom, ")~pi"), # 弧度法用ラベル
  angle_label = paste0(deg_label, "==", rad_label) # 度数法・弧度法の対応用ラベル
)
rad_label_df
```

　角度 $\theta$ に関する軸目盛ラベルを $\frac{i}{n} \pi$ の形で表示することにします。1周 $360^{\circ}$ は $2 \pi$ なので、この例では、$i$ を $0$ から $2 n$ 未満の整数とします。$n$ は、半円における目盛の数に対応します。\
　$n$ を`n`、$i$ を`tick_vec`として値を作成します。\

　度数法における角度を $\theta^{\circ} = 180^{\circ} \frac{i}{n}$ で計算して`theta_deg`列、弧度法における角度を $\theta = \frac{i}{n} \pi$ で計算して`theta_rad`列として、円周上の点の座標を計算します。\

　`theta_deg`列や`tick_vec`を用いて、ラベル用の文字列を作成します。数式を表示する場合は、`expression()`の記法を用います。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.2
angle_mark_df <- tibble::tibble(
  theta = seq(from = 0, to = 1/denom*pi, length.out = 100), 
  x = d * cos(theta), 
  y = d * sin(theta)
)
angle_mark_df
```

　この例では、なす角 $\theta$ を示すために、軸目盛1つ分の角マーク(小さい扇型)を表示することにします。\
　そこで、角マーク用のラジアン $0 \leq \theta \leq \frac{\pi}{n}$ を作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.3
angle_label_df <- tibble::tibble(
  theta = 0.5 / denom * pi, 
  x = d * cos(theta), 
  y = d * sin(theta)
)
angle_label_df
```

　角ラベルは、角マークの中点に表示することにします。\
　そこで、角ラベル用のラジアンを $\theta = \frac{\pi}{2 n}$ として、点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\

　円周上に角度目盛を表示したグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 目盛ラベルの表示位置を指定
d <- 1.1

# グラフサイズ用の値を設定
axis_size <- r * d + 0.3

# 円周上の角度目盛を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = rad_label_df, 
            mapping = aes(x = x*d, y = y*d, label = angle_label, 
                          hjust = 1-(x/r*0.5+0.5), vjust = 1-(y/r*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = rad_label_df, 
            mapping = aes(x = x, y = y, angle = theta_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = rad_label_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  geom_segment(mapping = aes(x = 0, y = 0, xend = r, yend = 0)) + # x軸上の半径
  geom_text(mapping = aes(x = 0.5*r, y = 0), 
            label = paste0("r==", r), parse = TRUE, 
            size = 5, hjust = 0.5, vjust = 0) + # 半径ラベル
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), 
            label = "theta", parse = TRUE, 
            size = 5, hjust = 0.5, vjust = 0.5) + # 角ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "degree and radian", 
       subtitle = expression(theta*degree == frac(2*pi, 360) ~ theta), 
       #subtitle = expression(theta == frac(360, 2*pi) ~ theta*degree), 
       x = expression(x == r ~ cos~theta), 
       y = expression(y == r ~ sin~theta))
```

　目盛ラベルの表示位置の調整用の値を`d`とします。\
　また、横・縦方向の表示位置の調整用の引数`hjust, vjust`を、`x, y`列の値を使って指定しています。$r \cos \theta, r \sin \theta$ (`x, y`列)は $-r$ から $r$ の値をとります。$r$ で割ると $-1$ から $1$ の値になり、さらに $0.5$ を掛けると $-0.5$ から $0.5$ の値になり、$0.5$ を足すと $0$ から $1$ の値になります。この値を $1$ から引いた値を使うといい感じの表示位置になります。`hjust, vjust`を指定(こんな面倒な設定を)せずに、`d`を少し大きくしても同様の図になります。\
　角度目盛の指示線を`|`で表示します。線の向きは角度列`theta_deg`を90°回転させた方向です。\

　度数法 $\theta^{\circ}$ と弧度法 $\theta$ は、$\theta = \frac{2 \pi}{360} \theta^{\circ}$、$\theta^{\circ} = \frac{360}{2 \pi} \theta$ の関係です。つまり、$\theta^{\circ} = 0^{\circ}$ のとき $\theta = 0$、$\theta^{\circ} = 180^{\circ}$ のとき $\theta = \pi$、$\theta^{\circ} = 360^{\circ}$ のとき $\theta = 2 \pi$ です。\
　また、$\cos \theta = \cos (\theta + 2 \pi)$、$\sin \theta = \sin (\theta + 2 \pi)$ なので、$2 \pi$ で1周期です。\
　円の大きさ(半径)や中心の位置(座標)は角度に影響しません。\
\


### アニメーションの作成

　続いて、なす角と円周上の点の関係をアニメーションで確認します。\
\

　フレームごとの角度を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# フレームごとの角度を指定
theta_n <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]

# フレームごとの角度ラベルを作成
frame_label_vec <- paste0(
  "θ° = ", round(theta_n/pi*180, digits = 1), "°, ", 
  "θ = ", round(theta_n/pi, digits = 2), "π"
)
head(theta_n); head(frame_label_vec)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を等間隔に作成します。範囲を $2 \pi$ の倍数にして`frame_num + 1`個の等間隔の値を作成して、最後の値を除くと繋がりの良いアニメーションになります。\
　この例では、フレームごとの角度をグラフに表示するために、`theta_n`を用いた文字列をフレーム切替用のラベル列として使います。作図自体には不要な処理です。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# フレームごとの円周上の点の座標を計算
anim_angle_point_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
  theta = theta_n, 
  x = r * cos(theta), 
  y = r * sin(theta)
)
anim_angle_point_df
```

　フレーム番号を`1`から`frame_num`の整数として、フレームラベル`frame_label_vec`と合わせて格納します。どちらか1つの列があれば作図できます。\
　また、フレームごとの角度`theta_n`を用いて、円周上の各点の座標を計算します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    theta = seq(from = 0, to = theta_n[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(theta), 
    y = d * sin(theta)
  )
anim_angle_mark_df
```

　フレームごとにグループ化して、`summarise()`を使ってフレーム(角度)ごとに`0`から`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.2
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
  theta = 0.5 * theta_n, 
  x = d * cos(theta), 
  y = d * sin(theta)
)
anim_angle_label_df
```

　x軸の正の部分とのなす角の中点にラベルと配置するために、`0.5 * theta_n`を用いて円弧上の点の座標を計算します。\

　フレームごとに角度を変化させたアニメーションを作成します。

```{r, eval=FALSE}
# ラベルの表示位置を指定
d <- 1.1

# グラフサイズ用の値を設定
axis_size <- d + 0.3

# 角度と円周上の点のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = rad_label_df, 
            mapping = aes(x = x*d, y = y*d, label = angle_label, 
                          hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = rad_label_df, 
            mapping = aes(x = x, y = y, angle = theta_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = rad_label_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  geom_point(data = anim_angle_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_angle_point_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               size = 1) + # 原点と円周上の点の線分
  geom_segment(mapping = aes(x = 0, y = 0, xend = r, yend = 0), 
               size = 1) + # 正のx軸上の半径
  geom_text(mapping = aes(x = 0.5*r, y = 0), 
            label = "r", parse = TRUE, 
            size = 5, hjust = 0.5, vjust = -0.5) + # 半径ラベル
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), 
            label = "theta", parse = TRUE, 
            size = 5, hjust = 0.5, vjust = 0.5) + # 角ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "degree and radian", 
       subtitle = "{current_frame}", 
       x = expression(x == r ~ cos~theta), 
       y = expression(y == r ~ sin~theta))

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 600)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレームラベル列`frame_label`(またはフレーム番号列`frame_i`)を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

　ラジアン(角度) $\theta$ が大きくなるほど円周上の点が反時計回りに移動するのが分かります。角度が負の値のときは時計回りの方向にできるなす角になります。\
\

　この記事では、円を可視化しました。次の記事からは、三角関数(円関数)を可視化していきます。\
\


# sin関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるsin関数(正弦関数・サイン関数・sine function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
###資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## sin関数の作図

　次に、sin関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　sin関数の曲線を描画するためのデータフレームを作成します。

```{r}
# sin関数を計算
sin_df <- tibble::tibble(
  t = theta_vec, 
  sin_t = sin(theta_vec), 
  cos_t = cos(theta_vec)
)
sin_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。sin関数は`sin()`で計算できます。cos関数の値は比較に使います。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

</details>

　sin関数のグラフを作成します。

```{r, fig.width=9, fig.height=3, dpi=100}
# sin関数を作図
ggplot() + 
  geom_line(data = sin_df, 
            mapping = aes(x = t, y = sin_t, linetype = "sin"), 
            size = 1) + # sin曲線
  geom_line(data = sin_df, 
            mapping = aes(x = t, y = cos_t, linetype = "cos"), 
            size = 1) + # cos曲線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("sin", "cos"), 
                        values = c("solid", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "sine function", 
       x = expression(theta), 
       y = expression(sin~theta))
```

　x軸を $\theta$、y軸を $\sin \theta$ として、`geom_line()`でsin関数の曲線を描画します。また、$\cos \theta$ の曲線を点線で描画します。\
　cos関数の曲線を正の方向へ $\frac{\pi}{2}$ 移動するとsin関数の曲線になるのが分かります。この関係を式で表すと $\sin \theta = \cos (\theta - \frac{\pi}{2})$ です。詳しくは「sin関数の振幅・周期・平行移動の変形の可視化
」を参照してください。\
\


## 単位円の作図

　続いて、sin関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のsin関数の可視化

　次は、単位円上における三角関数(sin・cos)のグラフを作成します。\
\


### グラフの作成

　変数を固定したsin関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2点の座標を格納します。原点の座標は、作図時に値を引数に指定します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("sin", "sin", "cos", "cos") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, cos(theta), 
    0, 0
  ), 
  y_from = c(
    0, 0, 
    0, sin(theta)
  ), 
  x_to = c(
    0, cos(theta), 
    cos(theta), cos(theta)
  ), 
  y_to = c(
    sin(theta), sin(theta), 
    0, sin(theta)
  )
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sin", "cos") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0, 
    0.5 * cos(theta)
  ), 
  y = c(
    0.5 * sin(theta),
    0
  ), 
  angle = c(90, 0), 
  v = c(-0.5, 1), 
  fnc_label = c("sin~theta", "cos~theta") # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ラベルの表示角度を`angle`列、表示角度に応じた上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
axis_size <- 1.3

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　sin関数の値は、円周上の点 $(\cos \theta, \sin \theta)$ のy軸の値(高さ)です。\
\


### アニメーションの作成

　続いて、変数の値を変化させたsin関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 \pi$ の倍数にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 2) |> # (2は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　フレーム数分の点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標を格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("sin", "sin", "cos", "cos") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num)
  ), 
  y_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), sin(theta_i)
  ), 
  x_to = c(
    rep(0, times = frame_num), cos(theta_i), 
    cos(theta_i), cos(theta_i)
  ), 
  y_to = c(
    sin(theta_i), sin(theta_i), 
    rep(0, times = frame_num), sin(theta_i)
  ), 
  label_flag = c(TRUE, FALSE, TRUE, FALSE) |> 
    rep(each = frame_num), # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 4) |> # (4は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　「グラフの作成」のときと同様に、線分ごとに`frame_num`個の座標を格納します。\
　また、関数ラベルを描画する線分を`label_flag`列に指定しておきます。関数ごとに、ラベルを表示する1つの線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 0) |> 
      rep(each = frame_num), 
    v = c(-0.5, 1) |> 
      rep(each = frame_num), 
    fnc_label = c("sin~theta", "cos~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`から`label_flag`列が`TRUE`の行(線分)を取り出して、`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
axis_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 600)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\
\


## 単位円上の点とsin関数曲線の関係の可視化

　最後は、単位円上におけるsin関数の値(直線)と、sin関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したsin関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のsin関数の可視化」のコードで5つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.25
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("sin", "sin", "cos", "cos") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, cos(theta), 
    0, 0
  ), 
  y_from = c(
    0, 0, 
    0, sin(theta)
  ), 
  x_to = c(
    0, cos(theta), 
    cos(theta), cos(theta)
  ), 
  y_to = c(
    sin(theta), sin(theta), 
    0, sin(theta)
  )
)

# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sin", "cos") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0, 
    0.5 * cos(theta)
  ), 
  y = c(
    0.5 * sin(theta),
    0
  ), 
  angle = c(90, 0), 
  v = c(-0.5, 1), 
  fnc_label = c("sin~theta", "cos~theta") # 関数ラベル
)
```

　単位円における点とsin曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_size <- 1.3

# sin曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = cos(theta), 
  x_to = axis_size+l, 
  y = sin(theta)
)
segment_circle_df
```

　単位円における点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=5, fig.height=5, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y), 
               size = 1, linetype = "dotted") + # sin曲線との対応線
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のsin関数の可視化」のときと同様に、作図します。\
\

　sin関数の曲線を描画するためのデータフレームを作成します。

```{r}
# sin関数を計算
sin_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  sin_t = sin(t)
)
sin_df
```

　「sin関数の作図」のときと同様にして、曲線の座標を計算します。\

　sin曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# sin直線との対応線の座標を格納
l <- 0.8
d <- 1.1
segment_sin_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(sin(theta), sin(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-axis_size*d, sin(theta))
)
segment_sin_df
```

　曲線上の点からx軸とy軸へ垂線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「sin関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　sin関数曲線のグラフを作成します。

```{r, fig.width=10, fig.height=5, dpi=100}
# 関数ラベル用の文字列を作成
sin_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ")"
)

# sin関数曲線を作図
sin_graph <- ggplot() + 
  geom_line(data = sin_df, 
            mapping = aes(x = t, y = sin_t), 
            size = 1) + # sin曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = sin_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_sin_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # sin直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "sine function", 
       subtitle = parse(text = sin_label), 
       x = expression(theta), 
       y = expression(sin~theta))
sin_graph
```

　「sin関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=15, fig.height=5, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, sin_graph, guides = "collect")
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、点のy軸の値と、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。\
\


#### 1周期

　円周上を1周した際のsin関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos")

# グラフサイズ用の値を設定
axis_size <- 1.3

# sin関数を計算
sin_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  sin_t = sin(t)
)

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("sin", "sin", "cos", "cos") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, cos(theta), 
      0, 0
    ), 
    y_from = c(
      0, 0, 
      0, sin(theta)
    ), 
    x_to = c(
      0, cos(theta), 
      cos(theta), cos(theta)
    ), 
    y_to = c(
      sin(theta), sin(theta), 
      0, sin(theta)
    )
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sin", "cos") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0, 
      0.5 * cos(theta)
    ), 
    y = c(
      0.5 * sin(theta),
      0
    ), 
    angle = c(90, 0), 
    v = c(-0.5, 1), 
    fnc_label = c("sin~theta", "cos~theta") # 関数ラベル
  )
  
  # sin曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = cos(theta), 
    x_to = axis_size+l, 
    y = sin(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # sin曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # sin直線との対応線の座標を格納
  l <- 0.8
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(sin(theta), sin(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-axis_size*d, sin(theta))
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = sin_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sin直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, sin_graph, guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　sin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sin_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sin_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\
\


#### n周期

　円周上を複数回周回した際のsin関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos")

# グラフサイズ用の値を設定
axis_size <- 1.3

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("sin", "sin", "cos", "cos") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, cos(theta), 
      0, 0
    ), 
    y_from = c(
      0, 0, 
      0, sin(theta)
    ), 
    x_to = c(
      0, cos(theta), 
      cos(theta), cos(theta)
    ), 
    y_to = c(
      sin(theta), sin(theta), 
      0, sin(theta)
    )
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sin", "cos") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0, 
      0.5 * cos(theta)
    ), 
    y = c(
      0.5 * sin(theta),
      0
    ), 
    angle = c(90, 0), 
    v = c(-0.5, 1), 
    fnc_label = c("sin~theta", "cos~theta") # 関数ラベル
  )
  
  # sin曲線との対応線の座標を格納
  l <- 0.6
  segment_circle_df <- tibble::tibble(
    x = cos(theta), 
    x_to = -axis_size-l, 
    y = sin(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # sin曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # sin関数を計算
  sin_df <- tibble::tibble(
    t = theta_vec, 
    sin_t = sin(t)
  )
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # sin直線との対応線の座標を格納
  l <- 0.8
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(sin(theta), sin(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-axis_size*d, sin(theta))
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = sin_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sin直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(sin_graph, circle_graph, guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　sin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sin_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sin_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が1周する $2 \pi$ の間隔で、曲線が同じ形になるのが分かります。\
\

　この記事では、sin関数を可視化しました。次の記事では、cos関数を可視化します。\
\


# sin関数の振幅・周期・平行移動の変形の可視化

　sin関数に関して、関数または変数の係数や定数項による波の振幅・周期・平行移動の変化をグラフで確認します。sin関数の作図については「sin関数の可視化」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
### 資料作成用:(チェック用)

# 利用パッケージ
library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\
\


## 関数をk倍する場合

　まずは、sin関数$\sin \theta$の係数と振幅の関係を可視化します。\
\


### グラフの作成

　角度$\theta$を固定した$k \sin \theta$をグラフで確認します。\
\

　関数の係数と角度を指定します。

```{r}
# 関数の係数を指定
k <- 3

# 角度を指定
alpha <- 120

# ラジアンに変換
theta <- alpha / 180 * pi
theta
```

　sin関数の係数$k$を指定します。\
　度数法における角度$\alpha$を指定して、弧度法における角度(ラジアン)$\theta = \alpha \frac{\pi}{180}$に変換します。$\pi$は円周率で`pi`で扱えます。\

　曲線上に関数の点を描画するためのデータフレームを作成します。

```{r}
# 関数の点の描画用
point_df <- tibble::tibble(
  theta = theta, 
  sin_theta = sin(theta) * c(1, k), 
  cos_theta = cos(theta) * c(1, k), 
  fnc = c("sin theta", "k sin theta")
)
point_df
```

　sin関数$\sin \theta$とk倍したsin関数$k \sin \theta$、cos関数$\cos \theta$とk倍したcos関数$k \cos \theta$を計算して、$\theta$と共に格納します。(オブジェクト名と列名が重複するため、エラーにならないように処理しています。)\
　作図時の色分けなど用に、元の関数とk倍した値を区別するための列`fnc`を作成します。\

　単位円とk倍した円を描画するためのデータフレームを作成します。

```{r}
# 単位円の描画用
tmp_vals <- seq(from = 0, to = 2*pi, by = 0.05)
circle_df <- tibble::tibble(
  theta = c(tmp_vals, tmp_vals), 
  sin_theta = c(sin(tmp_vals), sin(tmp_vals)*k), 
  cos_theta = c(cos(tmp_vals), cos(tmp_vals)*k), 
  fnc = rep(c("sin theta", "k sin theta"), each = length(tmp_vals))
)
circle_df
```

　単位円の作図用のラジアン$0 \leq \theta \leq 2 \pi$を作成して、$\sin \theta, \cos \theta$を計算します。単位円の座標は、x軸の値$x = \cos \theta$、y軸の値$y = \sin \theta$に対応します。\
　同様に、k倍した値も格納します。こちらは、半径が$k$の円周上の点になります。\

　単位円上に角度目盛を描画するためのデータフレームを作成します。

```{r}
# 角度目盛の描画用
tick_df <- tibble::tibble(
  alpha = 0:11 * 30, 
  theta = 0:11 / 6 * pi, 
  x = cos(theta), 
  y = sin(theta), 
  rad_label = paste0("frac(", 0:11, ", 6)~pi")
)
tick_df
```

　$30^{\circ} = 30 \frac{\pi}{180} = \frac{\pi}{6}$間隔で、$\frac{n}{6} \pi\ (n = 0, \dots, 11)$の形で目盛を表示することにします。\
　単位円のときと同様に、x軸とy軸の値を計算して、ラベルと合わせて格納します。ラベルとして数式を表示する場合は、`expression()`の記法を使います。\

　角度を表示するためのデータフレームを作成します。

```{r}
# 半径の描画用
radius_df <- tibble::tibble(
  x_from = c(0, 0, 0), 
  y_from = c(0, 0, 0), 
  x_to = c(1, cos(theta), cos(theta)*k), 
  y_to = c(0, sin(theta), sin(theta)*k), 
  fnc = c("r", "sin theta", "k sin theta")
)

# 角度マークの描画用
d <- 0.1
angle_df <- tibble::tibble(
  theta = seq(from = min(0, theta), to = max(0, theta), length.out = 100), 
  x = cos(theta) * d, 
  y = sin(theta) * d
)

# 角度ラベルの描画用
d <- 0.2
angle_label_df <- tibble::tibble(
  theta = 0.5 * theta, 
  x = cos(theta) * d, 
  y = sin(theta) * d, 
  angle_label = "theta"
)
radius_df; angle_df; angle_label_df
```

　$0^{\circ}, \theta$のそれぞれの角度における半径を描画するために、原点と円周上の点を結ぶ線分の座標を格納して`radius_df`とします。始点の座標を`x_from, y_from`、終点の座標を`x_to, y_to`列とします。\
　扇形(角度マーク)を描画するための値(ラジアン)を作成して、x軸とy軸の値を計算して`angle_df`とします。$\theta$が正の値($\theta > 0$)のときは$0$から$\theta$、負の値($\theta < 0$)のときは$\theta$から$0$の値となるように処理します。\
　角度の中点に配置するように座標とラベル用の文字列を格納して`angle_label_df`とします。\

　単位円におけるsin関数の値を描画するためのデータフレームを作成します。

```{r}
# sin関数の線の描画用
sin_line_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta)*k), 
  y_from = c(0, 0), 
  x_to = c(cos(theta), cos(theta)*k), 
  y_to = c(sin(theta), sin(theta)*k), 
  fnc = c("sin theta", "k sin theta")
)

# sin関数の線ラベルの描画用
sin_label_df <- sin_line_df |> 
  dplyr::group_by(fnc) |> # 中点の計算用
  dplyr::mutate(
    # 中点に配置
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to))
  ) |> 
  dplyr::ungroup() |> 
  tibble::add_column(
    fnc_label = c("sin~theta", "k~sin~theta")
  ) |> 
  dplyr::select(x, y, fnc, fnc_label)
sin_line_df; sin_label_df
```

　sin関数の値は、角度$\theta$における単位円上の点$(\cos \theta, \sin \theta)$と、$x = 0$の直線への垂線との交点$(\cos \theta, 0)$を結ぶ線分で表現できます。同様に、k倍した値も格納します。それぞれ始点と終点の座標を格納して`sin_line_df`とします。\
　sin関数の垂線(線分)の中点に配置するように座標とラベル用の文字列を格納して`sin_label_df`とします。\

　単位円上の点とsin関数上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# 描画領域のサイズを設定
axis_size <- max(1, abs(k)) + 0.5
l         <- 1.5

# サイン波との対応用
segment_circle_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta)*k), 
  y_from = c(sin(theta), sin(theta)*k), 
  x_to = c(-axis_size-l, -axis_size-l), 
  y_to = c(sin(theta), sin(theta)*k), 
  fnc = c("sin theta", "k sin theta")
)
segment_circle_df
```

　円周上の点からy軸への垂線を引くように座標を指定します。作図時に、隣のグラフに届かないような長さ`l`を指定します。\
　また、2つのグラフの描画範囲を固定するために、`axis_size`として値を指定しておきます。\

　単位円のグラフを作成します。

```{r, fig.width=6, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", k==", k, 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 単位円を作図
d <- 1.2
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = cos_theta, y = sin_theta, group = fnc, linetype = fnc), 
            size = 1) + # 単位円
  geom_text(data = tick_df, 
            mapping = aes(x = x, y = y, angle = alpha+90), 
            label = "|", size = 2) + # 角度目盛
  geom_text(data = tick_df, 
            mapping = aes(x = x*d, y = y*d, label = rad_label, 
                          hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
  geom_path(data = angle_df, 
            mapping = aes(x = x, y = y)) + # 角度マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y, label = angle_label), parse = TRUE) + # 角度ラベル
  geom_segment(data = sin_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # sin関数
  geom_text(data = sin_label_df, 
             mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
             angle = 90, vjust = 1) + # sin関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # sin波との対応線
  geom_point(data = point_df, 
             mapping = aes(x = cos_theta, y = sin_theta), 
             size = 4) + # 円上の点
  scale_color_manual(breaks = c("sin theta", "k sin theta"), 
                     values = c("red", "blue")) + # 線の色
  scale_linetype_manual(breaks = c("sin theta", "k sin theta", "r"), 
                        values = c("solid", "dashed", "solid")) + # 線の種類
  theme(legend.position = "none") + # 凡例の非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = fnc_label), 
       x = "x", y = "y")
circle_graph
```

　x軸をcos関数の値、y軸をsin関数の値として、(`geom_line()`ではなく)`geom_path()`で曲線(円)を描画します。綺麗な円を描画するには`coord_***()`の`ratio`引数を`1`にします。\
　ラベル配置位置の調整用の値を`d`として、`tick_df`を使って角度ラベルを描画します。また、x軸・y軸方向の配置位置の調整用の引数`hjust, yjust`に、`x, y`列の値を使って指定しています。`x, y`列($\sin \theta, \cos \theta$)は―1から1の値をとります。0.5を掛けると-0.5から0.5の値となり、さらに0.5を足すと0から1の値になります。(`hjust, vjust`を指定せずに`d`を少し大きくしても同様の図になります。)\
　半径などの線分を`geom_segment()`で描画します。\

　サイン波の作図用のラジアンの値を作成します。

```{r}
# 作図用のラジアンの値を作成
theta_vals <- seq(from = theta-2*pi, to = theta+2*pi, by = 0.01)
head(theta_vals)
```

　この例では、指定した$\theta$を中心に前後$2 \pi$を範囲とします。範囲(サイズ)を$2 \pi$にすると、1周期分の曲線を描画できます。この例は、2周期になります。\

　サイン波の描画するためのデータフレームを作成します。

```{r}
# サイン波の描画用
sin_curve_df <- tibble::tibble(
  theta = c(theta_vals, theta_vals), 
  sin_theta = c(sin(theta_vals), sin(theta_vals)*k), 
  fnc = rep(c("sin theta", "k sin theta"), each = length(theta_vals))
)
sin_curve_df
```

　作図用の$\theta$の値と$\sin \theta, k \sin \theta$の値を格納します。\

　先ほどと同様に、sin関数上の点と円周上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# x軸(角度)・単位円との対応用
d <- 1.1
segment_sin_df <- tibble::tibble(
  x_from = c(theta, theta, theta, theta), 
  y_from = c(sin(theta), sin(theta), sin(theta)*k, sin(theta)*k), 
  x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
  y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta)*k), 
  fnc = rep(c("sin theta", "k sin theta"), each = 2)
)
segment_sin_df
```

　曲線上の点からx軸・y軸への垂線を引くように座標を指定します。\

　x軸目盛として、角度ラベルを描画するのに用いるベクトルを作成します。

```{r}
# x軸目盛ラベルの描画用の値を作成
tick_min <- floor(min(theta_vals) * 6 / pi)
tick_vec <- seq(from = tick_min, to = tick_min+25, by = 1)
tick_vec
```

　単位円の目盛と同様に、$30^{\circ} = \frac{\pi}{6}$間隔で目盛を表示することにします。$\frac{n}{6} \pi$の形で目盛を描画するために、作図用の角度$\theta$の最小値を、`floor()`で小数点以下を切り捨てて、$\frac{6}{\pi}$倍して、最小値の$n$を求めて`tick_min`とします。\
　`theta_vals`のサイズが$4 \pi$の場合は、$n$から$n+25$までの整数を生成して`tick_vec`とします。\

　サイン波のグラフを作成します。

```{r, fig.width=12, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", k==", k, 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", k~sin~theta==", round(sin(theta)*k, digits = 2), 
  ")"
)

# サイン波を作図
sin_graph <- ggplot() + 
  geom_line(data = sin_curve_df, 
            mapping = aes(x = theta, y = sin_theta, color = fnc), 
            size = 1) + # sin関数
  geom_segment(data = segment_sin_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # 単位円との対応線
  geom_point(data = point_df, 
             mapping = aes(x = theta, y = sin_theta), 
             size = 4) + # 関数曲線上の点
  scale_x_continuous(breaks = tick_vec/6*pi, 
                     labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
  scale_color_manual(breaks = c("sin theta", "k sin theta"), 
                     values = c("red", "blue"), 
                     labels = parse(text = c("sin~theta", "k~sin~theta")), 
                     name = "function") + # 線の色
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(min(theta_vals), max(theta_vals)), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "sine curve", 
       subtitle = parse(text = fnc_label), 
       x = expression(theta), y = expression(f(theta)))
sin_graph
```

　x軸を$\theta$、y軸をsin関数の値として`geom_line()`で曲線を描画します。\
　`scale_x_continuous()`でx軸目盛を設定します。目盛の表示位置の引数`breaks`に`tick_vec`を$\frac{\pi}{6}$倍した値、目盛ラベルの引数`labels`に$\frac{n}{6} \pi$の形の文字列を指定します。\

　2つのグラフを並べて描画します。

```{r, fig.width=18, fig.height=6}
# グラフを並べて描画
patchwork::wrap_plots(sin_graph, circle_graph) + 
  patchwork::plot_layout(guides = "collect")
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　点$(k \cos \theta, k \sin \theta)$は、半径がkの円(単位円をk倍した円)上の点になります。よって、サイン波の振幅もk倍になるのを確認できます。\

・$\theta^{\circ} = 120^{\circ}, k = -1$のグラフ

![](../figure/curves/sin_t120_k-1.png)

　$k$が負の値のとき、円周上の点については原点に対して反転し、サイン波については$x = 0$の直線に対して反転したグラフになります。また、「変数をa倍する場合」で確認する$a = -1$のとき、「変数にbを加える場合」で確認する$b = \pi = 180^{\circ}$のときと同じグラフになることから、$-\sin \theta = \sin(-\theta) = \sin(\theta + 180^{\circ})$が成り立つのを確認できます。\

・$\theta^{\circ} = 120^{\circ}, k = \frac{1}{2}$のグラフ

![](../figure/curves/sin_t120_k0_5.png)

　$k$が1未満のときは、単位円(振幅が-1から1)よりも小さくなります。\
\


### アニメーションの作成

　続いて、角度を変化させたアニメーションで確認します。\
\

　フレーム数と角度の範囲を指定して、角度として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 100

# 関数の係数を指定
k <- 3

# 角度の範囲を指定
theta_min <- -2 * pi
theta_max <- 2 * pi

# フレームごとの角度を作成
theta_i <- seq(from = theta_min, to = theta_max, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`と、角度(ラジアン)$\theta$の最小値`theta_min`・最大値`theta_max`を指定して、`frame_num`個の等間隔の$\theta$の値を作成します。三角関数は$2 \pi$で1周期なので、最小値に$2 \pi$の$n$倍を加えた値を最大値にして、等間隔に切り分け最大値自体を除くと、最後のフレームと最初のフレームの繋がりが良くなります。\

<details><summary>・コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出して作図し、グラフを書き出します

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "trigonometric/figure/tmp_folder"

# 描画領域のサイズを設定
axis_size <- max(1, abs(k)) + 0.5
l         <- 1.5

# 単位円の描画用
tmp_vals <- seq(from = 0, to = 2*pi, by = 0.05)
circle_df <- tibble::tibble(
  theta = c(tmp_vals, tmp_vals), 
  sin_theta = c(sin(tmp_vals), sin(tmp_vals)*k), 
  cos_theta = c(cos(tmp_vals), cos(tmp_vals)*k), 
  fnc = rep(c("sin theta", "k sin theta"), each = length(tmp_vals))
)

# 角度ごとに作図
for(i in 1:frame_num) {
  
  # i番目の角度を取得
  theta <- theta_i[i]
  
  # 関数の点の描画用
  point_df <- tibble::tibble(
    theta = theta, 
    sin_theta = sin(theta) * c(1, k), 
    cos_theta = cos(theta) * c(1, k), 
    fnc = c("sin theta", "k sin theta")
  )
  
  # 半径の描画用
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0), 
    y_from = c(0, 0, 0), 
    x_to = c(1, cos(theta), cos(theta)*k), 
    y_to = c(0, sin(theta), sin(theta)*k), 
    fnc = c("r", "sin theta", "k sin theta")
  )
  
  # 角度マークの描画用
  d <- 0.1
  angle_df <- tibble::tibble(
    theta = seq(from = min(0, theta), to = max(0, theta), length.out = 100), 
    x = cos(theta) * d, 
    y = sin(theta) * d
  )
  
  # 角度ラベルの描画用
  d <- 0.2
  angle_label_df <- tibble::tibble(
    theta = 0.5 * theta, 
    x = cos(theta) * d, 
    y = sin(theta) * d, 
    angle_label = "theta"
  )
  
  # sin関数の線の描画用
  sin_line_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta)*k), 
    y_from = c(0, 0), 
    x_to = c(cos(theta), cos(theta)*k), 
    y_to = c(sin(theta), sin(theta)*k), 
    fnc = c("sin theta", "k sin theta")
  )
  
  # sin関数の線ラベルの描画用
  sin_label_df <- sin_line_df |> 
    dplyr::group_by(fnc) |> # 中点の計算用
    dplyr::mutate(
      # 中点に配置
      x = median(c(x_from, x_to)), 
      y = median(c(y_from, y_to))
    ) |> 
    dplyr::ungroup() |> 
    tibble::add_column(
      fnc_label = c("sin~theta", "k~sin~theta")
    ) |> 
    dplyr::select(x, y, fnc, fnc_label)
  
  # サイン波との対応用
  segment_circle_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta)*k), 
    y_from = c(sin(theta), sin(theta)*k), 
    x_to = c(-axis_size-l, -axis_size-l), 
    y_to = c(sin(theta), sin(theta)*k), 
    fnc = c("sin theta", "k sin theta")
  )
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", k==", k, 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円を作図
  d <- 1.2
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = cos_theta, y = sin_theta, group = fnc, linetype = fnc), 
              size = 1) + # 単位円
    geom_text(data = tick_df, 
              mapping = aes(x = x, y = y, angle = alpha+90), 
              label = "|", size = 2) + # 角度目盛
    geom_text(data = tick_df, 
              mapping = aes(x = x*d, y = y*d, label = rad_label, 
                            hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
    geom_path(data = angle_df, 
              mapping = aes(x = x, y = y)) + # 角度マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y, label = angle_label), parse = TRUE) + # 角度ラベル
    geom_segment(data = sin_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # sin関数
    geom_text(data = sin_label_df, 
               mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
               angle = 90, vjust = 1) + # sin関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # sin波との対応線
    geom_point(data = point_df, 
               mapping = aes(x = cos_theta, y = sin_theta), 
               size = 4) + # 円上の点
    scale_color_manual(breaks = c("sin theta", "k sin theta"), 
                       values = c("red", "blue")) + # 線の色
    scale_linetype_manual(breaks = c("sin theta", "k sin theta", "r"), 
                          values = c("solid", "dashed", "solid")) + # 線の種類
    theme(legend.position = "none") + # 凡例の非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "unit circle", 
         subtitle = parse(text = fnc_label), 
         x = "x", y = "y")
  
  # 作図用のラジアンの値を作成
  theta_size <- 2 * pi
  theta_vals <- seq(from = max(theta_min, theta-theta_size), to = theta, by = 0.01)
  
  # サイン波の描画用
  sin_curve_df <- tibble::tibble(
    theta = c(theta_vals, theta_vals), 
    sin_theta = c(sin(theta_vals), sin(theta_vals)*k), 
    fnc = rep(c("sin theta", "k sin theta"), each = length(theta_vals))
  )
  
  # x軸(角度)・単位円との対応用
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x_from = c(theta, theta, theta, theta), 
    y_from = c(sin(theta), sin(theta), sin(theta)*k, sin(theta)*k), 
    x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
    y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta)*k), 
    fnc = rep(c("sin theta", "k sin theta"), each = 2)
  )
  
  # x軸目盛ラベルの描画用の値を作成
  tick_min <- floor((theta-theta_size) * 6 / pi)
  tick_vec <- seq(from = tick_min, to = tick_min+13, by = 1)
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", k==", k, 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", k~sin~theta==", round(sin(theta)*k, digits = 2), 
    ")"
  )
  
  # サイン波を作図
  sin_graph <- ggplot() + 
    geom_line(data = sin_curve_df, 
              mapping = aes(x = theta, y = sin_theta, color = fnc), 
              size = 1) + # sin関数
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # 単位円との対応線
    geom_point(data = point_df, 
               mapping = aes(x = theta, y = sin_theta), 
               size = 4) + # 関数曲線上の点
    scale_x_continuous(breaks = tick_vec/6*pi, 
                       labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
    scale_color_manual(breaks = c("sin theta", "k sin theta"), 
                       values = c("red", "blue"), 
                       labels = parse(text = c("sin~theta", "k~sin~theta")), 
                       name = "function") + # 線の色
    #theme(legend.position = "none") + # 凡例の非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta-theta_size, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine curve", 
         subtitle = parse(text = fnc_label), 
         x = expression(theta), y = expression(f(theta)))
  
  # グラフを並べて描画
  graph <- patchwork::wrap_plots(sin_graph, circle_graph) + 
      patchwork::plot_layout(guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1200, height = 600, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, "/", frame_num, appendLF = FALSE)
}
```

　「グラフの作成」で作成した`tick_df`も使います。\
　変数の値(角度)ごとに「グラフの作成」と同様に処理して、作成したグラフを`ggsave()`で保存します。\
　保存用のフォルダは空である必要があります。また、画像ファイルの読み込み時に、文字列基準で書き出した順番になるようなファイル名である必要があります。\
　($\theta = 0$のときの作図では、`angle_df`が1行しか値を持たないため、`geom_path()`で描画できずメッセージが表示されます。)\

　アニメーション(gif画像)を作成します。

```{r, eval=FALSE}
# ファイル名を取得
file_name_vec <- list.files(dir_path)

# ファイルパスを作成
file_path_vec <- paste0(dir_path, "/", file_name_vec)

# gif画像を作成
file_path_vec |> 
  magick::image_read() |> 
  magick::image_animate(fps = 1, dispose = "previous") |> 
  magick::image_write_gif(path = "trigonometric/figure/curves/sin_k.gif", delay = 0.1) -> tmp_path
```

　`list.files()`で`dir_path`フォルダ内のファイル名を取得して、ファイルパスを作成します。\
　`image_read()`で画像を読み込んで、`image_animate()`でgifファイルに変換して、`image_write_gif()`でgifファイルを書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\

</details>

\ 

・$k = 3$の推移

![](../figure/curves/sin_k3.gif)

　sin関数をk倍することで振幅がk倍になりますが、$2 \pi$間隔の周期(角速度)に変化がないのを確認できます。\

・$k = -3$の推移

![](../figure/curves/sin_k-3.gif)

　k倍したsin関数と-k倍sin関数では、常に円周上の点が$180^{\circ} = \pi$変化(進む・戻る)した点を推移するのが分かります。\

・$k = -1$の推移

![](../figure/curves/sin_k-1.gif)

　後で、$a = -1$や$b = \pi$のグラフと比較します。\
\


## 関数にlを加える場合

　sin関数$\sin \theta$に定数$l$を加えた$\sin \theta + l$のグラフは、$\sin \theta$の曲線がy軸方向に$l$だけ平行移動します。定数項$l$と平行移動の関係は直感的な変化なので、個別の可視化は省略します。最後の「sin関数の変形」で確認することにします。\
\


## 変数をa倍する場合

　次は、sin関数の変数$\theta$の係数と周期(波長)の関係を可視化します。\
\


### グラフの作成

　角度$\theta$を固定した$\sin(a \theta)$をグラフで確認します。\
\

　変数の係数と角度を指定します。

```{r}
# 変数の係数を指定
a <- 4

# 角度を指定
alpha <- 60

# ラジアンに変換
theta <- alpha / 180 * pi
theta
```

　sin関数の変数(角度)の係数$a$と、角度(ラジアン)$\theta$を指定します。\

　曲線上に関数の点を描画するためのデータフレームを作成します。

```{r}
# 関数の点の描画用
point_df <- tibble::tibble(
  theta = c(theta, theta), 
  sin_theta = sin(theta * c(1, a)), 
  cos_theta = cos(theta * c(1, a)), 
  fnc = c("sin theta", "sin(a theta)")
)
point_df
```

　sin関数$\sin \theta$とa倍した変数によるsin関数$\sin (a \theta)$、cos関数$\cos \theta$とa倍した変数によるcos関数$\cos(a \theta)$を計算して、$\theta$と共に格納します。\
　作図時の色分けなど用に、元の関数とa倍した変数による値を区別するための列`fnc`を作成します。\

　単位円を描画するためのデータフレームを作成します。

```{r}
# 単位円の描画用
circle_df <- tibble::tibble(
  theta = seq(from = 0, to = 2*pi, by = 0.04), 
  sin_theta = sin(theta), 
  cos_theta = cos(theta)
)

# 角度目盛の描画用
tick_df <- tibble::tibble(
  alpha = 0:11 * 30, 
  theta = 0:11 / 6 * pi, 
  x = cos(theta), 
  y = sin(theta), 
  rad_label = paste0("frac(", 0:11, ", 6)~pi")
)
circle_df; tick_df
```

　単位円の作図用のラジアン$0 \leq \theta \leq 2 \pi$を作成して、$\sin \theta, \cos \theta$を計算します。\
　`tick_df`は、「関数をk倍する場合」と同じ処理です。\

　角度を表示するためのデータフレームを作成します。

```{r}
# 半径の描画用
radius_df <- tibble::tibble(
  x_from = c(0, 0, 0), 
  y_from = c(0, 0, 0), 
  x_to = c(1, cos(theta), cos(theta*a)), 
  y_to = c(0, sin(theta), sin(theta*a)), 
  fnc = c("r", "sin theta", "sin(a theta)")
)

# 角度マークの描画用
d1 <- 0.15
d2 <- 0.2
tmp_vals  <- seq(from = min(0, theta), to = max(0, theta), length.out = 100)
angle_df <- tibble::tibble(
  rad = c(tmp_vals, tmp_vals), 
  x = c(cos(tmp_vals)*d1, cos(tmp_vals*a)*d2), 
  y = c(sin(tmp_vals)*d1, sin(tmp_vals*a)*d2), 
  ang = c(rep(c("theta", "a theta"), each = length(tmp_vals)))
)

# 角度ラベルの描画用
d1 <- 0.1
d2 <- 0.3
angle_label_df <- tibble::tibble(
  rad = c(median(c(0, theta)), median(c(0, theta*a))), 
  x = cos(rad) * c(d1, d2), 
  y = sin(rad) * c(d1, d2), 
  angle_label = c("theta", "a*theta"), 
  ang = c("theta", "a theta")
)
radius_df; angle_df; angle_label_df
```

　$0^{\circ}, \theta, a \theta$のそれぞれの角度における半径を描画するために、原点と単位円上の点を結ぶ線分の座標を格納して`radius_df`とします。始点の座標を`x_from, y_from`、終点の座標を`x_to, y_to`列とします。\
　2つの扇形(角度マーク)を描画するための値(ラジアン)を作成して、x軸とy軸の値を計算して`angle_df`とします。角度$\theta$として$0$から$\theta$、角度$a \theta$として$0$から$a \theta$の値を使います。\
　角度の中点に配置するように座標とラベル用の文字列を格納して`angle_label_df`とします。\

　単位円におけるsin関数の値を描画するためのデータフレームを作成します。

```{r}
# sin関数の線の描画用
sin_line_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta*a)), 
  y_from = c(0, 0), 
  x_to = c(cos(theta), cos(theta*a)), 
  y_to = c(sin(theta), sin(theta*a)), 
  fnc = c("sin theta", "sin(a theta)")
)

# sin関数の線ラベルの描画用
sin_label_df <- sin_line_df |> 
  dplyr::group_by(fnc) |> # 中点の計算用
  dplyr::mutate(
    # 中点に配置
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to))
  ) |> 
  dplyr::ungroup() |> 
  tibble::add_column(
    fnc_label = c("sin~theta", "sin~(a*theta)")
  ) |> 
  dplyr::select(x, y, fnc, fnc_label)
sin_line_df; sin_label_df
```

　これまでと同様に処理します。\

　単位円上の点とsin関数上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# 描画領域のサイズを設定
axis_size <- 1.5
l         <- 0.5

# サイン波との対応用
segment_circle_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta*a)), 
  y_from = c(sin(theta), sin(theta*a)), 
  x_to = c(-axis_size-l, -axis_size-l), 
  y_to = c(sin(theta), sin(theta*a)), 
  fnc = c("sin theta", "sin(a theta)")
)
segment_circle_df
```

　これまでと同様に処理します。\

　単位円のグラフを作成します。

```{r, fig.width=6, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", a==", round(a, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 円を作図
d <- 1.2
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = cos_theta, y = sin_theta), 
            size = 1) + # 単位円
  geom_text(data = tick_df, 
            mapping = aes(x = x, y = y, angle = alpha+90), 
            label = "|", size = 2) + # 角度目盛
  geom_text(data = tick_df, 
            mapping = aes(x = x*d, y = y*d, label = rad_label, 
                          hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
  geom_path(data = angle_df, 
            mapping = aes(x = x, y = y, color = ang)) + # 角度マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y, label = angle_label, color = ang), parse = TRUE) + # 角度ラベル
  geom_segment(data = sin_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # sin関数
  geom_text(data = sin_label_df, 
             mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
             angle = 90, vjust = 1) + # sin関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # sin波との対応線
  geom_point(data = point_df, 
             mapping = aes(x = cos_theta, y = sin_theta), 
             size = 4) + # 円上の点
  scale_color_manual(breaks = c("sin theta", "sin(a theta)", "theta", "a theta"), 
                     values = c("red", "blue", "red", "blue")) + # 線の色
  scale_linetype_manual(breaks = c("sin theta", "sin(a theta)", "r"), 
                        values = c("solid", "dashed", "solid")) + 
  theme(legend.position = "none") + # 凡例の非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = fnc_label), 
       x = "x", y = "y")
circle_graph
```

　これまでと同様に処理します。\

　サイン波の作図用のラジアンの値を作成します。

```{r}
# 作図用のラジアンの値を作成
theta_vals <- seq(from = theta-2*pi, to = theta+2*pi, by = 0.01)
head(theta_vals)
```

　この例では、2周期分の値を指定します。\

　サイン波の描画するためのデータフレームを作成します。

```{r}
# サイン波の描画用
sin_curve_df <- tibble::tibble(
  theta = c(theta_vals, theta_vals), 
  sin_theta = c(sin(theta_vals), sin(theta_vals*a)), 
  fnc = rep(c("sin theta", "sin(a theta)"), each = length(theta_vals))
)
sin_curve_df
```

　作図用の$\theta$の値と$\sin \theta, \sin(a \theta)$の値を格納します。\

　先ほどと同様に、sin関数上の点と円周上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# x軸(角度)・単位円との対応用
d <- 1.1
segment_sin_df <- tibble::tibble(
  x_from = c(theta, theta, theta, theta), 
  y_from = c(sin(theta), sin(theta), sin(theta*a), sin(theta*a)), 
  x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
  y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta*a)), 
  fnc = rep(c("sin theta", "sin(a theta)"), each = 2)
)
segment_sin_df
```

　曲線上の点からx軸・y軸への垂線を引くように座標を指定します。\

　x軸目盛として、角度ラベルを描画するのに用いるベクトルを作成します。

```{r}
# x軸目盛ラベルの描画用の値を作成
tick_min <- floor(min(theta_vals) * 6 / pi)
tick_vec <- seq(from = tick_min, to = tick_min+25, by = 1)
tick_vec
```

　「関数をk倍する場合」と同じ処理です。\

　サイン波のグラフを作成します。

```{r, fig.width=12, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", a==", round(a, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", sin~(a*theta)==", round(sin(theta*a), digits = 2), 
  ")"
)

# サイン波を作図
sin_graph <- ggplot() + 
  geom_line(data = sin_curve_df, 
            mapping = aes(x = theta, y = sin_theta, color = fnc), 
            size = 1) + # sin関数
  geom_segment(data = segment_sin_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # 単位円との対応線
  geom_point(data = point_df, 
             mapping = aes(x = theta, y = sin_theta), 
             size = 4) + # 関数曲線上の点
  scale_x_continuous(breaks = tick_vec/6*pi, 
                     labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
  scale_color_manual(breaks = c("sin theta", "sin(a theta)"), 
                     values = c("red", "blue"), 
                     labels = parse(text = c("sin~theta", "sin~(a*theta)")), 
                     name = "function") + # 線の色
  theme(legend.text.align = 0) + # 凡例の設定
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(min(theta_vals), max(theta_vals)), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "sine curve", 
       subtitle = parse(text = fnc_label), 
       x = expression(theta), y = expression(f(theta)))
sin_graph
```

　「関数をk倍する場合」と同様に処理します。\

　2つのグラフを並べて描画します。

```{r, fig.width=18, fig.height=6}
# グラフを並べて描画
patchwork::wrap_plots(sin_graph, circle_graph) + 
  patchwork::plot_layout(guides = "collect")
```

　角度$\theta$が$a$倍になることで、角速度(角の変化)も$a$倍になります。よって、波長が$\frac{1}{a}$倍($2 \pi$の範囲での周期の数が$a$倍)になるのを確認できます。\

・$\theta^{\circ} = 120^{\circ}, a = -1$のグラフ

![](../figure/curves/sin_t120_a-1.png)

　$a$が負の値のとき、$x = 0$の直線に対して反転したグラフになります。\
　$a = -1$のとき、「関数をk倍する場合」の$k = -1$のときや「変数にbを加える場合」の$b = \pi$のとき、サイン波の形が同じになりますが、単位円の点(単位円における位置関係)が異なるのが分かります。\
\


### アニメーションの作成

　続いて、角度を変化させたアニメーションで確認します。\
\

　フレーム数と角度の範囲を指定して、角度として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 100

# 変数の定数項を指定
a <- 2

# 角度の範囲を指定
theta_min <- -2 * pi
theta_max <- 2 * pi

# フレームごとの角度を作成
theta_i <- seq(from = theta_min, to = theta_max, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　「関数をk倍する場合」と同じ処理です。\

<details><summary>・コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出して作図し、グラフを書き出します

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "trigonometric/figure/tmp_folder"

# 描画領域のサイズを設定
axis_size <- 1.5
l         <- 0.6

# 角度ごとに作図
for(i in 1:frame_num) {
  
  # i番目の角度を取得
  theta <- theta_i[i]
  
  # 関数の点の描画用
  point_df <- tibble::tibble(
    theta = c(theta, theta), 
    sin_theta = sin(theta * c(1, a)), 
    cos_theta = cos(theta * c(1, a)), 
    fnc = c("sin theta", "sin(a theta)")
  )
  
  # 半径の描画用
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0), 
    y_from = c(0, 0, 0), 
    x_to = c(1, cos(theta), cos(theta*a)), 
    y_to = c(0, sin(theta), sin(theta*a)), 
    fnc = c("r", "sin theta", "sin(a theta)")
  )
  
  # 角度マークの描画用
  d1 <- 0.15
  d2 <- 0.2
  tmp_vals  <- seq(from = min(0, theta), to = max(0, theta), length.out = 100)
  angle_df <- tibble::tibble(
    rad = c(tmp_vals, tmp_vals), 
    x = c(cos(tmp_vals)*d1, cos(tmp_vals*a)*d2), 
    y = c(sin(tmp_vals)*d1, sin(tmp_vals*a)*d2), 
    ang = c(rep(c("theta", "a theta"), each = length(tmp_vals)))
  )
  
  # 角度ラベルの描画用
  d1 <- 0.1
  d2 <- 0.3
  angle_label_df <- tibble::tibble(
    rad = c(median(c(0, theta)), median(c(0, theta*a))), 
    x = cos(rad) * c(d1, d2), 
    y = sin(rad) * c(d1, d2), 
    angle_label = c("theta", "a*theta"), 
    ang = c("theta", "a theta")
  )
  
  # sin関数の線の描画用
  sin_line_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta*a)), 
    y_from = c(0, 0), 
    x_to = c(cos(theta), cos(theta*a)), 
    y_to = c(sin(theta), sin(theta*a)), 
    fnc = c("sin theta", "sin(a theta)")
  )
  
  # sin関数の線ラベルの描画用
  sin_label_df <- sin_line_df |> 
    dplyr::group_by(fnc) |> # 中点の計算用
    dplyr::mutate(
      # 中点に配置
      x = median(c(x_from, x_to)), 
      y = median(c(y_from, y_to))
    ) |> 
    dplyr::ungroup() |> 
    tibble::add_column(
      fnc_label = c("sin~theta", "sin~(a*theta)")
    ) |> 
    dplyr::select(x, y, fnc, fnc_label)
  
  # サイン波との対応用
  segment_circle_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta*a)), 
    y_from = c(sin(theta), sin(theta*a)), 
    x_to = c(-axis_size-l, -axis_size-l), 
    y_to = c(sin(theta), sin(theta*a)), 
    fnc = c("sin theta", "sin(a theta)")
  )
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", a==", round(a, digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 円を作図
  d <- 1.2
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = cos_theta, y = sin_theta), 
              size = 1) + # 単位円
    geom_text(data = tick_df, 
              mapping = aes(x = x, y = y, angle = alpha+90), 
              label = "|", size = 2) + # 角度目盛
    geom_text(data = tick_df, 
              mapping = aes(x = x*d, y = y*d, label = rad_label, 
                            hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
    geom_path(data = angle_df, 
              mapping = aes(x = x, y = y, color = ang)) + # 角度マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y, label = angle_label, color = ang), parse = TRUE) + # 角度ラベル
    geom_segment(data = sin_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # sin関数
    geom_text(data = sin_label_df, 
               mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
               angle = 90, vjust = 1) + # sin関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # sin波との対応線
    geom_point(data = point_df, 
               mapping = aes(x = cos_theta, y = sin_theta), 
               size = 4) + # 円上の点
    scale_color_manual(breaks = c("sin theta", "sin(a theta)", "theta", "a theta"), 
                       values = c("red", "blue", "red", "blue")) + # 線の色
    scale_linetype_manual(breaks = c("sin theta", "sin(a theta)", "r"), 
                          values = c("solid", "dashed", "solid")) + 
    theme(legend.position = "none") + # 凡例の非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "unit circle", 
         subtitle = parse(text = fnc_label), 
         x = "x", y = "y")

  # 作図用のラジアンの値を作成
  theta_size <- 2 * pi
  theta_vals <- seq(from = max(theta_min, theta-theta_size), to = theta, by = 0.01)
  
  # サイン波の描画用
  sin_curve_df <- tibble::tibble(
    theta = c(theta_vals, theta_vals), 
    sin_theta = c(sin(theta_vals), sin(theta_vals*a)), 
    fnc = rep(c("sin theta", "sin(a theta)"), each = length(theta_vals))
  )
  
  # x軸(角度)・単位円との対応用
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x_from = c(theta, theta, theta, theta), 
    y_from = c(sin(theta), sin(theta), sin(theta*a), sin(theta*a)), 
    x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
    y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta*a)), 
    fnc = rep(c("sin theta", "sin(a theta)"), each = 2)
  )
  
  # x軸目盛ラベルの描画用の値を作成
  tick_min <- floor((theta-theta_size) * 6 / pi)
  tick_vec <- seq(from = tick_min, to = tick_min+13, by = 1)
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", a==", round(a, digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", sin~(a*theta)==", round(sin(theta*a), digits = 2), 
    ")"
  )
  
  # サイン波を作図
  sin_graph <- ggplot() + 
    geom_line(data = sin_curve_df, 
              mapping = aes(x = theta, y = sin_theta, color = fnc), 
              size = 1) + # sin関数
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # 単位円との対応線
    geom_point(data = point_df, 
               mapping = aes(x = theta, y = sin_theta), 
               size = 4) + # 関数曲線上の点
    scale_x_continuous(breaks = tick_vec/6*pi, 
                       labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
    scale_color_manual(breaks = c("sin theta", "sin(a theta)"), 
                       values = c("red", "blue"), 
                       labels = parse(text = c("sin~theta", "sin~(a*theta)")), 
                       name = "function") + # 線の色
    theme(legend.text.align = 0) + # 凡例の設定
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta-theta_size, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine curve", 
         subtitle = parse(text = fnc_label), 
         x = expression(theta), y = expression(f(theta)))
  
  # グラフを並べて描画
  graph <- patchwork::wrap_plots(sin_graph, circle_graph) + 
      patchwork::plot_layout(guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1200, height = 600, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, "/", frame_num, appendLF = FALSE)
}
```

　「グラフの作成」で作成した`circle_df, tick_df`も使います。\

　「関数をk倍する場合」のコードでgif画像を作成します。

```{r, eval=FALSE, echo=FALSE}
### 資料作成用:(再掲)

# ファイル名を取得
file_name_vec <- list.files(dir_path)

# ファイルパスを作成
file_path_vec <- paste0(dir_path, "/", file_name_vec)

# gif画像を作成
file_path_vec |> 
  magick::image_read() |> 
  magick::image_animate(fps = 1, dispose = "previous") |> 
  magick::image_write_gif(path = "trigonometric/figure/curves/sin_a.gif", delay = 0.1) -> tmp_path
```

</details>

\ 

・$a = 2$の推移

![](../figure/curves/sin_a2.gif)

　円周上($2 \pi$の範囲)を$\sin(\theta)$の点が1周する間に、$\sin(a \theta)$の点がa周するのを確認できます。\

・$a = -2$の推移

![](../figure/curves/sin_a-2.gif)

　$a$が負の値のとき、円周上の点が逆回転します。\

・$a = -1$の推移

![](../figure/curves/sin_a-1.gif)

　$k = -1$や$b = \pi$のグラフと比較します。\
\


## 変数にbを加える場合

　sin関数の変数$\theta$に加える定数と平行移動の関係を可視化します。\
\


### グラフの作成

　角度$\theta$を固定した$\sin(\theta + b)$をグラフで確認します。\
\

　変数に加える定数と角度を指定します。

```{r}
# 変数の定数項を指定
b <- 0.5 * pi

# 角度を指定
alpha <- 120

# ラジアンに変換
theta <- alpha / 180 * pi
theta
```

　sin関数の変数(角度)の定数項$b$と、角度(ラジアン)$\theta$を指定します。\

　曲線上に関数の点を描画するためのデータフレームを作成します。

```{r}
# 関数の点の描画用
point_df <- tibble::tibble(
  theta = c(theta, theta), 
  sin_theta = sin(theta + c(0, b)), 
  cos_theta = cos(theta + c(0, b)), 
  fnc = c("sin theta", "sin(theta+b)")
)
point_df
```

　sin関数$\sin \theta$と定数を加えた変数によるsin関数$\sin (\theta + b)$、cos関数$\cos \theta$と定数を加えた変数によるcos関数$\cos(\theta + b)$を計算して、$\theta$と共に格納します。\
　作図時の色分けなど用に、元の関数と定数を加えた変数による値を区別するための列`fnc`を作成します。\

　単位円を描画するためのデータフレームを作成します。

```{r}
# 単位円の描画用
circle_df <- tibble::tibble(
  theta = seq(from = 0, to = 2*pi, by = 0.05), 
  sin_theta = sin(theta), 
  cos_theta = cos(theta)
)

# 角度目盛の描画用
tick_df <- tibble::tibble(
  alpha = 0:11 * 30, 
  theta = 0:11 / 6 * pi, 
  x = cos(theta), 
  y = sin(theta), 
  rad_label = paste0("frac(", 0:11, ", 6)~pi")
)
circle_df; tick_df
```

　「変数をa倍する場合」と同じ処理です。\

　角度を表示するためのデータフレームを作成します。

```{r}
# 半径の描画用
radius_df <- tibble::tibble(
  x_from = c(0, 0, 0), 
  y_from = c(0, 0, 0), 
  x_to = c(1, cos(theta), cos(theta+b)), 
  y_to = c(0, sin(theta), sin(theta+b)), 
  fnc = c("r", "sin theta", "sin(theta+b)")
)

# 角度マークの描画用
d1 <- 0.15
d2 <- 0.2
d3 <- 0.4
tmp_t_vals  <- seq(from = min(0, theta), to = max(0, theta), length.out = 100)
tmp_b_vals  <- seq(from = min(theta, theta+b),  to = max(theta, theta+b), length.out = 100)
tmp_tb_vals <- seq(from = min(0, theta+b),  to = max(0, theta+b), length.out = 100)
angle_df <- tibble::tibble(
  rad = c(tmp_t_vals, tmp_b_vals, tmp_tb_vals), 
  x = c(cos(tmp_t_vals)*d1, cos(tmp_b_vals)*d2, cos(tmp_tb_vals)*d3), 
  y = c(sin(tmp_t_vals)*d1, sin(tmp_b_vals)*d2, sin(tmp_tb_vals)*d3), 
  ang = c(
    rep("theta", times = length(tmp_t_vals)), 
    rep("b", times = length(tmp_b_vals)), 
    rep("theta+b", times = length(tmp_tb_vals))
  )
)

# 角度ラベルの描画用
d1 <- 0.1
d2 <- 0.3
d3 <- 0.5
angle_label_df <- tibble::tibble(
  rad = c(median(c(0, theta)), median(c(theta, theta+b)), median(c(0, theta+b))), 
  x = cos(rad) * c(d1, d2, d3), 
  y = sin(rad) * c(d1, d2, d3), 
  angle_label = c("theta", "b", "(theta+b)"), 
  ang = c("theta", "b", "theta+b")
)
radius_df; angle_df; angle_label_df
```

　$0^{\circ}, \theta, b, \theta + b$のそれぞれの角度における半径を描画するために、原点と単位円上の点を結ぶ線分の座標を格納して`radius_df`とします。始点の座標を`x_from, y_from`、終点の座標を`x_to, y_to`列とします。\
　3つの扇形(角度マーク)を描画するための値(ラジアン)を作成して、x軸とy軸の値を計算して`angle_df`とします。角度$\theta$として$0$から$\theta$、角度$b$として$\theta$から$b$、角度$\theta + b$として$0$から$\theta + b$の値を使います。\
　角度の中点に配置するように座標とラベル用の文字列を格納して`angle_label_df`とします。\

　単位円におけるsin関数の値を描画するためのデータフレームを作成します。

```{r}
# sin関数の線の描画用
sin_line_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta+b)), 
  y_from = c(0, 0), 
  x_to = c(cos(theta), cos(theta+b)), 
  y_to = c(sin(theta), sin(theta+b)), 
  fnc = c("sin theta", "sin(theta+b)")
)

# sin関数の線ラベルの描画用
sin_label_df <- sin_line_df |> 
  dplyr::group_by(fnc) |> # 中点の計算用
  dplyr::mutate(
    # 中点に配置
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to))
  ) |> 
  dplyr::ungroup() |> 
  tibble::add_column(
    fnc_label = c("sin~theta", "sin~(theta+b)")
  ) |> 
  dplyr::select(x, y, fnc, fnc_label)
sin_line_df; sin_label_df
```

　これまでと同様に処理します。\

　単位円上の点とsin関数上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# 描画領域のサイズを設定
axis_size <- 1.5
l         <- 0.5

# サイン波との対応用
segment_circle_df <- tibble::tibble(
  x_from = c(cos(theta), cos(theta+b)), 
  y_from = c(sin(theta), sin(theta+b)), 
  x_to = c(-axis_size-l, -axis_size-l), 
  y_to = c(sin(theta), sin(theta+b)), 
  fnc = c("sin theta", "sin(theta+b)")
)
segment_circle_df
```

　単位円上の点からy軸への垂線を引くように座標を指定します。作図時に、隣のグラフに届かないような長さ`l`を指定します。\
　また、2つのグラフの描画範囲を固定するために、`axis_size`として値を指定しておきます。\

　単位円のグラフを作成します。

```{r, fig.width=6, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", b==", round(b, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 円を作図
d <- 1.2
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = cos_theta, y = sin_theta), 
            size = 1) + # 単位円
  geom_text(data = tick_df, 
            mapping = aes(x = x, y = y, angle = alpha+90), 
            label = "|", size = 2) + # 角度目盛
  geom_text(data = tick_df, 
            mapping = aes(x = x*d, y = y*d, label = rad_label, 
                          hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
  geom_path(data = angle_df, 
            mapping = aes(x = x, y = y, color = ang)) + # 角度マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y, label = angle_label, color = ang), parse = TRUE) + # 角度ラベル
  geom_segment(data = sin_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # sin関数
  geom_text(data = sin_label_df, 
             mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
             angle = 90, vjust = 1) + # sin関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # sin波との対応線
  geom_point(data = point_df, 
             mapping = aes(x = cos_theta, y = sin_theta), 
             size = 4) + # 円上の点
  scale_color_manual(breaks = c("sin theta", "sin(theta+b)", "theta", "b", "theta+b"), 
                     values = c("red", "blue", "red", "purple", "blue")) + # 線の色
  scale_linetype_manual(breaks = c("sin theta", "sin(theta+b)", "r"), 
                        values = c("solid", "dashed", "solid")) + 
  theme(legend.position = "none") + # 凡例の非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = fnc_label), 
       x = "x", y = "y")
circle_graph
```

　これまでと同様に処理します。\

　サイン波の作図用のラジアンの値を作成します。

```{r}
# 作図用のラジアンの値を作成
theta_vals <- seq(from = theta-2*pi, to = theta+2*pi, by = 0.01)
head(theta_vals)
```

　この例では、2周期分の値を指定します。\

　サイン波の描画するためのデータフレームを作成します。

```{r}
# サイン波の描画用
sin_curve_df <- tibble::tibble(
  theta = c(theta_vals, theta_vals), 
  sin_theta = c(sin(theta_vals), sin(theta_vals+b)), 
  fnc = rep(c("sin theta", "sin(theta+b)"), each = length(theta_vals))
)
sin_curve_df
```

　作図用の$\theta$の値と$\sin \theta, \sin(\theta + b)$の値を格納します。\

　先ほどと同様に、sin関数上の点と円周上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# x軸(角度)・単位円との対応用
d <- 1.1
segment_sin_df <- tibble::tibble(
  x_from = c(theta, theta, theta, theta), 
  y_from = c(sin(theta), sin(theta), sin(theta+b), sin(theta+b)), 
  x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
  y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta+b)), 
  fnc = rep(c("sin theta", "sin(theta+b)"), each = 2)
)
segment_sin_df
```

　曲線上の点からx軸・y軸への垂線を引くように座標を指定します。\

　角度$b$に関して描画するためのデータフレームを作成します。

```{r}
# 角度bに関する可視化用
b_df <- tibble::tibble(
  x = theta+b, 
  y = sin(theta+b), 
  x_to = theta, 
  y_to = sin(theta+b), 
  angle_lable = "b"
) |> 
  dplyr::mutate(
    # 中点に配置
    x_mid = median(c(x, x_to)), 
    y_mid = median(c(y, y_to))
  )
b_df
```

　角度$\theta + b$における点の座標を`x, y`列、角度$\theta$における点の座標を`x_to, y_to`列、またその中点を`x_mid, y_mid`列として、ラベル用の文字列と共に格納します。\

　x軸目盛として、角度ラベルを描画するのに用いるベクトルを作成します。

```{r}
# x軸目盛ラベルの描画用の値を作成
tick_min <- floor(min(theta_vals) * 6 / pi)
tick_vec <- seq(from = tick_min, to = tick_min+25, by = 1)
tick_vec
```

　「関数をk倍する場合」と同じ処理です。\

　サイン波のグラフを作成します。

```{r, fig.width=12, fig.height=6}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", b==", round(b, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", sin~(theta+b)==", round(sin(theta+b), digits = 2), 
  ")"
)

# サイン波を作図
sin_graph <- ggplot() + 
  geom_line(data = sin_curve_df, 
            mapping = aes(x = theta, y = sin_theta, color = fnc), 
            size = 1) + # sin関数
  geom_segment(data = segment_sin_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
               linetype = "dotted") + # 単位円との対応線
  geom_segment(data = b_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               color ="purple") + # 長さbの線分
  geom_text(data = b_df, 
            mapping = aes(x = x_mid, y = y_mid, label = angle_lable), 
            vjust = -0.5, color = "purple") + # 線分bのラベル
  geom_point(data = b_df, 
             mapping = aes(x = x, y = y), 
             size = 4, shape = 1) + # theta+bの点
  geom_point(data = point_df, 
             mapping = aes(x = theta, y = sin_theta), 
             size = 4) + # 関数曲線上の点
  scale_x_continuous(breaks = tick_vec/6*pi, 
                     labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
  scale_color_manual(breaks = c("sin theta", "sin(theta+b)"), 
                     values = c("red", "blue"), 
                     labels = parse(text = c("sin~theta", "sin~(theta+b)")), 
                     name = "function") + # 線の色
  theme(legend.text.align = 0) + # 凡例の設定
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(min(theta_vals), max(theta_vals)), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "sine curve", 
       subtitle = parse(text = fnc_label), 
       x = expression(theta), y = expression(f(theta)))
sin_graph
```

　「関数をk倍する場合」の作図処理に、角度$b$に関しても可視化します。\

　2つのグラフを並べて描画します。

```{r, fig.width=18, fig.height=6}
# グラフを並べて描画
patchwork::wrap_plots(sin_graph, circle_graph) + 
  patchwork::plot_layout(guides = "collect")
```

　角度$\theta$の曲線(赤色の線)に角度$b$が加えられることで、角度$\theta + b$の曲線(青色の線)が、x軸方向に$-b$(紫色の直線)だけ平行移動する($b$の分戻る)のを確認できます。\

・$\theta^{\circ} = 120^{\circ}, b = -\frac{1}{2} \pi$のグラフ

![](../figure/curves/sin_t120_b-0_5pi.png)

　$b$が負の値の(変数から定数を引いた)場合は、x軸方向に$b$だけ平行移動する($b$の分進む)のを確認できます。\

・$\theta^{\circ} = 120^{\circ}, b = \pi$のグラフ

![](../figure/curves/sin_t120_bpi.png)

「関数をk倍する場合」の$k = -1$のときと同じグラフになるのを確認できます。\
\


### アニメーションの作成

　続いて、角度を変化させたアニメーションで確認します。\
\

　フレーム数と角度の範囲を指定して、角度として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 100

# 変数の定数項を指定
b <- -0.5 * pi

# 角度の範囲を指定
theta_min <- -2 * pi
theta_max <- 2 * pi

# フレームごとの角度を作成
theta_i <- seq(from = theta_min, to = theta_max, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　「関数をk倍する場合」と同じ処理です。\

<details><summary>・コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出して作図し、グラフを書き出します

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "trigonometric/figure/tmp_folder"

# 描画領域のサイズを設定
axis_size <- 1.5
l         <- 0.6

# 角度ごとに作図
for(i in 1:frame_num) {
  
  # i番目の角度を取得
  theta <- theta_i[i]
  
  # 関数の点の描画用
  point_df <- tibble::tibble(
    theta = c(theta, theta), 
    sin_theta = sin(theta + c(0, b)), 
    cos_theta = cos(theta + c(0, b)), 
    fnc = c("sin theta", "sin(theta+b)")
  )
  
  # 半径の描画用
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0), 
    y_from = c(0, 0, 0), 
    x_to = c(1, cos(theta), cos(theta+b)), 
    y_to = c(0, sin(theta), sin(theta+b)), 
    fnc = c("r", "sin theta", "sin(theta+b)")
  )
  
  # 角度マークの描画用
  d1 <- 0.15
  d2 <- 0.2
  d3 <- 0.4
  tmp_t_vals  <- seq(from = min(0, theta), to = max(0, theta), length.out = 100)
  tmp_b_vals  <- seq(from = min(theta, theta+b),  to = max(theta, theta+b), length.out = 100)
  tmp_tb_vals <- seq(from = min(0, theta+b),  to = max(0, theta+b), length.out = 100)
  angle_df <- tibble::tibble(
    rad = c(tmp_t_vals, tmp_b_vals, tmp_tb_vals), 
    x = c(cos(tmp_t_vals)*d1, cos(tmp_b_vals)*d2, cos(tmp_tb_vals)*d3), 
    y = c(sin(tmp_t_vals)*d1, sin(tmp_b_vals)*d2, sin(tmp_tb_vals)*d3), 
    ang = c(
      rep("theta", times = length(tmp_t_vals)), 
      rep("b", times = length(tmp_b_vals)), 
      rep("theta+b", times = length(tmp_tb_vals))
    )
  )
  
  # 角度ラベルの描画用
  d1 <- 0.1
  d2 <- 0.3
  d3 <- 0.5
  angle_label_df <- tibble::tibble(
    rad = c(median(c(0, theta)), median(c(theta, theta+b)), median(c(0, theta+b))), 
    x = cos(rad) * c(d1, d2, d3), 
    y = sin(rad) * c(d1, d2, d3), 
    angle_label = c("theta", "b", "(theta+b)"), 
    ang = c("theta", "b", "theta+b")
  )
  
  # sin関数の線の描画用
  sin_line_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta+b)), 
    y_from = c(0, 0), 
    x_to = c(cos(theta), cos(theta+b)), 
    y_to = c(sin(theta), sin(theta+b)), 
    fnc = c("sin theta", "sin(theta+b)")
  )
  
  # sin関数の線ラベルの描画用
  sin_label_df <- sin_line_df |> 
    dplyr::group_by(fnc) |> # 中点の計算用
    dplyr::mutate(
      # 中点に配置
      x = median(c(x_from, x_to)), 
      y = median(c(y_from, y_to))
    ) |> 
    dplyr::ungroup() |> 
    tibble::add_column(
      fnc_label = c("sin~theta", "sin~(theta+b)")
    ) |> 
    dplyr::select(x, y, fnc, fnc_label)
  
  # サイン波との対応用
  segment_circle_df <- tibble::tibble(
    x_from = c(cos(theta), cos(theta+b)), 
    y_from = c(sin(theta), sin(theta+b)), 
    x_to = c(-axis_size-l, -axis_size-l), 
    y_to = c(sin(theta), sin(theta+b)), 
    fnc = c("sin theta", "sin(theta+b)")
  )
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", b==", round(b, digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 円を作図
  d <- 1.2
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = cos_theta, y = sin_theta), 
              size = 1) + # 単位円
    geom_text(data = tick_df, 
              mapping = aes(x = x, y = y, angle = alpha+90), 
              label = "|", size = 2) + # 角度目盛
    geom_text(data = tick_df, 
              mapping = aes(x = x*d, y = y*d, label = rad_label, 
                            hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, linetype = fnc)) + # 半径
    geom_path(data = angle_df, 
              mapping = aes(x = x, y = y, color = ang)) + # 角度マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y, label = angle_label, color = ang), parse = TRUE) + # 角度ラベル
    geom_segment(data = sin_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # sin関数
    geom_text(data = sin_label_df, 
               mapping = aes(x = x, y = y, label = fnc_label, color = fnc), parse = TRUE, 
               angle = 90, vjust = 1) + # sin関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # sin波との対応線
    geom_point(data = point_df, 
               mapping = aes(x = cos_theta, y = sin_theta), 
               size = 4) + # 円上の点
    scale_color_manual(breaks = c("sin theta", "sin(theta+b)", "theta", "b", "theta+b"), 
                     values = c("red", "blue", "red", "purple", "blue")) + # 線の色
    scale_linetype_manual(breaks = c("sin theta", "sin(theta+b)", "r"), 
                          values = c("solid", "dashed", "solid")) + 
    theme(legend.position = "none") + # 凡例の非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "unit circle", 
         subtitle = parse(text = fnc_label), 
         x = "x", y = "y")
  
  # 作図用のラジアンの値を作成
  theta_size <- 2 * pi
  tmp_theta  <- max(theta, theta+b)
  theta_vals <- seq(from = max(theta_min, tmp_theta-theta_size), to = tmp_theta, by = 0.01)
  
  # サイン波の描画用
  sin_curve_df <- tibble::tibble(
    theta = c(theta_vals, theta_vals), 
    sin_theta = c(sin(theta_vals), sin(theta_vals+b)), 
    fnc = rep(c("sin theta", "sin(theta+b)"), each = length(theta_vals))
  )
  
  # x軸(角度)・単位円との対応用
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x_from = c(theta, theta, theta, theta), 
    y_from = c(sin(theta), sin(theta), sin(theta+b), sin(theta+b)), 
    x_to = c(theta, max(theta_vals)+l, theta, max(theta_vals)+l), 
    y_to = c(-axis_size*d, sin(theta), -axis_size*d, sin(theta+b)), 
    fnc = rep(c("sin theta", "sin(theta+b)"), each = 2)
  )
  
  # 角度bに関する可視化用
  b_df <- tibble::tibble(
    x = theta+b, 
    y = sin(theta+b), 
    x_to = theta, 
    y_to = sin(theta+b), 
    angle_lable = "b"
  ) |> 
    dplyr::mutate(
      # 中点に配置
      x_mid = median(c(x, x_to)), 
      y_mid = median(c(y, y_to))
    )
  
  # x軸目盛ラベルの描画用の値を作成
  tick_min <- floor((tmp_theta-theta_size) * 6 / pi)
  tick_vec <- seq(from = tick_min, to = tick_min+13, by = 1)
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", b==", round(b, digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", sin~(theta+b)==", round(sin(theta+b), digits = 2), 
    ")"
  )
  
  # サイン波を作図
  sin_graph <- ggplot() + 
    geom_line(data = sin_curve_df, 
              mapping = aes(x = theta, y = sin_theta, color = fnc), 
              size = 1) + # sin関数
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # 単位円との対応線
    geom_segment(data = b_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 color ="purple") + # 長さbの線分
    geom_text(data = b_df, 
              mapping = aes(x = x_mid, y = y_mid, label = angle_lable), 
              vjust = -0.5, color = "purple") + # 線分bのラベル
    geom_point(data = b_df, 
               mapping = aes(x = x, y = y), 
               size = 4, shape = 1) + # theta+bの点
    geom_point(data = point_df, 
               mapping = aes(x = theta, y = sin_theta), 
               size = 4) + # 関数曲線上の点
    scale_x_continuous(breaks = tick_vec/6*pi, 
                       labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
    scale_color_manual(breaks = c("sin theta", "sin(theta+b)"), 
                       values = c("red", "blue"), 
                       labels = parse(text = c("sin~theta", "sin~(theta+b)")), 
                       name = "function") + # 線の色
    theme(legend.text.align = 0) + # 凡例の設定
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(tmp_theta-theta_size, tmp_theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine curve", 
         subtitle = parse(text = fnc_label), 
         x = expression(theta), y = expression(f(theta)))
  
  # グラフを並べて描画
  graph <- patchwork::wrap_plots(sin_graph, circle_graph) + 
      patchwork::plot_layout(guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1200, height = 600, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, "/", frame_num, appendLF = FALSE)
}
```

　「グラフの作成」で作成した`circle_df, tick_df`も使います。\

　「関数をk倍する場合」のコードでgif画像を作成します。

```{r, eval=FALSE, echo=FALSE}
### 資料作成用:(再掲)

# ファイル名を取得
file_name_vec <- list.files(dir_path)

# ファイルパスを作成
file_path_vec <- paste0(dir_path, "/", file_name_vec)

# gif画像を作成
file_path_vec |> 
  magick::image_read() |> 
  magick::image_animate(fps = 1, dispose = "previous") |> 
  magick::image_write_gif(path = "trigonometric/figure/curves/sin_b.gif", delay = 0.1) -> tmp_path
```

</details>

\ 

・$b = \frac{1}{2}\pi$の推移

![](../figure/curves/sin_b0_5pi.gif)

・$b = -\frac{1}{2}\pi$の推移

![](../figure/curves/sin_b-0_5pi.gif)

・$b = \pi$の推移

![](../figure/curves/sin_bpi.gif)

　$a = -1$や$a = -1$のグラフと比較します。\
\


## サイン波の変形

　ここまでは、個別の変化を確認しました。最後に、全ての変形を行います。\
\


### グラフの作成

　角度$\theta$を固定した$k \sin(a \theta + b) + l$をグラフで確認します。\
\

　パラメータと角度を指定します。

```{r}
# パラメータを指定
k_i <- c(-2, 3, 3)
l_i <- c(0, 2, -3)
a_i <- c(1.5, 1.5, -1)
b_i <- c(1/6*pi, 1/6*pi, -1/2*pi)

# 曲線の数を設定
n <- length(k_i)

# 角度を指定
alpha <- 60

# ラジアンに変換
theta <- alpha / 180 * pi
theta
```

　パラメータ$k, l, a, b$と角度(ラジアン)$\theta$を指定します。\
　パラメータを、それぞれ`k_i, l_i, a_i, b_i`として、同じ数の値を指定します。また指定した数を`n`とします。\

　曲線上に関数の点を描画するためのデータフレームを作成します。

```{r}
# 因子レベルの設定用のベクトルを作成
param_level <- paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")")

# 関数の点の描画用
point_df <- tibble::tibble(
  theta = theta, 
  sin_theta = sin(theta * a_i + b_i) * k_i + l_i, 
  cos_theta = cos(theta * a_i + b_i) * k_i, 
  param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
    factor(levels = param_level)
)
point_df
```

　$\theta$と$k \sin(a \theta + b) + l$、$k \cos(a \theta + b)$を格納します。\
　作図時の色分けなど用に、元の関数とパラメータによって加工した値を区別するための列`param`を作成します。線の色付け順や凡例の表示順を設定する場合は、因子型にしてレベルを設定しておきます。\

　円を描画するためのデータフレームを作成します。

```{r}
# 円の描画用
circle_df <- tidyr::expand_grid(
  i = 1:n, # 曲線番号
  theta = seq(from = 0, to = 2*pi, by = 0.05)
) |> # 曲線ごとに作図用のθを複製
  dplyr::group_by(i) |> # 角度の作成用
  dplyr::mutate(
    sin_theta = sin(theta) * k_i[unique(i)] + l_i[unique(i)], 
    cos_theta = cos(theta) * k_i[unique(i)], 
    param = paste0(
      "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
      ", a==", a_i[unique(i)], ", b==", round(b_i[unique(i)], 2), ")"
    ) |> 
    factor(levels = param_level)
  ) |> 
  dplyr::ungroup()
circle_df
```

　`1`から`n`の整数を曲線(パラメータの組み合わせ)番号として、円の作図用のラジアン$0 \leq \theta \leq 2 \pi$(`theta`列)との全ての組み合わせを`expand_grid()`で作成します。これにより、パラメータの設定ごとに`theta`列を複製できます。$a, b$の計算は、円周上を移動するだけなので、結果に影響しません。\
　`i`列でグループ化してパラメータの設定ごとに、$k \sin \theta + l$、$k \cos \theta$を計算します。\

　角度を表示するためのデータフレームを作成します。

```{r}
# 半径の描画用
radius_df <- dplyr::bind_rows(
  tibble::tibble(
    x_from = 0, 
    y_from = 0 + l_i, 
    x_to = 1 * abs(k_i), 
    y_to = 0 + l_i, 
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level), 
    k = k_i, 
    type = "main"
  ), # 水平方向の半径
  tibble::tibble(
    x_from = 0, 
    y_from = 0 + l_i, 
    x_to = cos(theta * a_i + b_i) * k_i,  
    y_to = sin(theta * a_i + b_i) * k_i + l_i,  
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level), 
    k = k_i, 
    type = "main"
  ), # 角度aθ+bの半径
  tibble::tibble(
    x_from = 0, 
    y_from = 0 + l_i, 
    x_to = cos(theta * a_i + b_i) * abs(k_i),  
    y_to = sin(theta * a_i + b_i) * abs(k_i) + l_i,  
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level), 
    k = k_i, 
    type = "sub"
  ) # kが負のとき用の半径
) |> 
  dplyr::group_by(k) |> # 行の抽出用
  dplyr::filter(
    (type == "main") | (k < 0 & type == "sub")
  ) |> # 不要な行を除去
  dplyr::ungroup()

# 角度マークの描画用
d <- 0.1
angle_df <- tibble::tibble(
  i = 1:n # 曲線番号
) |> 
  dplyr::group_by(i) |> # 角度の作成用
  dplyr::summarise(
    theta = seq(from = min(0, theta*a_i[i]+b_i[i]), to = max(0, theta*a_i[i]+b_i[i]), length.out = 100), 
    .groups = "keep"
  ) |> 
  dplyr::mutate(
    x = cos(theta) * (unique(i)+1)*d, 
    y = sin(theta) * (unique(i)+1)*d + l_i[unique(i)], 
    param = paste0(
      "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
      ", a==", a_i[unique(i)], ", b==", round(b_i, 2)[unique(i)], ")"
    ) |> 
    factor(levels = param_level)
  ) |> 
  dplyr::ungroup()

# 角度ラベルの描画用
angle_label_df <- angle_df |> 
  dplyr::group_by(i, param) |> # 中点の計算用
  dplyr::summarise(
    theta = median(theta), .groups = "keep"
  ) |> 
  dplyr::mutate(
    x = cos(theta) * (i+2)*d, 
    y = sin(theta) * (i+2)*d + l_i[i], 
    angle_label = paste0("theta[", i, "]")
  ) |> 
  dplyr::ungroup()
radius_df; angle_df; angle_label_df
```

　$0^{\circ}$と各$a \theta + b$における半径を描画するために、原点と円上の点を結ぶ線分の座標を格納して`radius_df`とします。ただし、$k$が負の値の場合は、その角度$a \theta + b$の線分を破線で、反転させた線分を実線で描画することにします。\
　そこで、それぞれデータフレームに値を格納しておいて`bind_rows()`で結合し、`filter()`で不要な行($k$が正の値の場合の行)を取り除きます(もっと上手く処理できれば教えて下さい)。\

　各角度に応じた扇形(角度マーク)を描画するための値(ラジアン)を作成して、x軸とy軸の値を計算して`angle_df`とします。\
　`i`列でグループ化して角ごとに、$0$から$a \theta + b$の値を`summarise()`で作成します。\

　角度の中点に配置するように座標とラベル用の文字列を格納して`angle_label_df`とします。\

　単位円におけるsin関数の値を描画するためのデータフレームを作成します。

```{r}
# sin関数の線の描画用
sin_line_df <- tibble::tibble(
  i = 1:n, # 曲線番号
  x_from = cos(theta * a_i + b_i) * k_i, 
  y_from = 0 + l_i, 
  x_to = cos(theta * a_i + b_i) * k_i, 
  y_to = sin(theta * a_i + b_i) * k_i + l_i, 
  param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
    factor(levels = param_level)
)

# sin関数の線ラベルの描画用
sin_label_df <- sin_line_df |> 
  dplyr::group_by(i) |> # 中点の計算用
  dplyr::mutate(
    # 中点に配置
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), 
    sin_theta = sin(theta * a_i[i] + b_i[i]) * k_i[i] + l_i[i], 
    fnc_label = paste0("sin[", i, "]==", round(sin_theta, digits = 2))
  ) |> 
  dplyr::ungroup() |> 
  dplyr::select(x, y, param, fnc_label)
sin_line_df; sin_label_df
```

　これまでと同様に処理します。\

　描画範囲を固定するための値を作成します。

```{r}
# 描画領域のサイズを設定
d <- 0.5
x_min <- -max(abs(k_i)) - d
x_max <- max(abs(k_i)) + d
y_min <- -max(abs(k_i)) + min(l_i) - d
y_max <- max(abs(k_i)) + max(l_i) + d
l     <- 1.5
x_min; x_max; y_min; y_max
```

　2つのグラフの描画範囲を固定するために、x軸の範囲を`x_min, x_max`、y軸の範囲を`y_min, y_max`として、また隣のグラフに届かないような長さ`l`を指定します。\

　円上の点とsin関数上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# サイン波との対応用
segment_circle_df <- tibble::tibble(
  x_from = cos(theta * a_i + b_i) * k_i, 
  y_from = sin(theta * a_i + b_i) * k_i + l_i, 
  x_to = x_min-l, 
  y_to = sin(theta * a_i + b_i) * k_i + l_i, 
  param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
    factor(levels = param_level)
)
segment_circle_df
```

　円周上の点からy軸への垂線を引くように座標を指定します。\

　ここまでは、設定したパラメータそれぞれに応じた値を持つ作図用のデータフレームを作成しました。\
　目安として表示するために、単位円における作図用のデータフレームを作成します。

```{r}
# 単位円の描画用
unit_circle_df <- tibble::tibble(
  theta = seq(from = 0, to = 2*pi, by = 0.05), 
  sin_theta = sin(theta), 
  cos_theta = cos(theta)
)

# 角度目盛の描画用
tick_df <- tibble::tibble(
  alpha = 0:11 * 30, 
  theta = 0:11 / 6 * pi, 
  x = cos(theta), 
  y = sin(theta), 
  rad_label = paste0("frac(", 0:11, ", 6)~pi")
)

# 半径の描画用
unit_radius_df <- tibble::tibble(
  x_from = c(0, 0), 
  y_from = c(0, 0), 
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)

# 角度マークの描画用
d <- 0.1
unit_angle_df <- tibble::tibble(
  theta = seq(from = min(0, theta), to = max(0, theta), by = 0.1), 
  x = cos(theta) * d, 
  y = sin(theta) * d
)

# 角度ラベルの描画用
d <- 0.2
unit_angle_label_df <- tibble::tibble(
  theta = 0.5 * theta, 
  x = cos(theta) * d, 
  y = sin(theta) * d, 
  angle_label = "theta"
)

# サイン波との対応用
segment_unit_circle_df <- tibble::tibble(
  x = cos(theta), 
  y = sin(theta), 
  x_to = x_min-l, 
  y_to = sin(theta)
)
```

　「sin関数の可視化」と同様の処理です。\

　単位円のグラフを作成します。

```{r, fig.width=8, fig.height=12}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 円を作図
d <- 1.2
circle_graph <- ggplot() + 
  geom_path(data = unit_circle_df, 
            mapping = aes(x = cos_theta, y = sin_theta), 
            size = 1) + # 単位円
  geom_text(data = tick_df, 
            mapping = aes(x = x, y = y, angle = alpha+90), 
            label = "|", size = 2) + # 角度目盛
  geom_text(data = tick_df, 
            mapping = aes(x = x*d, y = y*d, label = rad_label, 
                          hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
  geom_segment(data = unit_radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) + # 角度θの半径
  geom_path(data = unit_angle_df, 
            mapping = aes(x = x, y = y)) + # 角度θのマーク
  geom_text(data = unit_angle_label_df, 
            mapping = aes(x = x, y = y, label = angle_label), parse = TRUE) + # 角度θのラベル
  geom_path(data = circle_df, 
            mapping = aes(x = cos_theta, y = sin_theta, color = param), 
            linetype = "dotted", size = 1) + # 半径kの円
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = param, linetype = type)) + # 角度aθ+bの半径
  geom_path(data = angle_df, 
            mapping = aes(x = x, y = y, color = param)) + # 角度aθ+bのマーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y, label = angle_label, color = param), parse = TRUE) + # 角度aθ+bのラベル
  geom_segment(data = sin_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
               size = 1) + # 角度aθ+bのsin関数
  geom_text(data = sin_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = param), parse = TRUE, 
            angle = 90, vjust = 1) + # 角度aθ+bのsin関数ラベル
  geom_segment(data = segment_unit_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # 角度θのsin波との対応線
  geom_point(data = segment_unit_circle_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # 角度θの点
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
               size = 1, linetype = "dotted") + # 角度aθ+bのsin波との対応線
  geom_point(data = point_df, 
             mapping = aes(x = cos_theta, y = sin_theta, color = param), 
             size = 4) + # 円上の点
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "dashed")) + # 線の種類
  scale_color_hue(breaks = point_df[["param"]], 
                  labels = parse(text = as.character(point_df[["param"]])), 
                  name = expression(k~sin(a*theta+b)+l)) + # 線の色の凡例
  theme(legend.position = "none") + # 凡例の非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = fnc_label), 
       x = "x", y = "y")
circle_graph
```

　これまでと同様に、単位円$(\cos(\theta), \sin(\theta))$とパラメータごとの円$(k \cos(\theta) + l, k \sin(\theta) + l)$に関して作図します。\

　サイン波の作図用のラジアンの値を作成します。

```{r}
# 作図用のラジアンの値を作成
theta_vals <- seq(from = theta-2*pi, to = theta+2*pi, by = 0.01)
head(theta_vals)
```

　この例では、2周期分の値を指定します。\

　サイン波の描画するためのデータフレームを作成します。

```{r}
# サイン波の描画用
sin_curve_df <- tidyr::expand_grid(
  i = 1:n, # 曲線番号
  theta = theta_vals
) |> # 曲線ごとに作図用のθを複製
  dplyr::group_by(i) |> 
  dplyr::mutate(
    sin_theta = sin(theta * a_i[unique(i)] + b_i[unique(i)]) * k_i[unique(i)] + l_i[unique(i)], 
    param = paste0(
      "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
      ", a==", a_i[unique(i)], ", b==", round(b_i[unique(i)], 2), ")"
    ) |> 
      factor(levels = param_level)
  ) |> 
  dplyr::ungroup()
sin_curve_df
```

　作図用の値`theta_vals`を`expand_grid()`で複製して、$\theta$と$k \sin(a \theta + b) + l$を計算します。\

　先ほどと同様に、sin関数上の点と円周上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# x軸(角度)・円との対応用
d <- 1.1
segment_sin_df <- tibble::tibble(
  x_from = theta, 
  y_from = sin(theta * a_i + b_i) * k_i + l_i, 
  x_to = max(theta_vals)+l, 
  y_to = sin(theta * a_i + b_i) * k_i + l_i, 
  param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
    factor(levels = param_level)
)
segment_sin_df
```

　曲線上の点からx軸・y軸への垂線を引くように座標を指定します。\

　また、元のsin関数と単位円上の点を結ぶ線(の半分)を描画するためのデータフレームを作成します。

```{r}
# サイン波の描画用
unit_sin_curve_df <- tibble::tibble(
  theta = theta_vals, 
  sin_theta = sin(theta_vals)
)

# x軸(角度)・単位円との対応用
segment_unit_sin_df <- tibble::tibble(
  x = theta, 
  y = sin(theta) , 
  x_to = max(theta_vals)+l, 
  y_to = sin(theta)
)
```

　曲線上の点からy軸への垂線を引くように座標を指定します。`x, y`列は、曲線上の点などを描画するのにも使います。\

　x軸目盛として、角度ラベルを描画するのに用いるベクトルを作成します。

```{r}
# x軸目盛ラベルの描画用の値を作成
tick_min <- floor(min(theta_vals) * 6 / pi)
tick_vec <- seq(from = tick_min, to = tick_min+25, by = 1)
tick_vec
```

　「関数をk倍する場合」と同じ処理です。\

　サイン波のグラフを作成します。

```{r, fig.width=12, fig.height=12}
# 関数ラベルを作成
fnc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ")"
)

# サイン波を作図
sin_graph <- ggplot() + 
  geom_line(data = unit_sin_curve_df, 
            mapping = aes(x = theta, y = sin_theta), 
            size = 1) + # 角度θのsin関数
  geom_segment(data = segment_unit_sin_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # 角度θの単位円との対応線
  geom_vline(data = segment_unit_sin_df, 
             mapping = aes(xintercept = x), 
             size = 1, linetype = "dotted") + # 角度θの単位円との対応線
  geom_point(data = segment_unit_sin_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # 角度θの関数曲線上の点
  geom_line(data = sin_curve_df, 
            mapping = aes(x = theta, y = sin_theta, color = param), 
            size = 1) + # 角度aθ+bのsin関数
  geom_segment(data = segment_sin_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
               size = 1, linetype = "dotted") + # 角度aθ+bの円との対応線
  geom_point(data = point_df, 
             mapping = aes(x = theta, y = sin_theta, color = param), 
             size = 4) + # 角度aθ+bの関数曲線上の点
  scale_x_continuous(breaks = tick_vec/6*pi, 
                     labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
  scale_color_hue(breaks = point_df[["param"]], 
                  labels = parse(text = as.character(point_df[["param"]])), 
                  name = expression(k~sin(a*theta+b)+l)) + 
  theme(legend.text.align = 0) + # 凡例の左揃え
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(min(theta_vals), max(theta_vals)), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "sine curve", 
       subtitle = parse(text = fnc_label), 
       x = expression(theta), y = expression(f(theta)))
sin_graph
```

　これまでと同様に、元のsin関数$\sin \theta$とパラメータごとのsin関数$k \sin(a \theta + b) + l$に関して作図します。\

　2つのグラフを並べて描画します。

```{r, fig.width=20, fig.height=10}
# グラフを並べて描画
patchwork::wrap_plots(sin_graph, circle_graph) + 
  patchwork::plot_layout(guides = "collect")
```

　$l$の値によってグラフ全体がy軸方向に変化するのを確認できます。\
\


### アニメーションの作成

　続いて、角度を変化させたアニメーションで確認します。\
\

　フレーム数とパラメータ、角度の範囲を指定して、角度として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 100

# パラメータを指定
k_i <- c(-2, 3, 3)
l_i <- c(0, 2, -3)
a_i <- c(1.5, 1.5, -1)
b_i <- c(1/6*pi, 1/6*pi, -1/2*pi)

# 曲線の数を設定
n <- length(k_i)

# 角度の範囲を指定
theta_min <- -2 * pi
theta_max <- 2 * pi

# フレームごとの角度を作成
theta_i <- seq(from = theta_min, to = theta_max, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　「関数をk倍する場合」と同じ処理です。\

<details><summary>・コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出して作図し、グラフを書き出します

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "trigonometric/figure/tmp_folder"

# 描画領域のサイズを設定
d <- 0.5
x_min <- -max(abs(k_i)) - d
x_max <- max(abs(k_i)) + d
y_min <- -max(abs(k_i)) + min(l_i) - d
y_max <- max(abs(k_i)) + max(l_i) + d
l     <- 1.5

# 円の描画用
circle_df <- tidyr::expand_grid(
  i = 1:n, # 曲線番号
  theta = seq(from = 0, to = 2*pi, by = 0.05)
) |> # 曲線ごとに作図用のθを複製
  dplyr::group_by(i) |> # 角度の作成用
  dplyr::mutate(
    sin_theta = sin(theta) * k_i[unique(i)] + l_i[unique(i)], 
    cos_theta = cos(theta) * k_i[unique(i)], 
    param = paste0(
      "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
      ", a==", a_i[unique(i)], ", b==", round(b_i[unique(i)], 2), ")"
    ) |> 
    factor(levels = param_level)
  ) |> 
  dplyr::ungroup()

# 角度ごとに作図
for(i in 1:frame_num) {
  
  # i番目の角度を取得
  theta <- theta_i[i]
  
  # 因子レベルの設定用のベクトルを作成
  param_level <- paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")")
  
  # 関数の点の描画用
  point_df <- tibble::tibble(
    theta = theta, 
    sin_theta = sin(theta * a_i + b_i) * k_i + l_i, 
    cos_theta = cos(theta * a_i + b_i) * k_i, 
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level)
  )

  # 半径の描画用
  radius_df <- dplyr::bind_rows(
    tibble::tibble(
      x_from = 0, 
      y_from = 0 + l_i, 
      x_to = 1 * abs(k_i), 
      y_to = 0 + l_i, 
      param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
        factor(levels = param_level), 
      k = k_i, 
      type = "main"
    ), # 水平方向の半径
    tibble::tibble(
      x_from = 0, 
      y_from = 0 + l_i, 
      x_to = cos(theta * a_i + b_i) * k_i,  
      y_to = sin(theta * a_i + b_i) * k_i + l_i,  
      param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
        factor(levels = param_level), 
      k = k_i, 
      type = "main"
    ), # 角度aθ+bの半径
    tibble::tibble(
      x_from = 0, 
      y_from = 0 + l_i, 
      x_to = cos(theta * a_i + b_i) * abs(k_i),  
      y_to = sin(theta * a_i + b_i) * abs(k_i) + l_i,  
      param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
        factor(levels = param_level), 
      k = k_i, 
      type = "sub"
    ) # kが負のとき用の半径
  ) |> 
    dplyr::group_by(k) |> # 行の抽出用
    dplyr::filter(
      (type == "main") | (k < 0 & type == "sub")
    ) |> # 不要な行を除去
    dplyr::ungroup()
    
  # 角度マークの描画用
  d <- 0.1
  angle_df <- tibble::tibble(
    i = 1:n # 曲線番号
  ) |> 
    dplyr::group_by(i) |> # 角度の作成用
    dplyr::summarise(
      theta = seq(from = min(0, theta*a_i[i]+b_i[i]), to = max(0, theta*a_i[i]+b_i[i]), length.out = 100), 
      .groups = "keep"
    ) |> 
    dplyr::mutate(
      x = cos(theta) * (unique(i)+1)*d, 
      y = sin(theta) * (unique(i)+1)*d + l_i[unique(i)], 
      param = paste0(
        "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
        ", a==", a_i[unique(i)], ", b==", round(b_i, 2)[unique(i)], ")"
      ) |> 
      factor(levels = param_level)
    ) |> 
    dplyr::ungroup()
  
  # 角度ラベルの描画用
  angle_label_df <- angle_df |> 
    dplyr::group_by(i, param) |> # 中点の計算用
    dplyr::summarise(
      theta = median(theta), .groups = "keep"
    ) |> 
    dplyr::mutate(
      x = cos(theta) * (i+2)*d, 
      y = sin(theta) * (i+2)*d + l_i[i], 
      angle_label = paste0("theta[", i, "]")
    ) |> 
    dplyr::ungroup()

  # sin関数の線の描画用
  sin_line_df <- tibble::tibble(
    i = 1:n, # 曲線番号
    x_from = cos(theta * a_i + b_i) * k_i, 
    y_from = 0 + l_i, 
    x_to = cos(theta * a_i + b_i) * k_i, 
    y_to = sin(theta * a_i + b_i) * k_i + l_i, 
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level)
  )
  
  # sin関数の線ラベルの描画用
  sin_label_df <- sin_line_df |> 
    dplyr::group_by(i) |> # 中点の計算用
    dplyr::mutate(
      # 中点に配置
      x = median(c(x_from, x_to)), 
      y = median(c(y_from, y_to)), 
      sin_theta = sin(theta * a_i[i] + b_i[i]) * k_i[i] + l_i[i], 
      fnc_label = paste0("sin[", i, "]==", round(sin_theta, digits = 2))
    ) |> 
    dplyr::ungroup() |> 
    dplyr::select(x, y, param, fnc_label)

  # サイン波との対応用
  segment_circle_df <- tibble::tibble(
    x_from = cos(theta * a_i + b_i) * k_i, 
    y_from = sin(theta * a_i + b_i) * k_i + l_i, 
    x_to = x_min-l, 
    y_to = sin(theta * a_i + b_i) * k_i + l_i, 
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level)
  )

  # 半径の描画用
  unit_radius_df <- tibble::tibble(
    x_from = c(0, 0), 
    y_from = c(0, 0), 
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角度マークの描画用
  d <- 0.1
  unit_angle_df <- tibble::tibble(
    theta = seq(from = min(0, theta), to = max(0, theta), by = 0.1), 
    x = cos(theta) * d, 
    y = sin(theta) * d
  )
  
  # 角度ラベルの描画用
  d <- 0.2
  unit_angle_label_df <- tibble::tibble(
    theta = 0.5 * theta, 
    x = cos(theta) * d, 
    y = sin(theta) * d, 
    angle_label = "theta"
  )
  
  # サイン波との対応用
  segment_unit_circle_df <- tibble::tibble(
    x = cos(theta), 
    y = sin(theta), 
    x_to = x_min-l, 
    y_to = sin(theta)
  )

  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 円を作図
  d <- 1.2
  circle_graph <- ggplot() + 
    geom_path(data = unit_circle_df, 
              mapping = aes(x = cos_theta, y = sin_theta), 
              size = 1) + # 単位円
    geom_text(data = tick_df, 
              mapping = aes(x = x, y = y, angle = alpha+90), 
              label = "|", size = 2) + # 角度目盛
    geom_text(data = tick_df, 
              mapping = aes(x = x*d, y = y*d, label = rad_label, 
                            hjust = 1-(x*0.5+0.5), vjust = 1-(y*0.5+0.5)), parse = TRUE) + # 角度目盛ラベル
    geom_segment(data = unit_radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to)) + # 角度θの半径
    geom_path(data = unit_angle_df, 
              mapping = aes(x = x, y = y)) + # 角度θのマーク
    geom_text(data = unit_angle_label_df, 
              mapping = aes(x = x, y = y, label = angle_label), parse = TRUE) + # 角度θのラベル
    geom_path(data = circle_df, 
              mapping = aes(x = cos_theta, y = sin_theta, color = param), 
              linetype = "dotted", size = 1) + # 半径kの円
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = param, linetype = type)) + # 角度aθ+bの半径
    geom_path(data = angle_df, 
              mapping = aes(x = x, y = y, color = param)) + # 角度aθ+bのマーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y, label = angle_label, color = param), parse = TRUE) + # 角度aθ+bのラベル
    geom_segment(data = sin_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
                 size = 1) + # 角度aθ+bのsin関数
    geom_text(data = sin_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = param), parse = TRUE, 
              angle = 90, vjust = 1) + # 角度aθ+bのsin関数ラベル
    geom_segment(data = segment_unit_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # 角度θのsin波との対応線
    geom_point(data = segment_unit_circle_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # 角度θの点
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
                 linetype = "dotted") + # 角度aθ+bのsin波との対応線
    geom_point(data = point_df, 
               mapping = aes(x = cos_theta, y = sin_theta, color = param), 
               size = 4) + # 円上の点
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "dashed")) + # 線の種類
    scale_color_hue(breaks = point_df[["param"]], 
                    labels = parse(text = as.character(point_df[["param"]])), 
                    name = expression(k~sin(a*theta+b)+l)) + # 線の色の凡例
    theme(legend.position = "none") + # 凡例の非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
    labs(title = "unit circle", 
         subtitle = parse(text = fnc_label), 
         x = "x", y = "y")

  # 作図用のラジアンの値を作成
  theta_size <- 2 * pi
  theta_vals <- seq(from = max(theta_min, theta-theta_size), to = theta, by = 0.01)
  
  # サイン波の描画用
  sin_curve_df <- tidyr::expand_grid(
    i = 1:n, # 曲線番号
    theta = theta_vals
  ) |> # 曲線ごとに作図用のθを複製
    dplyr::group_by(i) |> 
    dplyr::mutate(
      sin_theta = sin(theta * a_i[unique(i)] + b_i[unique(i)]) * k_i[unique(i)] + l_i[unique(i)], 
      param = paste0(
        "list(k==", k_i[unique(i)], ", l==", l_i[unique(i)], 
        ", a==", a_i[unique(i)], ", b==", round(b_i[unique(i)], 2), ")"
      ) |> 
        factor(levels = param_level)
    ) |> 
    dplyr::ungroup()
  
  # x軸(角度)・円との対応用
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x_from = theta, 
    y_from = sin(theta * a_i + b_i) * k_i + l_i, 
    x_to = max(theta_vals)+l, 
    y_to = sin(theta * a_i + b_i) * k_i + l_i, 
    param = paste0("list(k==", k_i, ", l==", l_i, ", a==", a_i, ", b==", round(b_i, 2), ")") |> 
      factor(levels = param_level)
  )

  # サイン波の描画用
  unit_sin_curve_df <- tibble::tibble(
    theta = theta_vals, 
    sin_theta = sin(theta_vals)
  )
  
  # x軸(角度)・単位円との対応用
  segment_unit_sin_df <- tibble::tibble(
    x = theta, 
    y = sin(theta) , 
    x_to = max(theta_vals)+l, 
    y_to = sin(theta)
  )

  # x軸目盛ラベルの描画用の値を作成
  tick_min <- floor((theta-theta_size) * 6 / pi)
  tick_vec <- seq(from = tick_min, to = tick_min+13, by = 1)
  
  # 関数ラベルを作成
  fnc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # サイン波を作図
  sin_graph <- ggplot() + 
    geom_line(data = unit_sin_curve_df, 
              mapping = aes(x = theta, y = sin_theta), 
              size = 1) + # 角度θのsin関数
    geom_segment(data = segment_unit_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 linetype = "dotted") + # 角度θの単位円との対応線
    geom_vline(data = segment_unit_sin_df, 
               mapping = aes(xintercept = x), 
               linetype = "dotted") + # 角度θの単位円との対応線
    geom_point(data = segment_unit_sin_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # 角度θの関数曲線上の点
    geom_line(data = sin_curve_df, 
              mapping = aes(x = theta, y = sin_theta, color = param), 
              size = 1) + # 角度aθ+bのsin関数
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = param), 
                 linetype = "dotted") + # 角度aθ+bの円との対応線
    geom_point(data = point_df, 
               mapping = aes(x = theta, y = sin_theta, color = param), 
               size = 4) + # 角度aθ+bの関数曲線上の点
    scale_x_continuous(breaks = tick_vec/6*pi, 
                       labels = parse(text = paste0("frac(", tick_vec, ", 6)~pi"))) + # 角度目盛ラベル
    scale_color_hue(breaks = point_df[["param"]], 
                    labels = parse(text = as.character(point_df[["param"]])), 
                    name = expression(k~sin(a*theta+b)+l)) + 
    theme(legend.text.align = 0) + # 凡例の左揃え
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta-theta_size, theta), ylim = c(y_min, y_max)) + # 描画領域
    labs(title = "sine curve", 
         subtitle = parse(text = fnc_label), 
         x = expression(theta), y = expression(f(theta)))
  
  # グラフを並べて描画
  graph <- patchwork::wrap_plots(sin_graph, circle_graph) + 
      patchwork::plot_layout(guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, "/", frame_num, appendLF = FALSE)
}
```

　「グラフの作成」で作成した`unit_circle_df, tick_df`も使います。\

　「関数をk倍する場合」のコードでgif画像を作成します。

```{r, eval=FALSE, echo=FALSE}
### 資料作成用:(再掲)

# ファイル名を取得
file_name_vec <- list.files(dir_path)

# ファイルパスを作成
file_path_vec <- paste0(dir_path, "/", file_name_vec)

# gif画像を作成
file_path_vec |> 
  magick::image_read() |> 
  magick::image_animate(fps = 1, dispose = "previous") |> 
  magick::image_write_gif(path = "trigonometric/figure/curves/sin_curves.gif", delay = 0.1) -> tmp_path
```

</details>

\ 

![](../figure/curves/sin_curves.gif)

　色々比較してみてください。\
\

　この記事では、sin関数の変形を確認しました。\
\


# cos関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるcos関数(余弦関数・コサイン関数・cosine function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
###資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## cos関数の作図

　次に、cos関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　cos関数の曲線を描画するためのデータフレームを作成します。

```{r}
# cos関数を計算
cos_df <- tibble::tibble(
  t = theta_vec, 
  cos_t = cos(theta_vec), 
  sin_t = sin(theta_vec)
)
cos_df
```

　$\theta$ の値と $\cos \theta, \sin \theta$ の値をデータフレームに格納します。cos関数は`cos()`で計算できます。sin関数の値は比較に使います。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

</details>

　cos関数のグラフを作成します。

```{r, fig.width=9, fig.height=3, dpi=100}
# cos関数を作図
ggplot() + 
  geom_line(data = cos_df, 
            mapping = aes(x = t, y = cos_t, linetype = "cos"), 
            size = 1) + # cos曲線
  geom_line(data = cos_df, 
            mapping = aes(x = t, y = sin_t, linetype = "sin"), 
            size = 1) + # sin曲線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("cos", "sin"), 
                        values = c("solid", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "cosine function", 
       x = expression(theta), 
       y = expression(cos~theta))
```

　x軸を $\theta$、y軸を $\cos \theta$ として、`geom_line()`でcos関数の曲線を描画します。また、$\sin \theta$ の曲線を点線で描画します。\
　sin関数の曲線を負の方向へ $\frac{\pi}{2}$ 移動するとcos関数の曲線になるのが分かります。この関係を式で表すと $\cos \theta = \sin (\theta + \frac{\pi}{2})$ です。詳しくは、「cos関数の振幅・周期・平行移動の変形の可視化
」を参照してください。\
\


## 単位円の作図

　続いて、cos関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のcos関数の可視化

　次は、単位円上における三角関数(cos・sin)のグラフを作成します。\
\


### グラフの作成

　変数を固定したsin関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2点の座標を格納します。原点の座標は、作図時に値を引数に指定します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("cos", "cos", "sin", "sin") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 
    0, cos(theta)
  ), 
  y_from = c(
    0, sin(theta), 
    0, 0
  ), 
  x_to = c(
    cos(theta), cos(theta), 
    0, cos(theta)
  ), 
  y_to = c(
    0, sin(theta), 
    sin(theta), sin(theta)
  )
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("cos", "sin") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 * cos(theta), 
    0
  ), 
  y = c(
    0,
    0.5 * sin(theta)
  ), 
  angle = c(0, 90), 
  v = c(1, -0.5), 
  fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ラベルの表示角度を`angle`列、表示角度に応じた上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
axis_size <- 1.3

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　cos関数の値は、円周上の点 $(\cos \theta, \sin \theta)$ のx軸の値(横幅)です。\
\


### アニメーションの作成

　続いて、変数の値を変化させたcos関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 \pi$ の倍数にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", sin θ = ", round(sin(theta_i), digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 2) |> # (2は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　フレーム数分の点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標を格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("cos", "cos", "sin", "sin") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), cos(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), sin(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num)
  ), 
  x_to = c(
    cos(theta_i), cos(theta_i), 
    rep(0, times = frame_num), cos(theta_i)
  ), 
  y_to = c(
    rep(0, times = frame_num), sin(theta_i), 
    sin(theta_i), sin(theta_i)
  ), 
  label_flag = c(TRUE, FALSE, TRUE, FALSE) |> 
    rep(each = frame_num), # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 4) |> # (4は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　「グラフの作成」のときと同様に、線分ごとに`frame_num`個の座標を格納します。\
　また、関数ラベルを描画する線分を`label_flag`列に指定しておきます。関数ごとに、ラベルを表示する1つの線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90) |> 
      rep(each = frame_num), 
    v = c(1, -0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("cos~theta", "sin~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`から`label_flag`列が`TRUE`の行(線分)を取り出して、`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
axis_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 600)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\
\


## 単位円上の点とcos関数曲線の関係の可視化

　最後は、単位円上におけるcos関数の値(直線)と、cos関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したcos関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のcos関数の可視化」のコードで4つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.25
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("cos", "sin") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 * cos(theta), 
    0
  ), 
  y = c(
    0,
    0.5 * sin(theta)
  ), 
  angle = c(0, 90), 
  v = c(1, -0.5), 
  fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
)
```

</details>

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcos関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("cos", "cos", "cos", "sin", "sin") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 0, 
    0, cos(theta)
  ), 
  y_from = c(
    0, sin(theta), 0, 
    0, 0
  ), 
  x_to = c(
    cos(theta), cos(theta), 0, 
    0, cos(theta)
  ), 
  y_to = c(
    0, sin(theta), cos(theta), 
    sin(theta), sin(theta)
  ), 
  type = c("main", "main", "sub", "main", "main") # 線の種類用
)
function_line_df
```

　「単位円上のcos関数の可視化」のときのコードに、cos直線の1つを90°回転(軸を変換)した線分の座標を格納します。\

　軸の変換前後の点を描画するためのデータフレームを作成します。

```{r}
# 変換曲線の先端の座標を格納
adapt_point_df <- tibble::tibble(
  x = c(cos(theta), 0), 
  y = c(0, cos(theta))
)
adapt_point_df
```

　x軸・y軸の値をそれぞれ $0, \cos \theta$ とする2点の座標を格納します。\

　x軸の値を90度回転する曲線を描画するためのデータフレームを作成します。

```{r}
# 軸変換曲線の描画用
adapt_line_df <- tibble::tibble(
  rad = ifelse(
    test = rep(cos(theta) >= 0, times = 100), 
    yes = seq(from = 0, to = 0.5*pi, length.out = 100), 
    no = seq(from = pi, to = 1.5*pi, length.out = 100)
  ), 
  x = abs(cos(theta)) * cos(rad), 
  y = abs(cos(theta)) * sin(rad)
)
adapt_line_df <- tibble::tibble(
  rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
  x = cos(theta) * cos(rad), 
  y = cos(theta) * sin(rad)
)
adapt_line_df
```

　軸を変換する軌道として、半径が $|\cos \theta|$ の弧を描画します。全体値 $|x|$ は`abs()`で計算できます。\
　$\cos \theta \geq 0$ のときx軸の正の部分からy軸の正の部分への変化を示すため $0 \leq t \leq \frac{\pi}{2}$ のラジアン、$\cos \theta < 0$ のときx軸の負の部分からy軸の負の部分への変化を示すため $\pi \leq t \leq \frac{3 \pi}{2}$ のラジアンを用いて、弧のx軸の値 $x = |\cos \theta| \cos t$ とy軸の値 $y = |\cos \theta| \sin t$ を計算します。\
　または、$- \cos x = \cos (x + \pi)$ なのを利用して、$\theta$ の値に関わらず、$0 \leq t \leq \frac{\pi}{2}$ のラジアンを用いて、$x = \cos \theta \cos t$、$y = \cos \theta \sin t$ でも弧の座標を計算できます。\

　単位円上の点とcos曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_size <- 1.3

# cos曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = 0, 
  y = cos(theta), 
  x_to = axis_size+l
)
segment_circle_df
```

　単位円上の点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=5, fig.height=5, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(data = adapt_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # cos関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type, linetype = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y), 
               size = 1, linetype = "dotted") + # cos曲線との対応線
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
  scale_size_manual(breaks = c("main", "sub"), 
                    values = c(1, 1.5), guide ="none") + # (線が重なる対策)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcos関数の可視化」のときと同様に、作図します。\
\

　cos関数の曲線を描画するためのデータフレームを作成します。

```{r}
# cos関数を計算
cos_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  cos_t = cos(t)
)
cos_df
```

　「cos関数の作図」のときと同様にして、曲線の座標を計算します。\

　cos曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# cos直線との対応線の座標を格納
l <- 0.7
d <- 1.1
segment_cos_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(cos(theta), cos(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-axis_size*d, cos(theta))
)
segment_cos_df
```

　曲線上の点からx軸とy軸へ垂直線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「cos関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　cos関数曲線のグラフを作成します。

```{r, fig.width=10, fig.height=5, dpi=100}
# 関数ラベル用の文字列を作成
cos_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# cos関数曲線を作図
cos_graph <- ggplot() + 
  geom_line(data = cos_df, 
            mapping = aes(x = t, y = cos_t), 
            size = 1) + # cos曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = cos_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_cos_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # 変換曲線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "cosine function", 
       subtitle = parse(text = cos_label), 
       x = expression(theta), 
       y = expression(cos~theta))
cos_graph
```

　「cos関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, cos_graph)
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、円周上の点のx軸の値とcos曲線上の点のy軸の値、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


#### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcos関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("cos", "cos", "sin", "sin") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 
    0, cos(theta)
  ), 
  y_from = c(
    0, sin(theta), 
    0, 0
  ), 
  x_to = c(
    cos(theta), cos(theta), 
    0, cos(theta)
  ), 
  y_to = c(
    0, sin(theta), 
    sin(theta), sin(theta)
  )
)
function_line_df
```

　「単位円上のcos関数の可視化」のときのコードで線分の座標を格納します。\

　単位円における点と軸の変換図上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_size <- 1.3

# 軸変換曲線との対応線の座標を格納
l <- 0.4
segment_circle_df <- tibble::tibble(
  x = cos(theta), 
  y = sin(theta), 
  y_to = -axis_size-l
)
segment_circle_df
```

　単位円上の点からx軸へ垂直線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=5, fig.height=5, dpi=100}
# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x, yend = y_to), 
               size = 1, linetype = "dotted") + # 軸変換曲線との対応線
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcos関数の可視化」のときと同様に、作図します。\
\

　x軸の値を90度回転する線を描画するためのデータフレームを作成します。

```{r}
# cos関数の軸変換曲線の座標を計算
adapt_line_df <- tibble::tibble(
  rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
  x = axis_size + (axis_size-cos(theta)) * cos(rad), 
  y = axis_size + (axis_size-cos(theta)) * sin(rad)
)
adapt_line_df
```

　グラフのサイズを`axis_size`の2倍としました。`axis_size`を $S$ で表します。軸を変換する軌道として、中心の座標が $(S, S)$ で半径が $r = S - \cos \theta$ の弧を描画します。また、弧の中心が図の右上隅になるようにします。\
　$0 \leq t \leq \frac{\pi}{2}$ を用いて、弧のx軸の値 $x = S + r \cos t$ とy軸の値 $y = S + r \sin t$ を計算します。\
　円の座標計算については「円周の作図」を参照してください。\

　軸の変換図のグリッド線を描画するためのデータフレームを作成します。

```{r}
# 軸変換図のグリッド線の描画用
adapt_grid_df <- tidyr::expand_grid(
  d = axis_size - seq(from = -1, to = 1, by = 0.5), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = axis_size + d * cos(rad), 
    y = axis_size + d * sin(rad)
  )
adapt_grid_df
```

　軸の変換曲線と同様に、グリッド線として、等間隔の半径の複数の曲線を描画します。この例では、半径を $d = -1, -0.5, 0, 0.5, 1$ とします。\
　半径 $d$ の値を指定して`d`列、ラジアン $t$ の値を作成して`rad`列とします。`d, rad`列の全ての組み合わせを`expand_grid()`で作成することで、半径ごとに曲線用のラジアンを複製します。\
　弧の座標を $x = S + d \cos t$、$y = S + d \sin t$ で計算します。\

　軸の変換図上の点とcos曲線上の点・単位円上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# cos曲線・直線との対応線の座標を格納
l <- 0.7
segment_adapt_df <- tibble::tibble(
  x = c(cos(theta), axis_size), 
  y = c(axis_size, cos(theta)), 
  x_to = c(cos(theta), axis_size+l), 
  y_to = c(axis_size+l, cos(theta))
)
segment_adapt_df
```

　曲線の両端からx軸とy軸の反対側へ水平線と垂直線を引くように座標を指定します。\

　軸の変換図を作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 軸の変換曲線を作図
adapt_graph <- ggplot() + 
  geom_line(data = adapt_grid_df, 
            mapping = aes(x = x, y = y, group = d), 
            color = "white") + # グリッド線
  geom_line(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 軸変換曲線
  geom_point(data = segment_adapt_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # cos関数の点
  geom_segment(data = segment_adapt_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # cos直線・曲線との対応線
  #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(x = "x", y = "x")
adapt_graph
```

　軸の変換曲線とグリッド線をそれぞれ`geom_line()`で描画します。\
\

　「パターン1」のときのコードで、cos関数曲線のグラフを作成します。

```{r, echo=FALSE, fig.width=10, fig.height=5, dpi=100}
### 資料作成用:(値の変更)

# 変換曲線との対応線の座標を格納
l <- 1.2
d <- 1.1
segment_cos_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(cos(theta), cos(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-axis_size*d, cos(theta))
)

# cos関数曲線を作図
cos_graph <- ggplot() + 
  geom_line(data = cos_df, 
            mapping = aes(x = t, y = cos_t), 
            size = 1) + # cos曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = cos_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_cos_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # 変換曲線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "cosine function", 
       subtitle = parse(text = cos_label), 
       x = expression(theta), 
       y = expression(cos~theta))
cos_graph
```

\ 

</details>

　3つのグラフを並べて描画します。

```{r, fig.width=15, fig.height=9, dpi=100}
# 並べて描画
patchwork::wrap_plots(
  circle_graph, patchwork::plot_spacer(), 
  adapt_graph, cos_graph, 
  nrow = 2, ncol = 2, widths = c(1, 2, 1, 2), heights = c(1, 1, 1, 1)
)
```

　グラフを配置しない位置を`plot_spacer()`で指定します。\
　(サイズを調整しないと線がズレるようです。凡例を非表示にすると合いやすいかも?)\

　分かりやすい方の図を参考にしてください。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。\
\


#### 1周期

　円周上を1周した際のcos関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcos関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# グラフサイズ用の値を設定
axis_size <- 1.3

# cos関数を計算
cos_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  cos_t = cos(t)
)

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("cos", "cos", "cos", "sin", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 0, 
      0, cos(theta)
    ), 
    y_from = c(
      0, sin(theta), 0, 
      0, 0
    ), 
    x_to = c(
      cos(theta), cos(theta), 0, 
      0, cos(theta)
    ), 
    y_to = c(
      0, sin(theta), cos(theta), 
      sin(theta), sin(theta)
    ), 
    type = c("main", "main", "sub", "main", "main") # 線の種類用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cos", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 * cos(theta), 
      0
    ), 
    y = c(
      0,
      0.5 * sin(theta)
    ), 
    angle = c(0, 90), 
    v = c(1, -0.5), 
    fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(cos(theta), 0), 
    y = c(0, cos(theta))
  )
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = cos(theta) * cos(rad), 
    y = cos(theta) * sin(rad)
  )
  
  # cos曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = cos(theta), 
    x_to = axis_size+l
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = type, linetype = type)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # cos曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
    scale_size_manual(breaks = c("main", "sub"), 
                      values = c(1, 1.5), guide ="none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # cos直線との対応線の座標を格納
  l <- 0.8
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(cos(theta), cos(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-axis_size*d, cos(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = cos_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, cos_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　cos関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cos_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cos_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\
\


##### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcos関数とsin関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# グラフサイズ用の値を設定
axis_size <- 1.3

# sin・cos関数を計算
curve_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  sin_t = sin(t), 
  cos_t = cos(t)
)

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 軸変換図のグリッド線の描画用
adapt_grid_df <- tidyr::expand_grid(
  d = axis_size - seq(from = -1, to = 1, by = 0.5), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = axis_size + d * cos(rad), 
    y = axis_size + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("cos", "cos", "sin", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 
      0, cos(theta)
    ), 
    y_from = c(
      0, sin(theta), 
      0, 0
    ), 
    x_to = c(
      cos(theta), cos(theta), 
      0, cos(theta)
    ), 
    y_to = c(
      0, sin(theta), 
      sin(theta), sin(theta)
    )
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cos", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 * cos(theta), 
      0
    ), 
    y = c(
      0,
      0.5 * sin(theta)
    ), 
    angle = c(0, 90), 
    v = c(1, -0.5), 
    fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
  )
  
  # sin・cos曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = c(cos(theta), cos(theta)), 
    y = c(sin(theta), sin(theta)), 
    x_to = c(axis_size+l, cos(theta)), 
    y_to = c(sin(theta), -axis_size-l)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 軸変換曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## sin曲線の作図処理
  
  # sin直線との対応線の座標を格納
  l <- 1.4
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = theta, 
    y = sin(theta), 
    x_to = -l
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # sin直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  ## 軸の変換図の作図処理
  
  # cos関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
    x = axis_size + (axis_size-cos(theta)) * cos(rad), 
    y = axis_size + (axis_size-cos(theta)) * sin(rad)
  )
  
  # cos曲線・直線との対応線の座標を格納
  l <- 1
  segment_adapt_df <- tibble::tibble(
    x = c(cos(theta), axis_size), 
    y = c(axis_size, cos(theta)), 
    x_to = c(cos(theta), axis_size+l), 
    y_to = c(axis_size+l, cos(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cos直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cos曲線の作図処理
  
  # cos直線との対応線の座標を格納
  l <- 1.2
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(axis_size*d, cos(theta)), 
    x_to = c(theta, -l), 
    y_to = c(axis_size*d+l, cos(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    circle_graph, sin_graph, 
    adapt_graph, cos_graph, 
    nrow = 2, ncol = 2, widths = c(1, 2, 1, 2), heights = c(1, 1, 1, 1)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 900, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　先ほどと同様に処理します。\

</details>

　cos関数とsin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cos_sin_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cos_sin_1cycle.gif)

\ 


#### n周期

　円周上を複数回周回した際のcos関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcos関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# グラフサイズ用の値を設定
axis_size <- 1.3

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("cos", "cos", "cos", "sin", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 0, 
      0, cos(theta)
    ), 
    y_from = c(
      0, sin(theta), 0, 
      0, 0
    ), 
    x_to = c(
      cos(theta), cos(theta), 0, 
      0, cos(theta)
    ), 
    y_to = c(
      0, sin(theta), cos(theta), 
      sin(theta), sin(theta)
    ), 
    type = c("main", "main", "sub", "main", "main") # 線の種類用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cos", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 * cos(theta), 
      0
    ), 
    y = c(
      0,
      0.5 * sin(theta)
    ), 
    angle = c(0, 90), 
    v = c(1, -0.5), 
    fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(cos(theta), 0), 
    y = c(0, cos(theta))
  )
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = cos(theta) * cos(rad), 
    y = cos(theta) * sin(rad)
  )
  
  # cos曲線との対応線の座標を格納
  l <- 0.6
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = cos(theta), 
    x_to = -axis_size-l
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = type, linetype = type)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # cos曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
    scale_size_manual(breaks = c("main", "sub"), 
                      values = c(1, 1.5), guide ="none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "right") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # cos関数を計算
  cos_df <- tibble::tibble(
    t = theta_vec, 
    cos_t = cos(t)
  )
  
  # cos直線との対応線の座標を格納
  l <- 0.5
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(cos(theta), cos(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-axis_size*d, cos(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = cos_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(cos_graph, circle_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　cos関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cos_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cos_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が1周する $2 \pi$ の間隔で、曲線が同じ形になるのが分かります。\
\


##### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcos関数とsin関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cos", "sin")

# グラフサイズ用の値を設定
axis_size <- 1.3

# 軸変換図のグリッド線の描画用
adapt_grid_df <- tidyr::expand_grid(
  d = axis_size - seq(from = -1, to = 1, by = 0.5), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = axis_size + d * cos(rad), 
    y = axis_size + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("cos", "cos", "sin", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 
      0, cos(theta)
    ), 
    y_from = c(
      0, sin(theta), 
      0, 0
    ), 
    x_to = c(
      cos(theta), cos(theta), 
      0, cos(theta)
    ), 
    y_to = c(
      0, sin(theta), 
      sin(theta), sin(theta)
    )
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cos", "sin") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 * cos(theta), 
      0
    ), 
    y = c(
      0,
      0.5 * sin(theta)
    ), 
    angle = c(0, 90), 
    v = c(1, -0.5), 
    fnc_label = c("cos~theta", "sin~theta") # 関数ラベル
  )
  
  # sin・cos曲線との対応線の座標を格納
  l <- 1.4
  segment_circle_df <- tibble::tibble(
    x = c(cos(theta), cos(theta)), 
    y = c(sin(theta), sin(theta)), 
    x_to = c(-axis_size-l, cos(theta)), 
    y_to = c(sin(theta), axis_size+l)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 軸変換曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "right") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 変数の作成処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # sin・cos関数を計算
  curve_df <- tibble::tibble(
    t = theta_vec, 
    sin_t = sin(t), 
    cos_t = cos(t)
  )
  
  ## sin曲線の作図処理
  
  # sin直線との対応線の座標を格納
  l <- 1
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(axis_size*d, sin(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(axis_size*d+l, sin(theta))
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sin直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  ## 軸の変換図の作図処理
  
  # cos関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = -axis_size + (axis_size+cos(theta)) * cos(rad), 
    y = -axis_size + (axis_size+cos(theta)) * sin(rad)
  )
  
  # cos曲線・直線との対応線の座標を格納
  lx <- 1.2
  ly <- 0.1
  segment_adapt_df <- tibble::tibble(
    x = c(cos(theta), -axis_size), 
    y = c(-axis_size, cos(theta)), 
    x_to = c(cos(theta), -axis_size-lx), 
    y_to = c(-axis_size-ly, cos(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cos直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cos曲線の作図処理
  
  # cos直線との対応線の座標を格納
  l <- 1.5
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = theta, 
    y = cos(theta), 
    x_to = theta+l
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    cos_graph, adapt_graph, 
    sin_graph, circle_graph, 
    nrow = 2, ncol = 2, widths = c(2, 1, 2, 1), heights = c(1, 1, 1, 1)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 900, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から上下左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　cos関数とsin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cos_sin_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cos_sin_ncycle.gif)

\ 

　この記事では、cos関数を可視化しました。次の記事では、tan関数を可視化します。\
\


# cos関数の振幅・周期・平行移動の変形の可視化


# tan関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるtan関数(正接関数・タンジェント関数・tangent function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
###資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## 定義式の確認

　まずは、tan関数の定義式を確認します。\
\

　tan関数は、次の式で定義されます。

$$
\tan x
    = \frac{\sin x}{\cos x}
$$

　$\sin x$ はサイン関数、$\cos x$ はコサイン関数です。sin関数については「sin関数の可視化」、cos関数については「cos関数の可視化」を参照してください。\
　ただし、$n$ を整数として $x = \frac{2 n + 1}{2} \pi$ のとき、$\cos x = 0$ なので、0除算になるため定義できません。$\pi$ は円周率で、変数 $x$ は弧度法の角度(ラジアン)です。\
\


## tan関数の作図

　次に、tan関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　tan関数の曲線を描画するためのデータフレームを作成します。

```{r}
# 閾値を指定
threshold <- 4

# tan関数を計算
tan_df <- tibble::tibble(
  t = theta_vec, 
  sin_t = sin(theta_vec), 
  cos_t = cos(theta_vec), 
  tan_t = tan(theta_vec)
) |> 
  dplyr::mutate(
    tan_t = dplyr::if_else(
      condition = (tan_t >= -threshold & tan_t <= threshold), 
      true = tan_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
tan_df
```

　$\theta$ の値と $\sin \theta, \cos \theta, \tan \theta$ の値をデータフレームに格納します。tan関数は`tan()`で計算できます。sin関数とcos関数の値は比較に使います。\
　$\theta = \frac{2 i + 1}{2} \pi$ ($i$ は整数)付近で $-\infty$ または $\infty$ に近付くので、閾値`threshold`を指定しておき、`-threshold`未満または`threshold`より大きい場合は(数値型の)欠損値`NA`に置き換えます。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

　漸近線を描画するためのベクトルを作成します。

```{r}
# 漸近線用の値を作成
asymptote_vec <- seq(
  from = floor(min(theta_vec) / pi) + 0.5, 
  to = floor(max(theta_vec) / pi) + 0.5, 
  by = 1
) * pi
asymptote_vec; asymptote_vec*2/pi
```

　$\theta = \frac{2 i + 1}{2} \pi$ のとき $\tan \theta$ が発散するので、`theta_vec`の範囲内の $\frac{2 i + 1}{2} \pi$ の値を(上手いことして)作成します。\

</details>

　tan関数のグラフを作成します。

```{r, fig.width=10, fig.height=6, dpi=100}
# tan関数を作図
ggplot() + 
  geom_line(data = tan_df, 
            mapping = aes(x = t, y = tan_t, linetype = "tan"), 
            size = 1, na.rm = TRUE) + # tan曲線
  geom_line(data = tan_df, 
            mapping = aes(x = t, y = sin_t, linetype = "sin"), 
            size = 1) + # sin曲線
  geom_line(data = tan_df, 
            mapping = aes(x = t, y = cos_t, linetype = "cos"), 
            size = 1) + # cos曲線
  geom_vline(xintercept = asymptote_vec, linetype = "dashed") + # 漸近線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("tan", "sin", "cos"), 
                        values = c("solid", "dotdash", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "tangent function", 
       x = expression(theta), 
       y = expression(tan~theta))
```

　x軸を $\theta$、y軸を $\tan \theta$ として、`geom_line()`でtan関数の曲線を描画します。また、$\sin \theta, \cos \theta$ の曲線を点線で描画します。\
　x軸が $\frac{2 i + 1}{2} \pi$ の点($\frac{1}{2} \pi$ の前後 $\pi$ 間隔)に、`geom_vline()`で漸近線を破線で描画します。\
　$\cos \theta = 0$ となる $\theta$ が漸近線なのが分かります。\
\


## 単位円の作図

　続いて、tan関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のtan関数の可視化

　次は、単位円上における三角関数(tan・sin・cos・exsec)のグラフを作成します。\
\


### グラフの作成

　変数を固定したtan関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2点の座標を格納します。原点の座標は、作図時に値を引数に指定します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

</details>

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、x軸線から伸びる直線としてtan関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("tan", "sin", "cos", "exsec")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    1, 
    cos(theta), 
    0, 
    cos(theta)
  ), 
  y_from = c(
    0, 
    0, 
    0, 
    sin(theta)
  ), 
  x_to = c(
    1, 
    cos(theta), 
    cos(theta), 
    1
  ), 
  y_to = c(
    tan(theta), 
    sin(theta), 
    0, 
    tan(theta)
  )
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    1, 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 * (cos(theta) + 1)
  ), 
  y = c(
    0.5 * tan(theta), 
    0.5 * sin(theta), 
    0, 
    0.5 * (sin(theta) + tan(theta))
  ), 
  angle = c(90, 90, 0, 0), 
  h = c(0.5, 0.5, 0.5, 1.1), 
  v = c(1, -0.5, 1, 0.5), 
  fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ラベルの表示角度を`angle`列、表示角度に応じた左右の表示位置を`h`列、上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
x_size <- 1.3
y_min  <- min(-x_size, tan(theta))
y_max  <- max(x_size, tan(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # tan直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　tan関数の定義式 $\tan \theta = \frac{\sin \theta}{\cos \theta}$ やこの図から、$\cos \theta : \sin \theta = 1 : \tan \theta$ なのが分かります。tan関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」と「$x = 1$ の直線(破線)」の交点のy軸の値(高さ)です。\
　$\mathrm{exsec}\ \theta = \frac{1}{\cos \theta} - 1$ も三角関数の一種ですが、まぁいいでしょう。\
\


#### パターン2

　2つ目の方法では、円周上の点から伸びる直線としてtan関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("tan", "sin", "sin", "cos", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    cos(theta), 
    cos(theta), abs(cos(theta))*cos(theta), 
    0, 0, 
    1
  ), 
  y_from = c(
    sin(theta), 
    0, abs(cos(theta))*sin(theta), 
    0, 0, 
    0
  ), 
  x_to = c(
    1/cos(theta), 
    cos(theta), ifelse(cos(theta) >= 0, yes = 1, no = -1), 
    cos(theta), abs(cos(theta))*cos(theta), 
    1/cos(theta)
  ), 
  y_to = c(
    0, 
    sin(theta), 0, 
    0, abs(cos(theta))*sin(theta), 
    0
  ), 
  type = c("normal", "normal", "normal", "bold", "normal", "tiny") # 太さ用
)
function_line_df
```

　先ほどの様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 * (1/cos(theta) + cos(theta)), 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 * (1 + 1/cos(theta))
  ), 
  y = c(
    0.5 * sin(theta), 
    0.5 * sin(theta), 
    0, 
    0
  ), 
  angle = c(0, 90, 0, 0), 
  h = c(-0.5, 0.5, 0.5, 0.5), 
  v = c(0.5, -0.5, 1, -0.5), 
  fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
y_size <- 1.3
x_min  <- min(-y_size, 1/cos(theta))
x_max  <- max(y_size, 1/cos(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 0, linetype = "dashed") + # tan直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "tiny"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　こちらの図は、原点と点 $(\cos \theta, \sin \theta)$ を結ぶ線分を底辺、x軸線の一部を斜辺としたときのパターン1の図と言えます。文字通り首を捻って見てください。\
　tan関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」に対する「点 $(\cos \theta, \sin \theta)$ を通る垂線」と「$y = 0$ の直線(破線)」の「交点 $(\frac{1}{\cos \theta}, 0)$ と点 $(\cos \theta, \sin \theta)$ を結ぶ線分」の長さです。\
\


### アニメーションの作成

　続いて、変数の値を変化させたtan関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 \pi$ の倍数にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", tan θ = ", round(tan(theta_i), digits = 2), 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", exsec θ = ", round(1/cos(theta_i)-1, digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 2) |> # (2は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　フレーム数分の点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標を格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

</details>

　ここまでは、共通の処理です。ここからは、「グラフの作成」のときと同様に2つの方法で図示します。\
\


#### パターン1

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("tan", "sin", "cos", "exsec")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    cos(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    cos(theta_i), 
    rep(1, times = frame_num)
  ), 
  y_to = c(
    tan(theta_i), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    tan(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = length(fnc_level_vec)) |> 
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　「グラフの作成」のときと同様に、線分ごとに`frame_num`個の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, 0.5, 1.1) |> 
      rep(each = frame_num), 
    v = c(1, -0.5, 1, 0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`を`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 1.3
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # tan直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 800)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

　$\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ のとき $\cos \theta = 0$ なので、原点と円周上の点を結ぶ線分が垂直になり直線 $x = 1$ と平行なため交点ができず、$\tan \theta$ を描画(定義)できないのが分かります。\
\


#### パターン2

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("tan", "sin", "sin", "cos", "cos", "exsec") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    cos(theta_i), 
    cos(theta_i), abs(cos(theta_i))*cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(1, times = frame_num)
  ), 
  y_from = c(
    sin(theta_i), 
    rep(0, times = frame_num), abs(cos(theta_i))*sin(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    1/cos(theta_i), 
    cos(theta_i), ifelse(cos(theta_i) >= 0, yes = 1, no = -1), 
    cos(theta_i), abs(cos(theta_i))*cos(theta_i), 
    1/cos(theta_i)
  ), 
  y_to = c(
    rep(0, times = frame_num), 
    sin(theta_i), rep(0, times = frame_num), 
    rep(0, times = frame_num), abs(cos(theta_i))*sin(theta_i), 
    rep(0, times = frame_num)
  ), 
  type = c("normal", "normal", "normal", "bold", "normal", "tiny") |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE) |> 
    rep(each = frame_num), # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 6) |> # (6は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　先ほどと同様に、線分の座標を格納します。こちらは、関数ラベルを描画する線分を`label_flag`列に指定しておきます。関数ごとに、ラベルを表示する1つの線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(-0.2, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, -0.5, 1, -0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`label_flag`列が`TRUE`の行(線分)を取り出して、先ほどの同様に中点の座標を計算します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 0, linetype = "dashed") + # tan直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "tiny"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 600)
```

　こちらの図だと、原点と円周上の点を結ぶ線分が水平になり、その垂線が直線 $y = 0$ と平行なため交点ができず、$\tan \theta$ を描画(定義)できないのが分かります。\
\


## 単位円上の点とtan関数曲線の関係の可視化

　最後は、単位円上におけるtan関数の値(直線)と、tan関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したtan関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta), 
  tan_t = tan(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のtan関数の可視化」の「パターン1」のコードで5つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.25
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)

# 関数ラベルのレベルを指定
fnc_level_vec <- c("tan", "sin", "cos", "exsec")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    1, 
    cos(theta), 
    0, 
    cos(theta)
  ), 
  y_from = c(
    0, 
    0, 
    0, 
    sin(theta)
  ), 
  x_to = c(
    1, 
    cos(theta), 
    cos(theta), 
    1
  ), 
  y_to = c(
    tan(theta), 
    sin(theta), 
    0, 
    tan(theta)
  ), 
  type = c("normal", "normal", "normal", "tiny") # 太さ用
)

# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("tan", "sin", "cos", "exsec") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    1, 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 * (cos(theta) + 1)
  ), 
  y = c(
    0.5 * tan(theta), 
    0.5 * sin(theta), 
    0, 
    0.5 * (sin(theta) + tan(theta))
  ), 
  angle = c(90, 90, 0, 0), 
  h = c(0.5, 0.5, 0.5, 1.1), 
  v = c(1, -0.5, 1, 0.5), 
  fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") # 関数ラベル
)
```

　単位円における点とtan曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- max(x_size, abs(tan(theta))+0.5)

# tan曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = 1, 
  x_to = x_size+l, 
  y = tan(theta)
)
segment_circle_df
```

　単位円における点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=8, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # tan直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_point(data = segment_circle_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # tan関数点
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y), 
               size = 1, linetype = "dotted") + # tan曲線との対応線
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のtan関数の可視化」のときと同様に、作図します。\
\

　tan関数の曲線を描画するためのデータフレームを作成します。

```{r}
# tan関数を計算
tan_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  tan_t = tan(t)
) |> 
  dplyr::mutate(
    tan_t = dplyr::if_else(
      condition = (tan_t >= -y_size & tan_t <= y_size), 
      true = tan_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
tan_df
```

　「tan関数の作図」のときと同様にして、曲線の座標を計算します。\

　tan曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# tan直線との対応線の座標を格納
l <- 0.8
d <- 1.1
segment_tan_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(tan(theta), tan(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-y_size*d, tan(theta))
)
segment_tan_df
```

　曲線上の点からx軸とy軸へ垂線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「tan関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　tan関数曲線のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 関数ラベル用の文字列を作成
tan_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ")"
)

# tan関数曲線を作図
tan_graph <- ggplot() + 
  geom_line(data = tan_df, 
            mapping = aes(x = t, y = tan_t), 
            size = 1, na.rm = TRUE) + # tan曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = tan_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_tan_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # tan直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "tangent function", 
       subtitle = parse(text = tan_label), 
       x = expression(theta), 
       y = expression(tan~theta))
tan_graph
```

　「tan関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, tan_graph, guides = "collect")
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、点のy軸の値と、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。\
\


#### 1周期

　円周上を1周した際のtan関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("tan", "sin", "cos", "exsec")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 3

# tan関数を計算
tan_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), 
  tan_t = tan(t)
) |> 
  dplyr::mutate(
    tan_t = dplyr::if_else(
      condition = (tan_t >= -y_size & tan_t <= y_size), 
      true = tan_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    tan_t = tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("tan", "sin", "cos", "exsec") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      1, 
      cos(theta), 
      0, 
      cos(theta)
    ), 
    y_from = c(
      0, 
      0, 
      0, 
      sin(theta)
    ), 
    x_to = c(
      1, 
      cos(theta), 
      cos(theta), 
      1
    ), 
    y_to = c(
      tan(theta), 
      sin(theta), 
      0, 
      tan(theta)
    ), 
    type = c("normal", "normal", "normal", "tiny") # 太さ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("tan", "sin", "cos", "exsec") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      1, 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1)
    ), 
    y = c(
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta))
    ), 
    angle = c(90, 90, 0, 0), 
    h = c(0.5, 0.5, 0.5, 1.1), 
    v = c(1, -0.5, 1, 0.5), 
    fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") # 関数ラベル
  )
  
  # tan曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 1, 
    x_to = x_size+l, 
    y = tan(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # tan直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_point(data = segment_circle_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # tan関数点
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # tan曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # tan直線との対応線の座標を格納
  l <- 0.8
  d <- 1.1
  segment_tan_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(tan(theta), tan(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-y_size*d, tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  tan_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # tan関数曲線を作図
  tan_graph <- ggplot() + 
    geom_line(data = tan_df, 
              mapping = aes(x = t, y = tan_t), 
              size = 1, na.rm = TRUE) + # tan曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = tan_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_tan_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # tan直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "tangent function", 
         subtitle = parse(text = tan_label), 
         x = expression(theta), 
         y = expression(tan~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, tan_graph, guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　tan関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/tan_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/tan_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\

　$\cos \theta = 0$ となる $\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ とき、tan関数の線分の方向($\tan \theta$ の符号)が変わり、tan関数の曲線が不連続になるのが分かります。\
\


#### n周期

　円周上を複数回周回した際のtan関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("tan", "sin", "cos", "exsec")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 3

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    tan_t = tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c("tan", "sin", "cos", "exsec") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      1, 
      cos(theta), 
      0, 
      cos(theta)
    ), 
    y_from = c(
      0, 
      0, 
      0, 
      sin(theta)
    ), 
    x_to = c(
      1, 
      cos(theta), 
      cos(theta), 
      1
    ), 
    y_to = c(
      tan(theta), 
      sin(theta), 
      0, 
      tan(theta)
    ), 
    type = c("normal", "normal", "normal", "tiny") # 太さ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("tan", "sin", "cos", "exsec") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      1, 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1)
    ), 
    y = c(
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta))
    ), 
    angle = c(90, 90, 0, 0), 
    h = c(0.5, 0.5, 0.5, 1.1), 
    v = c(1, -0.5, 1, 0.5), 
    fnc_label = c("tan~theta", "sin~theta", "cos~theta", "exsec~theta") # 関数ラベル
  )
  
  # tan曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 1, 
    x_to = -x_size-l, 
    y = tan(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # tan直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
                 size = 1) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_point(data = segment_circle_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # tan関数点
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # tan曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # tan関数を計算
  tan_df <- tibble::tibble(
    t = theta_vec, 
    tan_t = tan(t)
  ) |> 
    dplyr::mutate(
      tan_t = dplyr::if_else(
        (tan_t >= -y_size & tan_t <= y_size), 
        true = tan_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # tan直線との対応線の座標を格納
  l <- 0.8
  d <- 1.1
  segment_tan_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(tan(theta), tan(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-y_size*d, tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  tan_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # tan関数曲線を作図
  tan_graph <- ggplot() + 
    geom_line(data = tan_df, 
              mapping = aes(x = t, y = tan_t), 
              size = 1, na.rm = TRUE) + # tan曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = tan_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_tan_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # tan直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "tangent function", 
         subtitle = parse(text = tan_label), 
         x = expression(theta), 
         y = expression(tan~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(tan_graph, circle_graph, guides = "collect")
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 900, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　tan関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/tan_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/tan_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が半周する $\pi$ の間隔で、曲線が同じ形になるのが分かります。\
\

　この記事では、tan関数を可視化しました。次の記事では、sec関数を可視化します。\
\


# tan関数の振幅・周期・平行移動の変形の可視化


# sec関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるsec関数(正割関数・セカント関数・secant function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
### 資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## 定義式の確認

　まずは、sec関数の定義式を確認します。\
\

　sec関数は、cos関数の逆数で定義されます。

$$
\sec x
    = \frac{1}{\cos x}
$$

　$\cos x$ はコサイン関数です。cos関数については「cos関数の可視化」を参照してください。\
　ただし、$n$ を整数として $x = \frac{2 n + 1}{2} \pi$ のとき、$\cos x = 0$ なので、0除算になるため定義できません。$\pi$ は円周率で、変数 $x$ は弧度法の角度(ラジアン)です。\
\


## sec関数の作図

　次に、sec関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　sec関数の曲線を描画するためのデータフレームを作成します。

```{r}
# 閾値を指定
threshold <- 4

# sec関数を計算
sec_df <- tibble::tibble(
  t = theta_vec, 
  cos_t = cos(theta_vec), 
  sec_t = 1/cos(theta_vec)
) |> 
  dplyr::mutate(
    sec_t = dplyr::if_else(
      condition = (sec_t >= -threshold & sec_t <= threshold), 
      true = sec_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
sec_df
```

　$\theta$ の値と $\cos \theta, \sec \theta$ の値をデータフレームに格納します。sec関数は`cos()`を使って計算できます。cos関数の値は比較に使います。\
　$\theta = \frac{2 i + 1}{2} \pi$ ($i$ は整数)付近で $-\infty$ または $\infty$ に近付くので、閾値`threshold`を指定しておき、`-threshold`未満または`threshold`より大きい場合は(数値型の)欠損値`NA`に置き換えます。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

　漸近線を描画するためのベクトルを作成します。

```{r}
# 漸近線用の値を作成
asymptote_vec <- seq(
  from = floor(min(theta_vec) / pi) + 0.5, 
  to = floor(max(theta_vec) / pi) + 0.5, 
  by = 1
) * pi
asymptote_vec; asymptote_vec*2/pi
```

　$\theta = \frac{2 i + 1}{2} \pi$ のとき $\sec \theta$ が発散するので、`theta_vec`の範囲内の $\frac{2 i + 1}{2} \pi$ の値を(上手いことして)作成します。\

</details>

　sec関数のグラフを作成します。

```{r, fig.width=10, fig.height=6, dpi=100}
# sec関数を作図
ggplot() + 
  geom_line(data = sec_df, 
            mapping = aes(x = t, y = sec_t, linetype = "sec"), 
            size = 1, na.rm = TRUE) + # sec曲線
  geom_line(data = sec_df, 
            mapping = aes(x = t, y = cos_t, linetype = "cos"), 
            size = 1) + # cos曲線
  geom_vline(xintercept = asymptote_vec, linetype = "dashed") + # 漸近線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("sec", "cos"), 
                        values = c("solid", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "secant function", 
       x = expression(theta), 
       y = expression(sec~theta))
```

　x軸を $\theta$、y軸を $\sec \theta$ として、`geom_line()`でsec関数の曲線を描画します。また、$\cos \theta$ の曲線を点線で描画します。\
　x軸が $\frac{2 i + 1}{2} \pi$ の点($\frac{1}{2} \pi$ の前後 $\pi$ 間隔)に、`geom_vline()`で漸近線を破線で描画します。\
　$\cos \theta = 0$ となる $\theta$ が漸近線なのが分かります。\
\


## 単位円の作図

　続いて、sec関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のsec関数の可視化

　次は、単位円上における三角関数(sec・sin・cos・tan)のグラフを作成します。\
\


### グラフの作成

　変数を固定したsec関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2点の座標を格納します。原点の座標は、作図時に値を引数に指定します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

</details>

　ここまでは、共通の処理です。ここからは、3つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、x軸線から伸びる直線としてシンプルにsec関数を可視化します。ただし、sec関数の絶対値と線分の長さが対応しますが、sec関数の正負と座標が対応しません。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("sec", "sin", "cos", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 
    cos(theta), 
    0, 
    1
  ), 
  y_from = c(
    0, 
    0, 
    0, 
    0
  ), 
  x_to = c(
    1, 
    cos(theta), 
    cos(theta), 
    1
  ), 
  y_to = c(
    tan(theta), 
    sin(theta), 
    0, 
    tan(theta)
  )
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sec", "sin", "cos", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5, 
    cos(theta), 
    0.5 * cos(theta), 
    1
  ), 
  y = c(
    0.5 * tan(theta), 
    0.5 * sin(theta), 
    0, 
    0.5 * tan(theta)
  ), 
  angle = c(0, 90, 0, 90), 
  h = c(1.1, 0.5, 0.5, 0.5), 
  v = c(0.5, -0.5, 1, 1), 
  fnc_label = c(
    ifelse(test = sin(theta) >= 0, yes = "sec~theta", no = "-sec~theta"), 
    "sin~theta", 
    "cos~theta", 
    "tan~theta"
  ) # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ただし、$\pi \lt \theta \lt 2 \pi$ の範囲でsec直線が直感的でない座標になるので、$\sin \theta \lt 0$ のときマイナスの符号を付けて表示することにします。\
　ラベルの表示角度を`angle`列、表示角度に応じた左右の表示位置を`h`列、上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sec~theta==", round(1/cos(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
x_size <- 1.3
y_min <- min(-x_size, tan(theta))
y_max <- max(x_size, tan(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　sec関数の定義式 $\sec \theta = \frac{1}{\cos \theta}$ やこの図から、$\cos \theta : 1 = 1 : \sec \theta$ なのが分かります。sec関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」と「$x = 1$ の直線(破線)」の交点 $(1, \tan \theta)$ と原点を結ぶ線分の長さです。ただし、$\pi \lt \theta \lt 2 \pi$ の範囲では符号が反転します。\
\


#### パターン2

　2つ目の方法では、x軸線から伸びる直線としてsec関数の正負とy軸の正負が対応するように可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 変換フラグを設定
sin_flg <- sin(theta) >= 0

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "sec", "sec", 
    "sin", 
    "cos", 
    "tan", "tan"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, ifelse(test = sin_flg, yes = NA, no = 0), 
    cos(theta), 
    0, 
    1, ifelse(test = sin_flg, yes = NA, no = 1)
  ), 
  y_from = c(
    0, ifelse(test = sin_flg, yes = NA, no = 0), 
    0, 
    0, 
    0, ifelse(test = sin_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    1, ifelse(test = sin_flg, yes = NA, no = 1), 
    cos(theta), 
    cos(theta), 
    1, ifelse(test = sin_flg, yes = NA, no = 1)
  ), 
  y_to = c(
    ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 
    sin(theta), 
    0, 
    tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
  ), 
  type = c(
    "main", "sub", 
    "main", 
    "main", 
    "main", "sub"
  ) # 線タイプ用
)
function_line_df
```

　「パターン1」の座標に加えて、$\pi \lt \theta \lt 2 \pi$ の範囲でも直感的な座標になるように、符号を反転させた線分の座標を格納します。\
　元の関数(線分)と符号を反転させた関数(線分)を、線の種類で描き分けることにします。`type`列として、それぞれの線を区別するための文字列を指定します。文字列の内容は自由です。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sec", "sec", "sin", "cos", "tan", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5, ifelse(test = sin_flg, yes = NA, no = 0.5), 
    cos(theta), 
    0.5 * cos(theta), 
    1, ifelse(test = sin_flg, yes = NA, no = 1)
  ), 
  y = c(
    0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = 0.5*tan(theta)), 
    0.5 * sin(theta), 
    0, 
    0.5 * tan(theta), ifelse(test = sin_flg, yes = NA, no = -0.5*tan(theta))
  ), 
  angle = c(0, 0, 90, 0, 90, 90), 
  h = c(1.1, 1.1, 0.5, 0.5, 0.5, 0.5), 
  v = c(0.5, 0.5, -0.5, 1, 1, 1), 
  fnc_label = c("sec~theta", "-sec~theta", "sin~theta", "cos~theta", "tan~theta", "-tan~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- max(x_size, abs(tan(theta)))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, linetype = type), 
               size = 1, na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　$\pi \lt \theta \lt 2 \pi$ のとき $\sin \theta \lt 0$ であり、$\tan \theta = \frac{\sin \theta}{\cos \theta}$ なので、原点と $(1, - \tan \theta)$ を結ぶ線分の長さです。sec関数の符号はy軸の値の符号と対応します。\
\


#### パターン3

　3つ目の方法では、円周上の点から伸びる直線としてsec関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("sec", "sin", "sin", "cos", "cos", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 
    cos(theta), abs(cos(theta))*cos(theta), 
    0, 0, 
    cos(theta)
  ), 
  y_from = c(
    0, 
    0, abs(cos(theta))*sin(theta), 
    0, 0, 
    sin(theta)
  ), 
  x_to = c(
    1/cos(theta), 
    cos(theta), ifelse(cos(theta) >= 0, yes = 1, no = -1), 
    cos(theta), abs(cos(theta))*cos(theta), 
    1/cos(theta)
  ), 
  y_to = c(
    0, 
    sin(theta), 0, 
    0, abs(cos(theta))*sin(theta), 
    0
  ), 
  type = c("bold", "normal", "normal", "thin", "normal", "normal") # 太さ用
)
function_line_df
```

　先ほどの様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sec", "sin", "cos", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / cos(theta), 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 * (1/cos(theta) + cos(theta))
  ), 
  y = c(
    0, 
    0.5 * sin(theta), 
    0, 
    0.5 * sin(theta)
  ), 
  angle = c(0, 90, 0, 0), 
  h = c(0.5, 0.5, 0.5, -0.2), 
  v = c(1, -0.5, -0.5, 0.5), 
  fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
y_size <- 1.3
x_min <- min(-y_size, 1/cos(theta))
x_max <- max(y_size, 1/cos(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 0, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　こちらの図は、原点と点 $(\cos \theta, \sin \theta)$ を結ぶ線分を底辺、x軸線の一部を斜辺としたときのパターン1の図と言えます。文字通り首を捻って見てください。\
　sec関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」に対する「点 $(\cos \theta, \sin \theta)$ を通る垂線」と「$y = 0$ の直線(破線)」の「交点 $(\frac{1}{\cos \theta}, 0)$ と原点を結ぶ線分」の長さです。\
\


### アニメーションの作成

　続いて、変数の値を変化させたsec関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 n \pi$ にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", sec θ = ", round(1/cos(theta_i), digits = 2), 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", tan θ = ", round(tan(theta_i), digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 2) |> # (2は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　フレーム数分の点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標を格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

</details>

　ここまでは、共通の処理です。ここからは、「グラフの作成」のときと同様に3つの方法で図示します。\
\


#### パターン1

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("sec", "sin", "cos", "tan") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    rep(1, times = frame_num)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    cos(theta_i), 
    rep(1, times = frame_num)
  ), 
  y_to = c(
    tan(theta_i), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    tan(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = length(fnc_level_vec)) |> 
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　「グラフの作成」のときと同様に、線分ごとに`frame_num`個の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 90) |> 
      rep(each = frame_num), 
    h = c(1.1, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, -0.5, 1, 1) |> 
      rep(each = frame_num), 
    fnc_label = c(
      ifelse(test = sin(theta_i) >= 0, yes = "sec~theta", no = "-sec~theta"), 
      rep("sin~theta", times = frame_num), 
      rep("cos~theta", times = frame_num), 
      rep("tan~theta", times = frame_num)
    ) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`を`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 1.3
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 800)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

　$\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ のとき $\cos \theta = 0$ なので、原点と円周上の点を結ぶ線分が垂直になり直線 $x = 1$ と平行なため交点ができず、$\sec \theta$ を描画(定義)できないのが分かります。\
\


#### パターン2

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 変換フラグを設定
sin_flg_i <- sin(theta_i) >= 0

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("sec", "sec", "sin", "cos", "tan", "tan") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 0), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    rep(1, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 1)
  ), 
  y_from = c(
    rep(0, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 0), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 0)
  ), 
  x_to = c(
    rep(1, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 1), 
    cos(theta_i), 
    cos(theta_i), 
    rep(1, times = frame_num), ifelse(test = sin_flg_i, yes = NA, no = 1)
  ), 
  y_to = c(
    ifelse(test = sin_flg_i, yes = tan(theta_i), no = -tan(theta_i)), ifelse(test = sin_flg_i, yes = NA, no = tan(theta_i)), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    tan(theta_i), ifelse(test = sin_flg_i, yes = NA, no = -tan(theta_i))
  ), 
  type = c(
    rep("main", times = frame_num), rep("sub", times = frame_num), 
    rep("main", times = frame_num), 
    rep("main", times = frame_num), 
    rep("main", times = frame_num), rep("sub", times = frame_num)
  ), # 線タイプ用
  frame_label = frame_label_vec |> 
    rep(times = 6) |> # (6は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　先ほどと同様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(type == "main") |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 90) |> 
      rep(each = frame_num), 
    h = c(1.1, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, -0.5, 1, 1) |> 
      rep(each = frame_num), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`type`列が`"main"`の行(元の関数の線分)を取り出して、先ほどの同様に中点の座標を計算します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 1.3
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, linetype = type), 
               size = 1, na.rm = TRUE) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 800)
```

\ 


#### パターン3

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("sec", "sin", "sin", "cos", "cos", "tan") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), 
    cos(theta_i), abs(cos(theta_i))*cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    cos(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), abs(cos(theta_i))*sin(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  x_to = c(
    1/cos(theta_i), 
    cos(theta_i), ifelse(cos(theta_i) >= 0, yes = 1, no = -1), 
    cos(theta_i), abs(cos(theta_i))*cos(theta_i), 
    1/cos(theta_i)
  ), 
  y_to = c(
    rep(0, times = frame_num), 
    sin(theta_i), rep(0, times = frame_num), 
    rep(0, times = frame_num), abs(cos(theta_i))*sin(theta_i), 
    rep(0, times = frame_num)
  ), 
  type = c("bold", "normal", "normal", "thin", "normal", "normal") |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE) |> 
    rep(each = frame_num), # # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 6) |> # (6は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　先ほどと同様に、線分の座標を格納します。こちらは、関数ラベルを描画する線分を`label_flag`列に指定しておきます。関数ごとに、ラベルを表示する1つの線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, 0.5, -0.2) |> 
      rep(each = frame_num), 
    v = c(1, -0.5, -0.5, 0.) |> 
      rep(each = frame_num), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`label_flag`列が`TRUE`の行(線分)を取り出して、先ほどの同様に中点の座標を計算します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 0, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 600)
```

　こちらの図だと、原点と円周上の点を結ぶ線分が垂直になり、その垂線が直線 $y = 0$ と平行なため交点ができず、$\sec \theta$ を描画(定義)できないのが分かります。\
\


## 単位円上の点とsec関数曲線の関係の可視化

　最後は、単位円上におけるsec関数の値(直線)と、sec関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したsec関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta), 
  sec_t = 1/cos(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のsec関数の可視化」のコードで3つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
```

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# 変換フラグを設定
sin_flg <- sin(theta) >= 0

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "sec", "sec", "sec", 
    "sin", 
    "cos", 
    "tan", "tan"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
    cos(theta), 
    0, 
    1, ifelse(test = sin_flg, yes = NA, no = 1)
  ), 
  y_from = c(
    0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
    0, 
    0, 
    0, ifelse(test = sin_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    1, ifelse(test = sin_flg, yes = NA, no = 1), 0, 
    cos(theta), 
    cos(theta), 
    1, ifelse(test = sin_flg, yes = NA, no = 1)
  ), 
  y_to = c(
    ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 1/cos(theta), 
    sin(theta), 
    0, 
    tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
  ), 
  type = c(
    "main", ifelse(test = sin_flg, yes = NA, no = "sub"), "sub", 
    "main", 
    "main", 
    "main", "sub"
  ) # 線タイプ用
)
function_line_df
```

　「単位円上のsec関数の可視化」のときのコードに、sec直線の1つを垂直線に回転した線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("sec", "sin", "cos", "tan") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5, 
    cos(theta), 
    0.5 * cos(theta), 
    1
  ), 
  y = c(
    0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 
    0.5 * sin(theta), 
    0, 
    0.5 * tan(theta)
  ), 
  angle = c(0, 90, 0, 90), 
  h = c(1.1, 0.5, 0.5, 0.5), 
  v = c(0.5, -0.5, 1, 1), 
  fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
)
function_label_df
```

　(図がゴチャゴチャするので)符号を反転させたラベルは描画しないことにします。\

　軸の変換前後の点を描画するためのデータフレームを作成します。

```{r}
# 変換曲線の先端の座標を格納
adapt_point_df <- tibble::tibble(
  x = c(1, 0), 
  y = c(ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 1/cos(theta))
)
adapt_point_df
```

　原点から伸びるsec直線の座標について、直線 $x = 1$ 上の点 $(1, \pm \tan \theta)$ と直線 $x = 0$ 上の点 $(0, \sec \theta)$ を格納します。\

　垂直線になるように直線を回転する軌道を描画するためのデータフレームを作成します。

```{r}
# sec直線の角度を設定
if(cos(theta) >= 0) {
  tmp_theta <- acos(cos(theta))
} else {
  tmp_theta <- pi + acos(cos(theta))
}

# 軸変換曲線の描画用
adapt_line_df <- tibble::tibble(
  rad = seq(
    from = tmp_theta, 
    to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
    length.out = 100
  ), 
  x = abs(1/cos(theta)) * cos(rad), 
  y = abs(1/cos(theta)) * sin(rad)
)
adapt_line_df
```

　軸を変換する軌道として、半径が $|\sec \theta|$ の弧を描画します。全体値 $|x|$ は`abs()`で計算できます。\

　任意の範囲で設定したラジアン $\theta$ を $0 \leq \alpha \leq \pi$ の範囲のラジアンに変換します。コサイン関数 $\cos x$ の逆関数(逆コサイン関数) $\arccos x$ を使って、 $\alpha = \arccos(\cos \theta)$ で計算します。逆コサイン関数は`acos()`で計算できます。\
　ただし、$\cos \theta \lt 0$ の範囲では、円周上の点と反対側にsec直線を描画しました。そこで、$\pi$ を加えた値を $\alpha$ とします。\

　$\sec \theta \geq 0$ のとき($\cos \theta \geq 0$ のとき)第1象限からy軸の正の部分への変化を示すため $\alpha \leq t \leq \frac{\pi}{2}$ のラジアン、$\sec \theta \lt 0$ のとき($\cos \theta \lt 0$ のとき)第4象限からy軸の負の部分への変化を示すため $\frac{3 \pi}{2} \leq t \leq \alpha$ のラジアンを用いて、弧のx軸の値 $x = |\sec \theta| \cos t$ とy軸の値 $y = |\sec \theta| \sin t$ を計算します。\

　単位円における点とsec曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
x_size <- 1.3
y_min  <- 2
y_max  <- 5
y_size <- ceiling(abs(1/cos(theta))) |> 
  max(y_min) |> 
  min(y_max)

# sec曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = 0, 
  y = 1/cos(theta), 
  x_to = x_size+l
)
segment_circle_df
```

　単位円における点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sec~theta==", round(1/cos(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(data = adapt_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # sec関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, linetype = type), 
               size = 1, na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 変換曲線
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y), 
               size = 1, linetype = "dotted") + # sec曲線との対応線
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のsec関数の可視化」のときと同様に、作図します。\
\

　sec関数の曲線を描画するためのデータフレームを作成します。

```{r}
# sec関数を計算
sec_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  sec_t = 1/cos(t)
) |> 
  dplyr::mutate(
    sec_t = dplyr::if_else(
      condition = (sec_t >= -y_size & sec_t <= y_size), 
      true = sec_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
sec_df
```

　「sec関数の作図」のときと同様にして、曲線の座標を計算します。\

　sec曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# sec直線との対応線の座標を格納
l <- 0.7
d <- 1.1
segment_sec_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(1/cos(theta), 1/cos(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-y_size*d, 1/cos(theta))
)
segment_sec_df
```

　曲線上の点からx軸とy軸へ垂線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「sec関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　sec関数曲線のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 関数ラベル用の文字列を作成
sec_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sec~theta==", round(1/cos(theta), digits = 2), 
  ")"
)

# sec関数曲線を作図
sec_graph <- ggplot() + 
  geom_line(data = sec_df, 
            mapping = aes(x = t, y = sec_t), 
            size = 1, na.rm = TRUE) + # sec曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = sec_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_sec_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # sec直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "secant function", 
       subtitle = parse(text = sec_label), 
       x = expression(theta), 
       y = expression(sec~theta))
sec_graph
```

　「sec関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, sec_graph)
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、単位円における点の値とsec曲線上の点のy軸の値と、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。cos関数の作図については「cos関数の可視化」を参照してください。\
\


#### 1周期

　円周上を1周した際のsec関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\
\


##### パターン1

　1つ目の方法では、sec関数のみを可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 2.5

# sec関数を計算
sec_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  sec_t = 1/cos(t)
) |> 
  dplyr::mutate(
    sec_t = dplyr::if_else(
      condition = (sec_t >= -y_size & sec_t <= y_size), 
      true = sec_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    sec_t = 1/cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  sin_flg <- sin(theta) >= 0
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "sec", "sec", "sec", 
      "sin", 
      "cos", 
      "tan", "tan"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = sin_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, ifelse(test = sin_flg, yes = NA, no = 1), 0, 
      cos(theta), 
      cos(theta), 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_to = c(
      ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 1/cos(theta), 
      sin(theta), 
      0, 
      tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
    ), 
    type = c(
      "main", ifelse(test = sin_flg, yes = NA, no = "sub"), "sub", 
      "main", 
      "main", 
      "main", "sub"
    ) # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sec", "sin", "cos", "tan") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5, 
      cos(theta), 
      0.5 * cos(theta), 
      1
    ), 
    y = c(
      0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 
      0.5 * sin(theta), 
      0, 
      0.5 * tan(theta)
    ), 
    angle = c(0, 90, 0, 90), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, 1, 1), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1, 0), 
    y = c(ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 1/cos(theta))
  )
  
  # sec直線の角度を設定
  if(cos(theta) >= 0) {
    tmp_theta <- acos(cos(theta))
  } else {
    tmp_theta <- pi + acos(cos(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/cos(theta)) * cos(rad), 
    y = abs(1/cos(theta)) * sin(rad)
  )
  
  # sec曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = 1/cos(theta), 
    x_to = x_size+l
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    #", sec~theta==", round(1/cos(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # sec関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, linetype = type), 
                 size = 1, na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # sec曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## sec関数曲線の作図処理
  
  # sec直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_sec_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/cos(theta), 1/cos(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-y_size*d, 1/cos(theta))
  )
  
  # 関数ラベル用の文字列を作成
  sec_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ")"
  )
  
  # sec関数曲線を作図
  sec_graph <- ggplot() + 
    geom_line(data = sec_df, 
              mapping = aes(x = t, y = sec_t), 
              size = 1, na.rm = TRUE) + # sec曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sec_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sec_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "secant function", 
         subtitle = parse(text = sec_label), 
         x = expression(theta), 
         y = expression(sec~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, sec_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　sec関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sec_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sec_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\

　$\cos \theta = 0$ となる $\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ とき、sec関数の線分の方向($\sec \theta$ の符号)が変わり、sec関数の曲線が不連続になるのが分かります。\
\


##### パターン2

　2つ目の方法では、sec関数とcos関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 2.5

# cos・sec関数を計算
curve_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  cos_t = cos(t), 
  sec_t = 1/cos(t)
) |> 
  dplyr::mutate(
    sec_t = dplyr::if_else(
      condition = (sec_t >= -y_size & sec_t <= y_size), 
      true = sec_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 軸変換図のグリッド線の描画用
adapt_grid_df <- tidyr::expand_grid(
  d = 1 - seq(from = -1, to = 1, by = 0.5), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = 1 + d * cos(rad), 
    y = 1 + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    sec_t = 1/cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  sin_flg <- sin(theta) >= 0
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "sec", "sec", "sec", 
      "sin", 
      "cos", 
      "tan", "tan"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = sin_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, ifelse(test = sin_flg, yes = NA, no = 1), 0, 
      cos(theta), 
      cos(theta), 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_to = c(
      ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 1/cos(theta), 
      sin(theta), 
      0, 
      tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
    ), 
    type = c(
      "main", ifelse(test = sin_flg, yes = NA, no = "sub"), "sub", 
      "main", 
      "main", 
      "main", "sub"
    ) # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sec", "sin", "cos", "tan") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5, 
      cos(theta), 
      0.5 * cos(theta), 
      1
    ), 
    y = c(
      0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 
      0.5 * sin(theta), 
      0, 
      0.5 * tan(theta)
    ), 
    angle = c(0, 90, 0, 90), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, 1, 1), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1, 0), 
    y = c(ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 1/cos(theta))
  )
  
  # sec直線の角度を設定
  if(cos(theta) >= 0) {
    tmp_theta <- acos(cos(theta))
  } else {
    tmp_theta <- pi + acos(cos(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/cos(theta)) * cos(rad), 
    y = abs(1/cos(theta)) * sin(rad)
  )
  
  # sec・cos曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = c(0, cos(theta)), 
    y = c(1/cos(theta), sin(theta)), 
    x_to = c(x_size+l, cos(theta)), 
    y_to = c(1/cos(theta), -y_size-l)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    #", sec~theta==", round(1/cos(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    #", cos~theta==", round(cos(theta), digits = 2), 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # sec関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, linetype = type), 
                 size = 1, na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec・cos曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## sec関数曲線の作図処理
  
  # sec直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_sec_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/cos(theta), -y_size*d), 
    x_to = c(-l, theta), 
    y_to = c(1/cos(theta), -y_size*d-l)
  )
  
  # 関数ラベル用の文字列を作成
  sec_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ")"
  )
  
  # sec関数曲線を作図
  sec_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sec_t), 
              size = 1, na.rm = TRUE) + # sec曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sec_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sec_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "secant function", 
         subtitle = parse(text = sec_label), 
         x = expression(theta), 
         y = expression(sec~theta))
  
  ## 軸の変換図の作図処理
  
  # cos関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
    x = 1 + (1-cos(theta)) * cos(rad), 
    y = 1 + (1-cos(theta)) * sin(rad)
  )
  
  # cos曲線・直線との対応線の座標を格納
  l <- 1.2
  segment_adapt_df <- tibble::tibble(
    x = c(cos(theta), 1), 
    y = c(1, cos(theta)), 
    x_to = c(cos(theta), x_size+l), 
    y_to = c(y_size+l, cos(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cos直線・曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cos曲線の作図処理
  
  # cos直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(cos(theta), y_size*d), 
    x_to = c(-l, theta), 
    y_to = c(cos(theta), y_size*d+l)
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    circle_graph, sec_graph, 
    adapt_graph, cos_graph, 
    nrow = 2, ncol = 2
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　先ほどと同様に処理します。\

</details>

　sec関数とcos関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sec_cos_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sec_cos_1cycle.gif)

　$\cos \theta = 0$ のときcot関数の曲線が不連続になるのが分かります。\
\


#### n周期

　円周上を複数回周回した際のsec関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、sec関数のみを可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 2.5

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    sec_t = 1/cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  sin_flg <- sin(theta) >= 0
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "sec", "sec", "sec", 
      "sin", 
      "cos", 
      "tan", "tan"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = sin_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, ifelse(test = sin_flg, yes = NA, no = 1), 0, 
      cos(theta), 
      cos(theta), 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_to = c(
      ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 1/cos(theta), 
      sin(theta), 
      0, 
      tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
    ), 
    type = c(
      "main", ifelse(test = sin_flg, yes = NA, no = "sub"), "sub", 
      "main", 
      "main", 
      "main", "sub"
    ) # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sec", "sin", "cos", "tan") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5, 
      cos(theta), 
      0.5 * cos(theta), 
      1
    ), 
    y = c(
      0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 
      0.5 * sin(theta), 
      0, 
      0.5 * tan(theta)
    ), 
    angle = c(0, 90, 0, 90), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, 1, 1), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1, 0), 
    y = c(ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 1/cos(theta))
  )
  
  # sec直線の角度を設定
  if(cos(theta) >= 0) {
    tmp_theta <- acos(cos(theta))
  } else {
    tmp_theta <- pi + acos(cos(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/cos(theta)) * cos(rad), 
    y = abs(1/cos(theta)) * sin(rad)
  )
  
  # sec曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = 1/cos(theta), 
    x_to = -x_size-l
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # sec関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, linetype = type), 
                 size = 1, na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # sec曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## sec関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # sec関数を計算
  sec_df <- tibble::tibble(
    t = theta_vec, 
    sec_t = 1/cos(t)
  ) |> 
    dplyr::mutate(
      sec_t = dplyr::if_else(
        condition = (sec_t >= -y_size & sec_t <= y_size), 
        true = sec_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  # sec直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_sec_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/cos(theta), 1/cos(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-y_size*d, 1/cos(theta))
  )
  
  # 関数ラベル用の文字列を作成
  sec_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ")"
  )
  
  # sec関数曲線を作図
  sec_graph <- ggplot() + 
    geom_line(data = sec_df, 
              mapping = aes(x = t, y = sec_t), 
              size = 1, na.rm = TRUE) + # sec曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sec_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sec_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "secant function", 
         subtitle = parse(text = sec_label), 
         x = expression(theta), 
         y = expression(sec~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(sec_graph, circle_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　sec関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sec_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sec_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が1周する $2 \pi$ の間隔で、曲線が同じ形になるのが分かります。\
\


##### パターン2

　2つ目の方法では、sec関数とcos関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("sec", "sin", "cos", "tan")

# グラフサイズ用の値を設定
x_size <- 1.3
y_size <- 2.5

# 軸変換図のグリッド線の描画用
adapt_grid_df <- tidyr::expand_grid(
  d = 1 - seq(from = -1, to = 1, by = 0.5), # グリッド線の位置を指定
  rad = seq(from = 0, to = 0.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = -1 + d * cos(rad), 
    y = -1 + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    sec_t = 1/cos(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_to = c(1, cos(theta)), 
    y_to = c(0, sin(theta))
  )
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  sin_flg <- sin(theta) >= 0
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "sec", "sec", "sec", 
      "sin", 
      "cos", 
      "tan", "tan"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_from = c(
      0, ifelse(test = sin_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = sin_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, ifelse(test = sin_flg, yes = NA, no = 1), 0, 
      cos(theta), 
      cos(theta), 
      1, ifelse(test = sin_flg, yes = NA, no = 1)
    ), 
    y_to = c(
      ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flg, yes = NA, no = tan(theta)), 1/cos(theta), 
      sin(theta), 
      0, 
      tan(theta), ifelse(test = sin_flg, yes = NA, no = -tan(theta))
    ), 
    type = c(
      "main", ifelse(test = sin_flg, yes = NA, no = "sub"), "sub", 
      "main", 
      "main", 
      "main", "sub"
    ) # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("sec", "sin", "cos", "tan") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5, 
      cos(theta), 
      0.5 * cos(theta), 
      1
    ), 
    y = c(
      0.5 * ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 
      0.5 * sin(theta), 
      0, 
      0.5 * tan(theta)
    ), 
    angle = c(0, 90, 0, 90), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, 1, 1), 
    fnc_label = c("sec~theta", "sin~theta", "cos~theta", "tan~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1, 0), 
    y = c(ifelse(test = sin_flg, yes = tan(theta), no = -tan(theta)), 1/cos(theta))
  )
  
  # sec直線の角度を設定
  if(cos(theta) >= 0) {
    tmp_theta <- acos(cos(theta))
  } else {
    tmp_theta <- pi + acos(cos(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/cos(theta)) * cos(rad), 
    y = abs(1/cos(theta)) * sin(rad)
  )
  
  # sec・cos曲線との対応線の座標を格納
  lx <- 0.5
  ly <- 1.2
  segment_circle_df <- tibble::tibble(
    x = c(0, cos(theta)), 
    y = c(1/cos(theta), sin(theta)), 
    x_to = c(-x_size-lx, cos(theta)), 
    y_to = c(1/cos(theta), y_size+ly)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_vline(xintercept = 1, linetype = "dashed") + # sec直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # sec関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
                 size = 1) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, linetype = type), 
                 size = 1, na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec・cos曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 変数の作成処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # cos・sec関数を計算
  curve_df <- tibble::tibble(
    t = theta_vec, 
    cos_t = cos(t), 
    sec_t = 1/cos(t)
  ) |> 
    dplyr::mutate(
      sec_t = dplyr::if_else(
        condition = (sec_t >= -y_size & sec_t <= y_size), 
        true = sec_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  ## sec関数曲線の作図処理
  
  # sec直線との対応線の座標を格納
  l <- 0.5
  d <- 1.1
  segment_sec_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/cos(theta), y_size*d), 
    x_to = c(theta+l, theta), 
    y_to = c(1/cos(theta), y_size*d+l)
  )
  
  # 関数ラベル用の文字列を作成
  sec_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sec~theta==", round(1/cos(theta), digits = 2), 
    ")"
  )
  
  # sec関数曲線を作図
  sec_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sec_t), 
              size = 1, na.rm = TRUE) + # sec曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sec_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sec_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # sec直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "secant function", 
         subtitle = parse(text = sec_label), 
         x = expression(theta), 
         y = expression(sec~theta))
  
  ## 軸の変換図の作図処理
  
  # cos関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = -1 + (1+cos(theta)) * cos(rad), 
    y = -1 + (1+cos(theta)) * sin(rad)
  )
  
  # cos曲線・直線との対応線の座標を格納
  l <- 0.5
  segment_adapt_df <- tibble::tibble(
    x = c(cos(theta), -1), 
    y = c(-1, cos(theta)), 
    x_to = c(cos(theta), -x_size-l), 
    y_to = c(-y_size-l, cos(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cos関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cos直線・曲線との対応線
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cos曲線の作図処理
  
  # cos直線との対応線の座標を格納
  l <- 1
  d <- 1.1
  segment_cos_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(cos(theta), -y_size*d), 
    x_to = c(theta+l, theta), 
    y_to = c(cos(theta), -y_size*d-l)
  )
  
  # 関数ラベル用の文字列を作成
  cos_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ")"
  )
  
  # cos関数曲線を作図
  cos_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cos_t), 
              size = 1) + # cos曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cos_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cos_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "cosine function", 
         subtitle = parse(text = cos_label), 
         x = expression(theta), 
         y = expression(cos~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    cos_graph, adapt_graph, 
    sec_graph, circle_graph, 
    nrow = 2, ncol = 2
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から上下左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　sec関数とcos関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/sec_cos_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/sec_cos_ncycle.gif)

\ 

　この記事では、sec関数を可視化しました。次の記事では、csc関数を可視化します。\
\


# csc関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるcsc関数(余割関数・コセカント関数・cosecant function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
### 資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## 定義式の確認

　まずは、csc関数の定義式を確認します。\
\

　csc関数は、sin関数の逆数で定義されます。

$$
\csc x
    = \frac{1}{\sin x}
$$

　$\sin x$ はサイン関数です。sin関数については「sin関数の可視化」を参照してください。\
　ただし、$n$ を整数として $x = n \pi$ のとき、$\sin x = 0$ なので、0除算になるため定義できません。$\pi$ は円周率で、変数 $x$ は弧度法の角度(ラジアン)です。\
\


## csc関数の作図

　次に、csc関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　csc関数の曲線を描画するためのデータフレームを作成します。

```{r}
# 閾値を指定
threshold <- 4

# csc関数を計算
csc_df <- tibble::tibble(
  t = theta_vec, 
  sin_t = sin(theta_vec), 
  csc_t = 1/sin(theta_vec)
) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(
      condition = (csc_t >= -threshold & csc_t <= threshold), 
      true = csc_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
csc_df
```

　$\theta$ の値と $\sin \theta, \csc \theta$ の値をデータフレームに格納します。cot関数は`sin()`を使って計算できます。sin関数の値は比較に使います。\
　$\theta = i \pi$ ($i$ は整数)付近で $-\infty$ または $\infty$ に近付くので、閾値`threshold`を指定しておき、`-threshold`未満または`threshold`より大きい場合は(数値型の)欠損値`NA`に置き換えます。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

　漸近線を描画するためのベクトルを作成します。

```{r}
# 漸近線用の値を作成
asymptote_vec <- seq(
  from = floor(min(theta_vec) / pi) + 1, 
  to = floor(max(theta_vec) / pi), 
  by = 1
) * pi
asymptote_vec; asymptote_vec*2/pi
```

　$\theta = i \pi$ ($\pi$ の倍数)のとき $\cot \theta$ が発散するので、`theta_vec`の範囲内の $i \pi$ の値を(上手いことして)作成します。\

</details>

　csc関数のグラフを作成します。

```{r, fig.width=10, fig.height=6, dpi=100}
# csc関数を作図
ggplot() + 
  geom_line(data = csc_df, 
            mapping = aes(x = t, y = csc_t, linetype = "csc"), 
            size = 1, na.rm = TRUE) + # csc曲線
  geom_line(data = csc_df, 
            mapping = aes(x = t, y = sin_t, linetype = "sin"), 
            size = 1) + # sin曲線
  geom_vline(xintercept = asymptote_vec, linetype = "dashed") + # 漸近線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("csc", "sin"), 
                        values = c("solid", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "cosecant function", 
       x = expression(theta), 
       y = expression(csc~theta))
```

　x軸を $\theta$、y軸を $\csc \theta$ として、`geom_line()`でcsc関数の曲線を描画します。また、$\sin \theta$ の曲線を点線で描画します。\
　x軸が $i \pi$ の点($0$ の前後 $\pi$ 間隔)に、`geom_vline()`で漸近線を破線で描画します。\
　$\sin \theta = 0$ となる $\theta$ が漸近線なのが分かります。\
\


## 単位円の作図

　続いて、csc関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のcsc関数の可視化

　次は、単位円上における三角関数(csc・sin・cos・cot)のグラフを作成します。\
\


### グラフの作成

　変数を固定したcsc関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。ただし、`theta`が`0`のとき計算結果に`Inf`が含まれるため意図しないグラフになります。発散時の対策については「アニメーションの作成」を参照してください。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

</details>

　ここまでは、共通の処理です。ここからは、3つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、x軸線から伸びる直線としてシンプルにcsc関数を可視化します。ただし、csc関数の絶対値と線分の長さが対応しますが、csc関数の正負と座標が対応しません。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_from = c(0, 0, 1/tan(theta)), 
  y_from = c(0, 0, 0), 
  x_to = c(1, cos(theta), 1/tan(theta)), 
  y_to = c(0, sin(theta), 1), 
  width = c("normal", "normal", "thin") # 太さ用
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2つの線分の座標を格納します。\
　また、関数直線の補助線として、長さが半径と同じ線分の座標を(次のデータフレームの座標を睨めっこして)格納します。\
　なす角用の線分と補助線を、線の太さで描き分けることにします。`type`列として、それぞれの線を区別するための文字列を指定します。文字列の内容は自由です。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("csc", "sin", "cos", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 
    cos(theta), 
    0, 
    0
  ), 
  y_from = c(
    0, 
    0, 
    0, 
    0
  ), 
  x_to = c(
    1/tan(theta), 
    cos(theta), 
    cos(theta), 
    1/tan(theta)
  ), 
  y_to = c(
    1, 
    sin(theta), 
    0, 
    0
  ), 
  width = c("normal", "normal", "bold", "thin") # 太さ用
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\
　線が重なる対策として、下の(先に描画される)線分を太く、上の(後に描画される)線分を細く描画することにします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("csc", "sin", "cos", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / tan(theta), 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 / tan(theta)
  ), 
  y = c(
    0.5, 
    0.5 * sin(theta), 
    0, 
    0
  ), 
  angle = c(0, 90, 0, 0), 
  h = c(1.1, 0.5, 0.5, 0.5), 
  v = c(0.5, -0.5, -0.5, 1), 
  fnc_label = c(
    ifelse(test = cos(theta) >= 0, yes = "csc~theta", no = "-csc~theta"), 
    "sin~theta", 
    "cos~theta", 
    "cot~theta"
  ) # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ただし、$\frac{\pi}{2} \lt \theta \lt \frac{3 \pi}{2}$ の範囲でcsc直線が直感的でない座標になるので、$\cos \theta \lt 0$ のときマイナスの符号を付けて表示することにします。\
　ラベルの表示角度を`angle`列、表示角度に応じた左右の表示位置を`h`列、上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", csc~theta==", round(1/sin(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
y_size <- 1.3
x_min <- min(-y_size, 1/tan(theta))
x_max <- max(y_size, 1/tan(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, size = width)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　csc関数の定義式 $\csc \theta = \frac{1}{\sin \theta}$ やこの図から、$\sin \theta : 1 = 1 : \csc \theta$ なのが分かります。csc関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」と「$y = 1$ の直線(破線)」の交点 $(\frac{1}{\tan \theta}, 1)$ と原点を結ぶ線分の長さです。ただし、$\pi \lt \theta \lt 2 \pi$ の範囲では符号が反転します。\
\


#### パターン2

　2つ目の方法では、x軸線から伸びる直線としてcsc関数の正負とxっ軸の正負が対応するように可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 変換フラグを設定
cos_flg <- cos(theta) >= 0

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_from = c(
    0, 0, 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_from = c(
    0, 0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    1, cos(theta), 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_to = c(
    0, sin(theta), 
    1, ifelse(test = cos_flg, yes = NA, no = 1)
  ), 
  width = c("normal", "normal", "thin", "thin") # 太さ用
)
radius_df
```

　「パターン1」の座標に加えて、符号を反転させた際の線分に対応する補助線の座標も格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "csc", "csc", 
    "sin", 
    "cos", 
    "cot", "cot"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 
    cos(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  y_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 
    0, 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 
    cos(theta), 
    cos(theta), 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_to = c(
    1, ifelse(test = cos_flg, yes = NA, no = 1), 
    sin(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  type = c(
    "main", "sub", 
    "main", 
    "main", 
    "main", "sub"
  ), # 線タイプ用
  width = c(
    "normal", "normal", 
    "normal", 
    "bold", 
    "thin", "thin"
  ) # 太さ用
)
function_line_df
```

　「パターン1」の座標に加えて、$\frac{\pi}{2} \lt \theta \lt \frac{3 \pi}{2}$ の範囲でも直感的な座標になるように、符号を反転させた線分の座標を格納します。\
　元の関数(線分)と符号を反転させた関数(線分)を、線の種類で描き分けることにします。`type`列として、それぞれの線を区別するための文字列を指定します。文字列の内容は自由です。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("csc", "csc", "sin", "cos", "cot", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), ifelse(test = cos_flg, yes = NA, no = 0.5/tan(theta)), 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 / tan(theta), ifelse(test = cos_flg, yes = NA, no = -0.5/tan(theta))
  ), 
  y = c(
    0.5, ifelse(test = cos_flg, yes = NA, no = 0.5), 
    0.5 * sin(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  angle = c(0, 0, 90, 0, 0, 0), 
  h = c(1.1, -0.1, 0.5, 0.5, 0.5, 0.5), 
  v = c(0.5, 0.5, -0.5, -0.5, 1, 1), 
  fnc_label = c("csc~theta", "-csc~theta", "sin~theta", "cos~theta", "cot~theta", "-cot~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
y_size <- 1.3
x_size <- max(y_size, abs(1/tan(theta)))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = width), 
               na.rm = TRUE) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), 
               na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　$\frac{\pi}{2} \lt \theta \lt \frac{3 \pi}{2}$ のとき $\cos \theta \lt 0$ であり、$\cot \theta = \frac{\cos \theta}{\sin \theta}$ なので、原点と $(- \cot \theta, 1)$ を結ぶ線分の長さです。csc関数の符号はx軸の値の符号と対応します。\
\


#### パターン3

　3つ目の方法では、円周上の点から伸びる直線としてcsc関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta)), 
  y_to = c(0, sin(theta))
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2点の座標を格納します。原点の座標は、作図時に値を引数に指定します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("csc", "sin", "sin", "cos", "cos", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 
    0, 0, 
    0, 0, 
    cos(theta)
  ), 
  y_from = c(
    0, 
    0, 0, 
    sin(theta), ifelse(sin(theta) >= 0, yes = 1, no = -1), 
    sin(theta)
  ), 
  x_to = c(
    0, 
    0, abs(sin(theta))*cos(theta), 
    cos(theta), abs(sin(theta))*cos(theta), 
    0
  ), 
  y_to = c(
    1/sin(theta), 
    sin(theta), abs(sin(theta))*sin(theta), 
    sin(theta), abs(sin(theta))*sin(theta), 
    1/sin(theta)
  ), 
  width = c("bold", "thin", "normal", "normal", "normal", "normal") # 太さ用
)
function_line_df
```

　先ほどの様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("csc", "sin", "cos", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0, 
    0, 
    0.5 * cos(theta), 
    0.5 * cos(theta)
  ), 
  y = c(
    0.5 / sin(theta), 
    0.5 * sin(theta), 
    sin(theta), 
    0.5 * (1/sin(theta) + sin(theta))
  ), 
  angle = c(90, 90, 0, 0), 
  h = c(0.5, 0.5, 0.5, -0.2), 
  v = c(1, -0.5, 1, 0.5), 
  fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
x_size <- 1.3
y_min <- min(-x_size, 1/sin(theta))
y_max <- max(x_size, 1/sin(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 0, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　こちらの図は、原点と点 $(\cos \theta, \sin \theta)$ を結ぶ線分を底辺、y軸線の一部を斜辺としたときのパターン1の図と言えます。文字通り首を捻って見てください。\
　csc関数の値は、「原点と点 $(\cos \theta, \sin \theta)$ を通る直線」に対する「点 $(\cos \theta, \sin \theta)$ を通る垂線」と「$x = 0$ の直線(破線)」の交点 $(\csc, 0)$ のy軸の値です。\
\


### アニメーションの作成

　続いて、変数の値を変化させたcsc関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 n \pi$ にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", csc θ = ", round(1/cos(theta_i), digits = 2), 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", cot θ = ", round(1/tan(theta_i), digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

</details>

　ここまでは、共通の処理です。ここからは、「グラフの作成」のときと同様に3つの方法で図示します。\
\


#### パターン1

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    1/tan(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    1/tan(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i), 
    rep(1, times = frame_num)
  ), 
  type = c("normal", "normal", "thin") |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 3) |> # (3は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    x_from = dplyr::if_else(condition = is.infinite(x_from), true = NA_real_, false = x_from), 
    x_to   = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to)
  ) # 発散した場合は欠損値に置換
anim_radius_df
```

　「グラフの作成」のときと同様に、フレーム数分の原点と点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標、また補助線用の線分の座標を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("csc", "sin", "cos", "cot") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    1/tan(theta_i), 
    cos(theta_i), 
    cos(theta_i), 
    1/tan(theta_i)
  ), 
  y_to = c(
    rep(1, times = frame_num), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  type = c("normal", "normal", "bold", "thin") |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 4) |> # (4は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to)
  ) # 発散した場合は欠損値に置換
anim_function_line_df
```

　線分ごとに`frame_num`個の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(1.1, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, -0.5, -0.5, 1) |> 
      rep(each = frame_num), 
    fnc_label = c(
      ifelse(test = cos(theta_i) >= 0, yes = "csc~theta", no = "-csc~theta"), 
      rep("sin~theta", times = frame_num), 
      rep("cos~theta", times = frame_num), 
      rep("cot~theta", times = frame_num)
    ) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`から`label_flag`列が`TRUE`の行(線分)を取り出して、`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = type), na.rm = TRUE) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, na.rm = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type), na.rm = TRUE) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 600)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

　$\theta = 0, \pi$ のとき $\sin \theta = 0$ なので、原点と円周上の点を結ぶ線分が水平になり直線 $y = 1$ と平行なため交点ができず、$\csc \theta$ を描画(定義)できないのが分かります。\
\


#### パターン2

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 変換フラグを設定
cos_flg_i <- cos(theta_i) >= 0

# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    1/tan(theta_i), ifelse(test = cos_flg_i, yes = NA, no = -1/tan(theta_i))
  ), 
  y_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0)
  ), 
  x_to = c(
    rep(1, times = frame_num), cos(theta_i), 
    1/tan(theta_i), ifelse(test = cos_flg_i, yes = NA, no = -1/tan(theta_i))
  ), 
  y_to =  c(
    rep(0, times = frame_num), sin(theta_i), 
    rep(1, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 1)
  ), 
  width = c("normal", "normal", "thin", "thin") |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 4) |> # (4は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    x_from = dplyr::if_else(condition = is.infinite(x_from), true = NA_real_, false = x_from), 
    x_to   = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to)
  ) # 発散した場合は欠損値に置換
anim_radius_df
```

　「グラフの作成」のときと同様に、フレーム数分の原点と点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標、また補助線用の線分の座標を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c(
    "csc", "csc", 
    "sin", 
    "cos", 
    "cot", "cot"
  ) |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0)
  ), 
  y_from = c(
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0)
  ), 
  x_to = c(
    ifelse(test = cos_flg_i, yes = 1/tan(theta_i), no = -1/tan(theta_i)), ifelse(test = cos_flg_i, yes = NA, no = 1/tan(theta_i)), 
    cos(theta_i), 
    cos(theta_i), 
    1/tan(theta_i), ifelse(test = cos_flg_i, yes = NA, no = -1/tan(theta_i))
  ), 
  y_to = c(
    rep(1, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 1), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), ifelse(test = cos_flg_i, yes = NA, no = 0)
  ), 
  type = c(
    "main", "sub", 
    "main", 
    "main", 
    "main", "sub"
  ) |> 
    rep(each = frame_num), # 線タイプ用
  width = c(
    "normal", "normal", 
    "normal", 
    "bold", 
    "thin", "thin"
  ) |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 6) |> # (6は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    x_to   = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to)
  ) # 発散した場合は欠損値に置換
anim_function_line_df
```

　線分ごとに`frame_num`個の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(type == "main") |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(1.1, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, -0.5, -0.5, 1) |> 
      rep(each = frame_num), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 1.3

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = width), na.rm = TRUE) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), 
               na.rm = TRUE) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 600)
```

\ 


#### パターン3

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 2) |> # (2は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　フレーム数分の点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("csc", "sin", "sin", "cos", "cos", "cot") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    cos(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    sin(theta_i), ifelse(sin(theta_i) >= 0, yes = 1, no = -1), 
    sin(theta_i)
  ), 
  x_to = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), abs(sin(theta_i))*cos(theta_i), 
    cos(theta_i), abs(sin(theta_i))*cos(theta_i), 
    rep(0, times = frame_num)
  ), 
  y_to = c(
    1/sin(theta_i), 
    sin(theta_i), abs(sin(theta_i))*sin(theta_i), 
    sin(theta_i), abs(sin(theta_i))*sin(theta_i), 
    1/sin(theta_i)
  ), 
  type = c("bold", "thin", "normal", "normal", "normal", "normal") |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE) |> 
    rep(each = frame_num), # # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 6) |> # (6は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　先ほどと同様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 90, 0, 0) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, 0.5, -0.2) |> 
      rep(each = frame_num), 
    v = c(1, -0.5, 1, 0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　ラベルを表示する線分の中点の座標を計算して、ラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 1.3
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 0, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to), 
               size = 1) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 600, height = 800)
```

　こちらの図だと、原点と円周上の点を結ぶ線分が水平になり、その垂線が直線 $x = 0$ と平行なため交点ができず、$\csc \theta$ を描画(定義)できないのが分かります。\
\


## 単位円上の点とcsc関数曲線の関係の可視化

　最後は、単位円上におけるcsc関数の値(直線)と、csc関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したcsc関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta), 
  csc_t = 1/sin(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。ただし、`theta`が`0`のとき計算結果に`Inf`が含まれるため意図しないグラフになります。発散時の対策については「アニメーションの作成」を参照してください。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のcsc関数の可視化」のコードで3つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)

# 変換フラグを設定
cos_flg <- cos(theta) >= 0

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_from = c(
    0, 0, 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_from = c(
    0, 0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    1, cos(theta), 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_to = c(
    0, sin(theta), 
    1, ifelse(test = cos_flg, yes = NA, no = 1)
  ), 
  width = c("normal", "normal", "thin", "thin") # 太さ用
)
```

</details>

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcsc関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# 変換フラグを設定
cos_flg <- cos(theta) >= 0

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "csc", "csc", "csc", 
    "sin", 
    "cos", 
    "cot", "cot"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
    cos(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  y_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
    0, 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 0, 
    cos(theta), 
    cos(theta), 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_to = c(
    1, ifelse(test = cos_flg, yes = NA, no = 1), 1/sin(theta), 
    sin(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  type = c(
    "main", "sub", "sub", 
    "main", 
    "main", 
    "main", "sub"
  ), # 線タイプ用
  width = c(
    "normal", "normal", "normal", 
    "normal", 
    "bold", 
    "thin", "thin"
  ) # 太さ用
)
function_line_df
```

　「単位円上のcsc関数の可視化」のときのコードに、csc直線の1つを垂直線に回転した線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("csc", "sin", "cos", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), 
    cos(theta), 
    0.5 * cos(theta), 
    0.5 / tan(theta)
  ), 
  y = c(
    0.5, 
    0.5 * sin(theta), 
    0, 
    0
  ), 
  angle = c(0, 90, 0, 0), 
  h = c(1.1, 0.5, 0.5, 0.5), 
  v = c(0.5, -0.5, -0.5, 1), 
  fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
)
function_label_df
```

　(図がゴチャゴチャするので)符号を反転させたラベルは描画しないことにします。\

　軸の変換前後の点を描画するためのデータフレームを作成します。

```{r}
# 変換曲線の先端の座標を格納
adapt_point_df <- tibble::tibble(
  x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 0), 
  y = c(1, 1/sin(theta))
)
adapt_point_df
```

　原点から伸びるcsc直線の座標について、直線 $y = 1$ 上の点 $(\pm \frac{1}{\tan \theta}, 1)$ と直線 $x = 0$ 上の点 $(0, \csc \theta)$ を格納します。\

　垂直線になるように直線を回転する軌道を描画するためのデータフレームを作成します。

```{r}
# csc直線の角度を設定
if(sin(theta) >= 0) {
  tmp_theta <- asin(sin(theta))
} else {
  tmp_theta <- pi + asin(sin(theta))
}

# 軸変換曲線の描画用
adapt_line_df <- tibble::tibble(
  rad = seq(
    from = tmp_theta, 
    to = ifelse(test = sin(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
    length.out = 100
  ), 
  x = abs(1/sin(theta)) * cos(rad), 
  y = abs(1/sin(theta)) * sin(rad)
)
adapt_line_df
```

　軸を変換する軌道として、半径が $|\csc \theta|$ の弧を描画します。全体値 $|x|$ は`abs()`で計算できます。\

　任意の範囲で設定したラジアン $\theta$ を $0 \leq \alpha \leq \pi$ の範囲のラジアンに変換します。コサイン関数 $\cos x$ の逆関数(逆コサイン関数) $\arccos x$ を使って、 $\alpha = \arccos(\cos \theta)$ で計算します。逆コサイン関数は`acos()`で計算できます。\

　$\csc \theta \geq 0$ のとき($\sin \theta \geq 0$ のとき)第1象限からy軸の正の部分への変化を示すため $\alpha \leq t \leq \frac{\pi}{2}$ のラジアン、$\csc \theta \lt 0$ のとき($\sin \theta \lt 0$ のとき)第2象限からy軸の負の部分への変化を示すため $\alpha \leq t \leq \frac{3 \pi}{2}$ のラジアンを用いて、弧のx軸の値 $x = |\csc \theta| \cos t$ とy軸の値 $y = |\csc \theta| \sin t$ を計算します。\

　単位円における点とcsc曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
size_min  <- 2
size_max  <- 5
x_size <- ceiling(abs(1/tan(theta))) |> 
  max(size_min) |> 
  min(size_max)
y_size <- ceiling(abs(1/sin(theta))) |> 
  max(size_min) |> 
  min(size_max)

# csc曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = 0, 
  y = 1/sin(theta), 
  x_to = x_size+l, 
  y_to = 1/sin(theta)
)
segment_circle_df
```

　単位円における点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", csc~theta==", round(1/sin(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(data = adapt_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # csc関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, size = width)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), 
               na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 変換曲線
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # csc曲線との対応線
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcsc関数の可視化」のときと同様に、作図します。\
\

　csc関数の曲線を描画するためのデータフレームを作成します。

```{r}
# csc関数を計算
csc_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  csc_t = 1/sin(t)
) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(
      condition = (csc_t >= -y_size & csc_t <= y_size), 
      true = csc_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
csc_df
```

　「csc関数の作図」のときと同様にして、曲線の座標を計算します。\

　csc曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# csc直線との対応線の座標を格納
l <- 0.7
d <- 1.1
segment_csc_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(1/sin(theta), 1/sin(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-y_size*d, 1/sin(theta))
)
segment_csc_df
```

　曲線上の点からx軸とy軸へ垂線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「csc関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　csc関数曲線のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 関数ラベル用の文字列を作成
csc_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", csc~theta==", round(1/sin(theta), digits = 2), 
  ")"
)

# csc関数曲線を作図
csc_graph <- ggplot() + 
  geom_line(data = csc_df, 
            mapping = aes(x = t, y = csc_t), 
            size = 1, na.rm = TRUE) + # csc曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = csc_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_csc_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # csc直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-x_size, x_size)) + # 描画領域
  labs(title = "cosecant function", 
       subtitle = parse(text = csc_label), 
       x = expression(theta), 
       y = expression(csc~theta))
csc_graph
```

　「csc関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, csc_graph)
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、単位円における点の値とcsc曲線上の点のy軸の値、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


#### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcsc関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# 変換フラグを設定
cos_flg <- cos(theta) >= 0

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "csc", "csc", "csc", 
    "sin", 
    "cos", 
    "cot", "cot"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
    cos(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  y_from = c(
    0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
    0, 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  x_to = c(
    ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 1/sin(theta), 
    cos(theta), 
    cos(theta), 
    1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
  ), 
  y_to = c(
    1, ifelse(test = cos_flg, yes = NA, no = 1), 0, 
    sin(theta), 
    0, 
    0, ifelse(test = cos_flg, yes = NA, no = 0)
  ), 
  type = c(
    "main", "sub", "sub", 
    "main", 
    "main", 
    "main", "sub"
  ), # 線タイプ用
  width = c(
    "normal", "normal", "bold", 
    "normal", 
    "normal", 
    "thin", "thin"
  ) # 太さ用
)
function_line_df
```

　「単位円上のcsc関数の可視化」のときのコードに、csc直線の1つを垂直線に回転した線分の座標を格納します。\

　「パターン1」のときのコードで、関数名をラベルとして描画するためのデータフレームを作成します。\

　軸の変換前後の点を描画するためのデータフレームを作成します。

```{r}
# 変換曲線の先端の座標を格納
adapt_point_df <- tibble::tibble(
  x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 1/sin(theta)), 
  y = c(1, 0)
)
adapt_point_df
```

　原点から伸びるcsc直線の座標について、直線 $y = 1$ 上の点 $(\pm \frac{1}{\tan \theta}, 1)$ と直線 $x = 0$ 上の点 $(0, \csc \theta)$ を格納します。\

　水平線になるように直線を回転する軌道を描画するためのデータフレームを作成します。

```{r}
# csc直線の角度を設定
if(sin(theta) >= 0) {
  tmp_theta <- asin(sin(theta))
} else {
  tmp_theta <- pi + asin(sin(theta))
}

# 軸変換曲線の描画用
adapt_line_df <- tibble::tibble(
  rad = seq(
    from = tmp_theta, 
    to = ifelse(test = sin(theta) >= 0, yes = 0, no = pi), 
    length.out = 100
  ), 
  x = abs(1/sin(theta)) * cos(rad), 
  y = abs(1/sin(theta)) * sin(rad)
)
adapt_line_df
```

　$\csc \theta \geq 0$ のとき($\sin \theta \geq 0$ のとき)第1象限からx軸の正の部分への変化を示すため $0 \leq t \leq \alpha$ のラジアン、$\csc \theta \lt 0$ のとき($\sin \theta \lt 0$ のとき)第2象限からx軸の負の部分への変化を示すため $\alpha \leq t \leq \pi$ のラジアンを用いて、弧のx軸の値 $x = |\sec \theta| \cos t$ とy軸の値 $y = |\sec \theta| \sin t$ を計算します。\

　単位円における点と軸の変換図上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
x_min  <- 2
x_max  <- 5
x_size <- ceiling(abs(1/sin(theta))) |> 
  max(x_min) |> 
  min(x_max)
y_size <- 1.5

# 軸変換曲線との対応線の座標を格納
l <- 0.8
segment_circle_df <- tibble::tibble(
  x = 1/sin(theta), 
  y = 0, 
  x_to = 1/sin(theta), 
  y_to = -y_size-l
)
segment_circle_df
```

　単位円における点からx軸へ垂直線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, echo=FALSE, fig.width=6, fig.height=6, dpi=100}
### 資料作成用:(再掲)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(data = adapt_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # csc関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, size = width)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), 
               na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 変換曲線
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # csc曲線との対応線
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線用)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcsc関数の可視化」のときと同様に、作図します。\
\

　x軸の値を90度回転する線を描画するためのデータフレームを作成します。

```{r}
# csc関数の軸変換曲線の座標を計算
adapt_line_df <- tibble::tibble(
  rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
  x = x_size + (x_size-1/sin(theta)) * cos(rad), 
  y = x_size + (x_size-1/sin(theta)) * sin(rad)
)
adapt_line_df
```

　グラフのサイズを`axis_size`の2倍としました。`axis_size`を $S$ で表します。軸を変換する軌道として、中心の座標が $(S, S)$ で半径が $r = S - \csc \theta$ の弧を描画します。また、弧の中心が図の右上隅になるようにします。\
　$\pi \leq t \leq \frac{3 \pi}{2}$ を用いて、弧のx軸の値 $x = S + r \cos t$ とy軸の値 $y = S + r \sin t$ を計算します。\
　円の座標計算については「円周の作図」を参照してください。\

　軸の変換図のグリッド線を描画するためのデータフレームを作成します。

```{r}
# 軸変換図のグリッド線の描画用
d <- 0.5
adapt_grid_df <- tidyr::expand_grid(
  ds = seq(from = d, to = 2*x_size, by = d), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = x_size + ds * cos(rad), 
    y = x_size + ds * sin(rad)
  )
adapt_grid_df
```

　軸の変換曲線と同様に、グリッド線として、等間隔の半径の複数の曲線を描画します。\
　半径の間隔`d`を指定して、半径列`ds`、ラジアン列`rad`を作成します。`ds, rad`列の全ての組み合わせを`expand_grid()`で作成することで、半径ごとに曲線用のラジアンを複製します。\
　弧の座標を $x = S + d \cos t$、$y = S + d \sin t$ で計算します。\

　軸の変換図上の点とcsc曲線上の点・単位円上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# csc曲線・直線との対応線の座標を格納
l <- 0.8
segment_adapt_df <- tibble::tibble(
  x = c(1/sin(theta), x_size), 
  y = c(x_size, 1/sin(theta)), 
  x_to = c(1/sin(theta), x_size+l), 
  y_to = c(x_size+l, 1/sin(theta))
)
segment_adapt_df
```

　曲線の両端からx軸とy軸の反対側へ水平線と垂直線を引くように座標を指定します。\

　軸の変換図を作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 軸の変換曲線を作図
adapt_graph <- ggplot() + 
  geom_line(data = adapt_grid_df, 
            mapping = aes(x = x, y = y, group = ds), 
            color = "white") + # グリッド線
  geom_line(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 軸変換曲線
  geom_point(data = segment_adapt_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # csc関数の点
  geom_segment(data = segment_adapt_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # csc直線・曲線との対応線
  #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-x_size, x_size)) + # 描画領域
  labs(x = "x", y = "x")
adapt_graph
```

　軸の変換曲線とグリッド線をそれぞれ`geom_line()`で描画します。\
\

　csc関数曲線のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# csc関数を計算
csc_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  csc_t = 1/sin(t)
) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(
      condition = (csc_t >= -x_size & csc_t <= x_size), 
      true = csc_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# csc直線との対応線の座標を格納
l <- 1.2
d <- 1.1
segment_csc_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(1/sin(theta), 1/sin(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-x_size*d, 1/sin(theta))
)

# csc関数曲線を作図
csc_graph <- ggplot() + 
  geom_line(data = csc_df, 
            mapping = aes(x = t, y = csc_t), 
            size = 1, na.rm = TRUE) + # csc曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = csc_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_csc_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # csc直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-x_size, x_size)) + # 描画領域
  labs(title = "cosecant function", 
       subtitle = parse(text = csc_label), 
       x = expression(theta), 
       y = expression(csc~theta))
csc_graph
```

　y軸方向の描画範囲を`x_size`を用いて設定して、作図します。\
\

</details>

　3つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=11, dpi=100}
# 並べて描画
patchwork::wrap_plots(
  circle_graph, patchwork::plot_spacer(), 
  adapt_graph, csc_graph, 
  nrow = 2, ncol = 2, 
  widths = c(1, pi/x_size), heights = c(1, x_size/y_size)
)
```

　グラフを配置しない位置を`plot_spacer()`で指定します。\

　分かりやすい方の図を参考にしてください。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。sin関数の作図については「sin関数の可視化」を参照してください。\
\


#### 1周期

　円周上を1周した際のcsc関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\
\


##### パターン1

　1つ目の方法では、csc関数のみを可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# グラフサイズ用の値を設定
x_size <- 1.5
y_size <- 2.5

# csc関数を計算
csc_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  csc_t = 1/sin(t)
) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(
      condition = (csc_t >= -y_size & csc_t <= y_size), 
      true = csc_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    csc_t = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(condition = is.infinite(csc_t), true = NA_real_, false = csc_t)
  ) # 発散した場合は欠損値に置換
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  cos_flg <- cos(theta) >= 0
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(
      0, 0, 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_from = c(
      0, 0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      0, sin(theta), 
      1, ifelse(test = cos_flg, yes = NA, no = 1)
    ), 
    width = c("normal", "normal", "thin", "thin") # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "csc", "csc", "csc", 
      "sin", 
      "cos", 
      "cot", "cot"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    y_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 0, 
      cos(theta), 
      cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      1, ifelse(test = cos_flg, yes = NA, no = 1), 1/sin(theta), 
      sin(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    type = c(
      "main", "sub", "sub", 
      "main", 
      "main", 
      "main", "sub"
    ), # 線タイプ用
    width = c(
      "normal", "normal", "normal", 
      "normal", 
      "bold", 
      "thin", "thin"
    ) # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("csc", "sin", "cos", "cot") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 / tan(theta)
    ), 
    y = c(
      0.5, 
      0.5 * sin(theta), 
      0, 
      0
    ), 
    angle = c(0, 90, 0, 0), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, -0.5, 1), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 0), 
    y = c(1, 1/sin(theta))
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # csc直線の角度を設定
  if(sin(theta) >= 0) {
    tmp_theta <- asin(sin(theta))
  } else {
    tmp_theta <- pi + asin(sin(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = sin(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/sin(theta)) * cos(rad), 
    y = abs(1/sin(theta)) * sin(rad)
  )
  
  # csc曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = 1/sin(theta), 
    x_to = x_size+l, 
    y_to = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    y    = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    #", csc~theta==", round(1/sin(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), na.rm = TRUE, 
               size = 4) + # csc関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, size = width), na.rm = TRUE) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## csc関数曲線の作図処理
  
  # csc直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_csc_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/sin(theta), 1/sin(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-y_size*d, 1/sin(theta))
  ) |> 
  dplyr::mutate(
    y    = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベル用の文字列を作成
  csc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ")"
  )
  
  # csc関数曲線を作図
  csc_graph <- ggplot() + 
    geom_line(data = csc_df, 
              mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
              size = 1) + # csc曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_csc_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "cosecant function", 
         subtitle = parse(text = csc_label), 
         x = expression(theta), 
         y = expression(csc~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, csc_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　csc関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/csc_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/csc_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\

　$\sin \theta = 0$ となる $\theta = 0, \pi, 2 \pi$ とき、csc関数の線分の方向($\csc \theta$ の符号)が変わり、csc関数の曲線が不連続になるのが分かります。\
\


##### パターン2

　2つ目の方法では、csc関数とsin関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# グラフサイズ用の値を設定
x_size <- 2.5
y_size <- 1.5

# sin・csc関数を計算
curve_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  sin_t = sin(t), 
  csc_t = 1/sin(t)
) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(
      condition = (csc_t >= -x_size & csc_t <= x_size), 
      true = csc_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 軸変換図のグリッド線の描画用
d <- 0.5
adapt_grid_df <- tidyr::expand_grid(
  ds = seq(from = d, to = 2*x_size, by = d), # グリッド線の位置を指定
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = x_size + ds * cos(rad), 
    y = x_size + ds * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    csc_t = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(condition = is.infinite(csc_t), true = NA_real_, false = csc_t)
  ) # 発散した場合は欠損値に置換
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  cos_flg <- cos(theta) >= 0
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(
      0, 0, 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_from = c(
      0, 0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      0, sin(theta), 
      1, ifelse(test = cos_flg, yes = NA, no = 1)
    ), 
    width = c("normal", "normal", "thin", "thin") # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "csc", "csc", "csc", 
      "sin", 
      "cos", 
      "cot", "cot"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    y_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 1/sin(theta), 
      cos(theta), 
      cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      1, ifelse(test = cos_flg, yes = NA, no = 1), 0, 
      sin(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    type = c(
      "main", "sub", "sub", 
      "main", 
      "main", 
      "main", "sub"
    ), # 線タイプ用
    width = c(
      "normal", "normal", "bold", 
      "normal", 
      "normal", 
      "thin", "thin"
    ) # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("csc", "sin", "cos", "cot") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 / tan(theta)
    ), 
    y = c(
      0.5, 
      0.5 * sin(theta), 
      0, 
      0
    ), 
    angle = c(0, 90, 0, 0), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, -0.5, 1), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 1/sin(theta)), 
    y = c(1, 0)
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # csc直線の角度を設定
  if(sin(theta) >= 0) {
    tmp_theta <- asin(sin(theta))
  } else {
    tmp_theta <- pi + asin(sin(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = sin(theta) >= 0, yes = 0, no = pi), 
      length.out = 100
    ), 
    x = abs(1/sin(theta)) * cos(rad), 
    y = abs(1/sin(theta)) * sin(rad)
  )
  
  # csc・sin曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = c(1/sin(theta), cos(theta)), 
    y = c(0, sin(theta)), 
    x_to = c(1/sin(theta), x_size+l), 
    y_to = c(-y_size-l, sin(theta))
  ) |> 
  dplyr::mutate(
    x    = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to)
  ) # 発散した場合は欠損値に置換
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), na.rm = TRUE, 
               size = 4) + # csc関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, size = width), na.rm = TRUE) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 軸の変換図の作図処理
  
  # csc関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
    x = x_size + (x_size-1/sin(theta)) * cos(rad), 
    y = x_size + (x_size-1/sin(theta)) * sin(rad)
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(condition = x <= x_size, true = x, false = NA_real_), 
      y = dplyr::if_else(condition = y <= x_size, true = y, false = NA_real_)
    ) # 領域外の場合は欠損値に置換
  
  # csc曲線・直線との対応線の座標を格納
  l <- 1.2
  segment_adapt_df <- tibble::tibble(
    x = c(1/sin(theta), x_size), 
    y = c(x_size, 1/sin(theta)), 
    x_to = c(1/sin(theta), x_size+l), 
    y_to = c(x_size+l, 1/sin(theta))
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(condition = x <= x_size, true = x, false = NA_real_), 
      y = dplyr::if_else(condition = y <= x_size, true = y, false = NA_real_)
    ) # 領域外の場合は欠損値に置換
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = ds), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, na.rm = TRUE, 
               mapping = aes(x = x, y = y), 
               size = 4) + # csc関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-x_size, x_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## csc関数曲線の作図処理
  
  # csc直線との対応線の座標を格納
  lx <- 1
  ly <- 0.5
  d <- 1.1
  segment_csc_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/sin(theta), x_size*d), 
    x_to = c(-lx, theta), 
    y_to = c(1/sin(theta), x_size*d+ly)
  ) |> 
    dplyr::mutate(
      y    = dplyr::if_else(condition = y <= x_size, true = y, false = NA_real_), 
      y_to = dplyr::if_else(condition = y_to <= x_size, true = y_to, false = NA_real_)
    ) # 領域外の場合は欠損値に置換
  
  # 関数ラベル用の文字列を作成
  csc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ")"
  )
  
  # csc関数曲線を作図
  csc_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
              size = 1) + # csc曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_csc_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-x_size, x_size)) + # 描画領域
    labs(title = "cosecant function", 
         subtitle = parse(text = csc_label), 
         x = expression(theta), 
         y = expression(csc~theta))
  
  ## sin曲線の作図処理
  
  # sin直線との対応線の座標を格納
  l <- 1.1
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(sin(theta), -y_size*d), 
    x_to = c(-l, theta), 
    y_to = c(sin(theta), -y_size*d-l)
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    circle_graph, sin_graph, 
    adapt_graph, csc_graph, 
    nrow = 2, ncol = 2, 
    widths  = c(1, pi/x_size), 
    heights = c(1, x_size/y_size)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1600, height = 1200, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　先ほどと同様に処理します。\

</details>

　csc関数とsin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/csc_sin_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/csc_sin_1cycle.gif)

　$\sin \theta = 0$ のときcot関数の曲線が不連続になるのが分かります。\
\


#### n周期

　円周上を複数回周回した際のcsc関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、csc関数のみを可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# グラフサイズ用の値を設定
x_size <- 1.5
y_size <- 2.5

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    csc_t = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(condition = is.infinite(csc_t), true = NA_real_, false = csc_t)
  ) # 発散した場合は欠損値に置換
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  cos_flg <- cos(theta) >= 0
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(
      0, 0, 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_from = c(
      0, 0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      0, sin(theta), 
      1, ifelse(test = cos_flg, yes = NA, no = 1)
    ), 
    width = c("normal", "normal", "thin", "thin") # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "csc", "csc", "csc", 
      "sin", 
      "cos", 
      "cot", "cot"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    y_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 0, 
      cos(theta), 
      cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      1, ifelse(test = cos_flg, yes = NA, no = 1), 1/sin(theta), 
      sin(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    type = c(
      "main", "sub", "sub", 
      "main", 
      "main", 
      "main", "sub"
    ), # 線タイプ用
    width = c(
      "normal", "normal", "normal", 
      "normal", 
      "bold", 
      "thin", "thin"
    ) # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("csc", "sin", "cos", "cot") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 / tan(theta)
    ), 
    y = c(
      0.5, 
      0.5 * sin(theta), 
      0, 
      0
    ), 
    angle = c(0, 90, 0, 0), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, -0.5, 1), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 0), 
    y = c(1, 1/sin(theta))
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # csc直線の角度を設定
  if(sin(theta) >= 0) {
    tmp_theta <- asin(sin(theta))
  } else {
    tmp_theta <- pi + asin(sin(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = sin(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), 
      length.out = 100
    ), 
    x = abs(1/sin(theta)) * cos(rad), 
    y = abs(1/sin(theta)) * sin(rad)
  )
  
  # csc曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    y = 1/sin(theta), 
    x_to = -x_size-l, 
    y_to = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    y    = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    #", csc~theta==", round(1/sin(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), na.rm = TRUE, 
               size = 4) + # csc関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = width), na.rm = TRUE) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## csc関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # csc関数を計算
  csc_df <- tibble::tibble(
    t = theta_vec, 
    csc_t = 1/sin(t)
  ) |> 
    dplyr::mutate(
      csc_t = dplyr::if_else(
        condition = (csc_t >= -y_size & csc_t <= y_size), 
        true = csc_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  # csc直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_csc_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/sin(theta), 1/sin(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-y_size*d, 1/sin(theta))
  ) |> 
  dplyr::mutate(
    y    = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベル用の文字列を作成
  csc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ")"
  )
  
  # csc関数曲線を作図
  csc_graph <- ggplot() + 
    geom_line(data = csc_df, 
              mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
              size = 1) + # csc曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_csc_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "cosecant function", 
         subtitle = parse(text = csc_label), 
         x = expression(theta), 
         y = expression(csc~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(csc_graph, circle_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1000, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　csc関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/csc_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/csc_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が1周する $2 \pi$ の間隔で、曲線が同じ形になるのが分かります。\
\


##### パターン2

　2つ目の方法では、csc関数とsin関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("csc", "sin", "cos", "cot")

# グラフサイズ用の値を設定
x_size <- 2.5
y_size <- 1.5

# 軸変換図のグリッド線の描画用
d <- 0.5
adapt_grid_df <- tidyr::expand_grid(
  ds = seq(from = d, to = 2*x_size, by = d), # グリッド線の位置を指定
  rad = seq(from = 0, to = 0.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = -x_size + ds * cos(rad), 
    y = -x_size + ds * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    csc_t = 1/sin(theta)
  ) |> 
  dplyr::mutate(
    csc_t = dplyr::if_else(condition = is.infinite(csc_t), true = NA_real_, false = csc_t)
  ) # 発散した場合は欠損値に置換
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.21
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 変換フラグを設定
  cos_flg <- cos(theta) >= 0
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(
      0, 0, 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_from = c(
      0, 0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      1, cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      0, sin(theta), 
      1, ifelse(test = cos_flg, yes = NA, no = 1)
    ), 
    width = c("normal", "normal", "thin", "thin") # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "csc", "csc", "csc", 
      "sin", 
      "cos", 
      "cot", "cot"
    ) |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      cos(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    y_from = c(
      0, ifelse(test = cos_flg, yes = NA, no = 0), 0, 
      0, 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    x_to = c(
      ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flg, yes = NA, no = 1/tan(theta)), 1/sin(theta), 
      cos(theta), 
      cos(theta), 
      1/tan(theta), ifelse(test = cos_flg, yes = NA, no = -1/tan(theta))
    ), 
    y_to = c(
      1, ifelse(test = cos_flg, yes = NA, no = 1), 0, 
      sin(theta), 
      0, 
      0, ifelse(test = cos_flg, yes = NA, no = 0)
    ), 
    type = c(
      "main", "sub", "sub", 
      "main", 
      "main", 
      "main", "sub"
    ), # 線タイプ用
    width = c(
      "normal", "normal", "bold", 
      "normal", 
      "normal", 
      "thin", "thin"
    ) # 太さ用
  ) |> 
  dplyr::mutate(
    x_to = dplyr::if_else(condition = is.infinite(x_to), true = NA_real_, false = x_to), 
    y_to = dplyr::if_else(condition = is.infinite(y_to), true = NA_real_, false = y_to)
  ) # 発散した場合は欠損値に置換
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("csc", "sin", "cos", "cot") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / ifelse(test = cos_flg, yes = tan(theta), no = -tan(theta)), 
      cos(theta), 
      0.5 * cos(theta), 
      0.5 / tan(theta)
    ), 
    y = c(
      0.5, 
      0.5 * sin(theta), 
      0, 
      0
    ), 
    angle = c(0, 90, 0, 0), 
    h = c(1.1, 0.5, 0.5, 0.5), 
    v = c(0.5, -0.5, -0.5, 1), 
    fnc_label = c("csc~theta", "sin~theta", "cos~theta", "cot~theta") # 関数ラベル
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(ifelse(test = cos_flg, yes = 1/tan(theta), no = -1/tan(theta)), 1/sin(theta)), 
    y = c(1, 0)
  ) |> 
  dplyr::mutate(
    x = dplyr::if_else(condition = is.infinite(x), true = NA_real_, false = x), 
    y = dplyr::if_else(condition = is.infinite(y), true = NA_real_, false = y)
  ) # 発散した場合は欠損値に置換
  
  # csc直線の角度を設定
  if(sin(theta) >= 0) {
    tmp_theta <- asin(sin(theta))
  } else {
    tmp_theta <- pi + asin(sin(theta))
  }
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(
      from = tmp_theta, 
      to = ifelse(test = sin(theta) >= 0, yes = 0, no = pi), 
      length.out = 100
    ), 
    x = abs(1/sin(theta)) * cos(rad), 
    y = abs(1/sin(theta)) * sin(rad)
  )
  
  # csc・sin曲線との対応線の座標を格納
  l <- 1
  segment_circle_df <- tibble::tibble(
    x = c(1/sin(theta), cos(theta)), 
    y = c(0, sin(theta)), 
    x_to = c(1/sin(theta), -x_size-l), 
    y_to = c(y_size+l, sin(theta))
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # csc直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), na.rm = TRUE, 
               size = 4) + # csc関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = width), na.rm = TRUE) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), 
              parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide = "none") + # (補助線用)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 変数の作成処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # sin・csc関数を計算
  curve_df <- tibble::tibble(
    t = theta_vec, 
    sin_t = sin(t), 
    csc_t = 1/sin(t)
  ) |> 
    dplyr::mutate(
      csc_t = dplyr::if_else(
        condition = (csc_t >= -x_size & csc_t <= x_size), 
        true = csc_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  ## 軸の変換図の作図処理
  
  # csc関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = -x_size + (x_size+1/sin(theta)) * cos(rad), 
    y = -x_size + (x_size+1/sin(theta)) * sin(rad)
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(condition = x >= -x_size, true = x, false = NA_real_), 
      y = dplyr::if_else(condition = y >= -x_size, true = y, false = NA_real_)
    ) # 領域外の場合は欠損値に置換
  
  # csc曲線・直線との対応線の座標を格納
  lx <- 0.8
  ly <- 0.4
  segment_adapt_df <- tibble::tibble(
    x = c(1/sin(theta), -x_size), 
    y = c(-x_size, 1/sin(theta)), 
    x_to = c(1/sin(theta), -x_size-lx), 
    y_to = c(-x_size-ly, 1/sin(theta))
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(condition = x >= -x_size, true = x, false = NA_real_), 
      y = dplyr::if_else(condition = y >= -x_size, true = y, false = NA_real_)
    ) # 領域外の場合は欠損値に置換
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = ds), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), na.rm = TRUE, 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), na.rm = TRUE, 
               size = 4) + # csc関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-x_size, x_size), ylim = c(-x_size, x_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## csc関数曲線の作図処理
  
  # csc直線との対応線の座標を格納
  l <- 0.7
  d <- 1.1
  segment_csc_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/sin(theta), -x_size*d), 
    x_to = c(theta+l, theta), 
    y_to = c(1/sin(theta), -x_size*d-l)
  )
  
  # 関数ラベル用の文字列を作成
  csc_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", csc~theta==", round(1/sin(theta), digits = 2), 
    ")"
  )
  
  # csc関数曲線を作図
  csc_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
              size = 1) + # csc曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = csc_t), na.rm = TRUE, 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_csc_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), na.rm = TRUE, 
                 size = 1, linetype = "dotted") + # csc直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-x_size, x_size)) + # 描画領域
    labs(title = "cosecant function", 
         subtitle = parse(text = csc_label), 
         x = expression(theta), 
         y = expression(csc~theta))
  
  ## sin曲線の作図処理
  
  # sin直線との対応線の座標を格納
  l <- 0.5
  d <- 1.1
  segment_sin_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(sin(theta), y_size*d), 
    x_to = c(theta+l, theta), 
    y_to = c(sin(theta), y_size*d+l)
  )
  
  # 関数ラベル用の文字列を作成
  sin_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ")"
  )
  
  # sin関数曲線を作図
  sin_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = sin_t), 
              size = 1) + # sin曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = sin_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_sin_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 変換曲線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-y_size, y_size)) + # 描画領域
    labs(title = "sine function", 
         subtitle = parse(text = sin_label), 
         x = expression(theta), 
         y = expression(sin~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    csc_graph, adapt_graph, 
    sin_graph, circle_graph, 
    nrow = 2, ncol = 2, 
    widths  = c(pi/x_size, 1), 
    heights = c(x_size/y_size, 1)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1600, height = 1200, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から上下左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　csc関数とsin関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/csc_sin_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/csc_sin_ncycle.gif)

\ 

　この記事では、csc関数を可視化しました。次の記事では、cot関数を可視化します。\
\


# cot関数の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の1つであるcot関数(余接関数・コタンジェント関数・cotangent function)をグラフで確認します。\
\

　ggplot2パッケージなどを使って作図します。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
###資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## 定義式の確認

　まずは、cot関数の定義式を確認します。\
\

　cot関数は、tan関数の逆数で定義されます。

$$
\cot x
    = \frac{1}{\tan x}
    = \frac{\cos x}{\sin x}
$$

　$\tan x$ はタンジェント関数、$\sin x$ はサイン関数、$\cos x$ はコサイン関数です。tan関数については「tan関数の可視化」、sin関数については「sin関数の可視化」、cos関数については「cos関数の可視化」を参照してください。\
　ただし、$n$ を整数として $x = n \pi$ のとき、$\sin x = \tan x = 0$ なので、0除算になるため定義できません。$\pi$ は円周率で、変数 $x$ は弧度法の角度(ラジアン)です。\
\


## cot関数の作図

　次に、cot関数のグラフを作成します。\
\

　変数の値(ベクトル)を設定します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算に用いる変数(ラジアン) $\theta$ の範囲を指定して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

<details><summary>・作図コード(クリックで展開)</summary>

　cot関数の曲線を描画するためのデータフレームを作成します。

```{r}
# 閾値を指定
threshold <- 4

# cot関数を計算
cot_df <- tibble::tibble(
  t = theta_vec, 
  tan_t = tan(theta_vec), 
  cot_t = 1/tan(theta_vec)
) |> 
  dplyr::mutate(
    tan_t = dplyr::if_else(
      condition = (tan_t >= -threshold & tan_t <= threshold), 
      true = tan_t, 
      false = NA_real_
    ), # 閾値外の値を欠損値に置換
    cot_t = dplyr::if_else(
      condition = (cot_t >= -threshold & cot_t <= threshold), 
      true = cot_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
cot_df
```

　$\theta$ の値と $\tan \theta, \cot \theta$ の値をデータフレームに格納します。cot関数は`tan()`を使って計算できます。tan関数の値は比較に使います。\
　$\theta = i \pi$ ($i$ は整数)付近で $-\infty$ または $\infty$ に近付くので、閾値`threshold`を指定しておき、`-threshold`未満または`threshold`より大きい場合は(数値型の)欠損値`NA`に置き換えます。\

　x軸目盛を設定するためのベクトルを作成します。装飾用の処理です。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度 $\theta$ に関する軸目盛ラベルを $i, n$ を整数として $\frac{i}{n} \pi$ の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。\
　`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\

　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。\
　ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`"frac(分子, 分母)"`で分数、`"~"`でスペースを表示します。\

　漸近線を描画するためのベクトルを作成します。

```{r}
# 漸近線用の値を作成
asymptote_vec <- seq(
  from = floor(min(theta_vec) / pi) + 1, 
  to = floor(max(theta_vec) / pi), 
  by = 1
) * pi
asymptote_vec; asymptote_vec*2/pi
```

　$\theta = i \pi$ ($\pi$ の倍数)のとき $\cot \theta$ が発散するので、`theta_vec`の範囲内の $\frac{2 i}{2} \pi$ の値を(上手いことして)作成します。\

</details>

　cot関数のグラフを作成します。

```{r, fig.width=10, fig.height=6, dpi=100}
# cot関数を作図
ggplot() + 
  geom_line(data = cot_df, 
            mapping = aes(x = t, y = cot_t, linetype = "cot"), 
            size = 1, na.rm = TRUE) + # cot曲線
  geom_line(data = cot_df, 
            mapping = aes(x = t, y = tan_t, linetype = "tan"), 
            size = 1, na.rm = TRUE) + # tan曲線
  geom_vline(xintercept = asymptote_vec, linetype = "dashed") + # 漸近線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 目盛ラベル
  scale_linetype_manual(breaks = c("cot", "tan"), 
                        values = c("solid", "dotted"), name = "function") + # (凡例表示用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "cotangent function", 
       x = expression(theta), 
       y = expression(cot~theta))
```

　x軸を $\theta$、y軸を $\cot \theta$ として、`geom_line()`でcot関数の曲線を描画します。また、$\tan \theta$ の曲線を点線で描画します。\
　x軸が $i \pi$ の点($0$ の前後 $\pi$ 間隔)に、`geom_vline()`で漸近線を破線で描画します。\
　$\tan \theta = 0$ となる $\theta$ が漸近線なのが分かります。\
\


## 単位円の作図

　続いて、cot関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円を描画するためのデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　円周の座標計算用のラジアンとして $0 \leq \theta \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos \theta$、y軸の値 $y = \sin \theta$ を計算します。\

　円周上に角度(ラジアン)目盛を描画するためのデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛ラベルの描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

</details>

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズ用の値を指定
axis_size <- 1.4

# 単位円を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
```

　このグラフ上に三角関数の値を直線として描画します。\
\


## 単位円上のcot関数の可視化

　次は、単位円上における三角関数(cot・tan・sin・cos・exsec・excsc)のグラフを作成します。\
\


### グラフの作成

　変数を固定したcot関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 円周上の点用のラジアンを指定
theta <- 2/6 * pi
theta
```

　円周上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　2つの線分のなす角 $\theta$ を示す角マークを描画するために、$0$ から $\theta$ までのラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\
\

</details>

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、x軸線から伸びる直線としてcot関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_from = c(0, 0, 0, 1/tan(theta)), 
  y_from = c(0, 0, 0, 0), 
  x_to = c(1, cos(theta), 0, 1/tan(theta)), 
  y_to = c(0, sin(theta), 1, 1), 
  type = c("normal", "normal", "thin", "thin") # 太さ用
)
radius_df
```

　原点と点 $(1, 0)$ を結ぶ線分(x軸線の正の部分)と、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を描画するために、2つの線分の座標を格納します。\
　また、関数直線の補助線として、長さが半径と同じ線分の座標を(次のデータフレームの座標を睨めっこして)格納します。\
　なす角用の線分と補助線用の線分を、線の太さで描き分けることにします。`type`列として、それぞれの線区別する文字列を指定します。文字列の内容は自由です。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "cot", "cot", 
    "tan", 
    "sin", "sin", 
    "cos", "cos", 
    "exsec", 
    "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 
    1, 
    0, cos(theta), 
    0, 0, 
    cos(theta), 
    cos(theta)
  ), 
  y_from = c(
    0, 1, 
    0, 
    0, 0, 
    0, sin(theta), 
    sin(theta), 
    sin(theta)
  ), 
  x_to = c(
    1/tan(theta), 1/tan(theta), 
    1, 
    0, cos(theta), 
    cos(theta), cos(theta), 
    1, 
    1/tan(theta)
  ), 
  y_to = c(
    0, 1, 
    tan(theta), 
    sin(theta), sin(theta), 
    0, sin(theta), 
    tan(theta), 
    1
  ), 
  type = c(
    "bold", "normal", 
    "normal", 
    "normal", "normal", 
    "thin", "normal", 
    "bold", 
    "thin") # 太さ用
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。\
　重なる線分を、線の太さで描き分けることにします。先に描画される線分を太く、後から描画される線分を細くするように、先ほどの文字列を`type`列に指定します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / tan(theta), 
    1, 
    0, 
    0.5 * cos(theta), 
    0.5 * (cos(theta) + 1), 
    0.5 * (cos(theta) + 1/tan(theta))
  ), 
  y = c(
    1, 
    0.5 * tan(theta), 
    0.5 * sin(theta), 
    0, 
    0.5 * (sin(theta) + tan(theta)), 
    0.5 * (sin(theta) + 1)
  ), 
  angle = c(0, 90, 90, 0, 0, 0), 
  h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
  v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
  fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ラベルの表示角度を`angle`列、表示角度に応じた左右の表示位置を`h`列、上下の表示位置を`v`列として値を指定します。\

　変数と関数の値を表示するための文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
  ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
  ")"
)
variable_label
```

　`"=="`で等号、`"list(変数1, 変数2)"`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
axis_size <- 1.3
x_min <- min(-axis_size, 1/tan(theta))
x_max <- max(axis_size, 1/tan(theta))
y_min <- min(-axis_size, tan(theta))
y_max <- max(axis_size, tan(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = type)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

　cot関数の定義式 $\tan \theta = \frac{\cos \theta}{\sin \theta}$ やこの図から、$\sin \theta : \cos \theta = 1 : \tan \theta$ なのが分かります。cot関数の値は、「原点と円周上の点 $(\cos \theta, \sin \theta)$ を通る直線」と「$y = 1$ の直線(破線)」の交点のx軸の値(横幅)です。\
　$\mathrm{exsec}\ \theta = \frac{1}{\cos \theta} - 1$ と $\mathrm{excsc}\ \theta = \frac{1}{\sin \theta} - 1$ も三角関数の一種ですが、まぁいいでしょう。\
\


#### パターン2

　2つ目の方法では、円周上の点から伸びる直線としてcot関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_to = c(1, cos(theta), 0), 
  y_to = c(0, sin(theta), ifelse(sin(theta) >= 0, yes = 1, no = 0)), 
  type = c("normal", "normal", "thin") # 太さ用
)
radius_df
```

　先ほどと同様に、なす角 $\theta$ のための2つの線分の終点の座標を格納します。\
　また、関数直線の補助線として、$\sin \theta$ が正の値( $0 \leq \theta \leq \pi$ )のとき、原点と点 $(0, 1)$ を結ぶ線分の座標を格納します。$\sin \theta$ が負の値( $\pi \lt \theta \lt 2 \pi$ )のときは、原点の座標(線分にならないように座標)を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c("cot", "tan", "sin", "sin", "cos", "cos", "exsec", "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    cos(theta), 
    cos(theta), 
    0, 0, 
    0, 0, 
    1, 
    0
  ), 
  y_from = c(
    sin(theta), 
    sin(theta), 
    0, 0, 
    sin(theta), ifelse(sin(theta) >= 0, yes = 1, no = -1), 
    0, 
    1
  ), 
  x_to = c(
    0, 
    1/cos(theta), 
    0, abs(sin(theta))*cos(theta), 
    cos(theta), abs(sin(theta))*cos(theta), 
    1/cos(theta), 
    0
  ), 
  y_to = c(
    1/sin(theta), 
    0, 
    sin(theta), abs(sin(theta))*sin(theta), 
    sin(theta), abs(sin(theta))*sin(theta), 
    0, 
    1/sin(theta)
  ), 
  type = c("normal", "normal", "bold", "normal", "normal", "normal", "normal", "thin") # 太さ用
)
function_line_df
```

　先ほどの様に、線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 * cos(theta), 
    0.5 * (1/cos(theta) + cos(theta)), 
    0, 
    0.5 * cos(theta), 
    0.5 * (1 + 1/cos(theta)), 
    0
  ), 
  y = c(
    0.5 * (1/sin(theta) + sin(theta)), 
    0.5 * sin(theta), 
    0.5 * sin(theta), 
    sin(theta), 
    0, 
    0.5 * (1 + 1/sin(theta))
  ), 
  angle = c(0, 0, 90, 0, 0, 90), 
  h = c(-0.2, -0.2, 0.5, 0.5, 0.5, 0.5), 
  v = c(0.5, 0.5, -0.5, -0.5, 1, 1), 
  fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# グラフサイズ用の値を設定
axis_size <- 1.3
x_min <- min(-axis_size, 1/cos(theta))
x_max <- max(axis_size, 1/cos(theta))
y_min <- min(-axis_size, 1/sin(theta))
y_max <- max(axis_size, 1/sin(theta))

# 単位円上の三角関数直線を作図
ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 0, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to, size = type)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
```

　こちらの図は、原点と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分を底辺、y軸線の一部を斜辺としたときのパターン1の図と言えます。文字通り首を捻って見てください。\
　cot関数の値は、「原点と円周上の点 $(\cos \theta, \sin \theta)$ を通る直線」に対する「円周上の点 $(\cos \theta, \sin \theta)$ を通る垂線」と「$x = 0$ の直線(破線)」の「交点 $(0, \frac{1}{\sin \theta})$ と円周上の点 $(\cos \theta, \sin \theta)$ を結ぶ線分」の長さです。\
\


### アニメーションの作成

　続いて、変数の値を変化させたcot関数をアニメーションで確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 150

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上の点の座標計算に用いる変数(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。範囲を $2 n \pi$ にして`frame_num + 1`個の等間隔の値を作成して最後の値を除くと、最後のフレームと最初のフレームがスムーズに繋がります。\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム切替用のラベルとして用いる文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", cot θ = ", round(1/tan(theta_i), digits = 2), 
  ", tan θ = ", round(tan(theta_i), digits = 2), 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", exsec θ = ", round(1/cos(theta_i)-1, digits = 2), 
  ", excsc θ = ", round(1/sin(theta_i)-1, digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値をグラフに表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点を描画するためのデータフレームを作成します。

```{r}
# 曲線上の点の描画用
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレーム切替用のラベルとあわせて格納します。\

　角マークを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  frame_label = factor(frame_label_vec, levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::group_by(frame_i, frame_label) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t)
  )
anim_angle_mark_df
```

　フレーム列でグループ化してフレーム(変数の値)ごとに、`summarise()`を使って`0`から各フレームの角度`theta_n[frame_i]`までの値を作成して、円弧の座標を計算します。\

　角ラベルを描画するためのデータフレームを作成します。

```{r}
# フレームごとの角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとの角マークの中点に角ラベルを配置するために、$\frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。\
\

</details>

　ここまでは、共通の処理です。ここからは、「グラフの作成」のときと同様に2つの方法で図示します。\
\


#### パターン1

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    1/tan(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    1/tan(theta_i)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i), 
    rep(1, times = frame_num), 
    rep(1, times = frame_num)
  ), 
  type = c("normal", "normal", "thin", "thin") |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 4) |> # (4は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　「グラフの作成」のときと同様に、フレーム数分の原点と点 $(0, 1)$ の座標と、フレームごとの点 $(\cos \theta, \sin \theta)$ の座標、また補助線用の線分の座標を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c(
    "cot", "cot", 
    "tan", 
    "sin", "sin", 
    "cos", "cos", 
    "exsec", 
    "excsc") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(1, times = frame_num), 
    rep(0, times = frame_num), cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    cos(theta_i), 
    cos(theta_i)
  ), 
  y_from = c(
    rep(0, times = frame_num), rep(1, times = frame_num), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), sin(theta_i), 
    sin(theta_i), 
    sin(theta_i)
  ), 
  x_to = c(
    1/tan(theta_i), 1/tan(theta_i), 
    rep(1, times = frame_num), 
    rep(0, times = frame_num), cos(theta_i), 
    cos(theta_i), cos(theta_i), 
    rep(1, times = frame_num), 
    1/tan(theta_i)
  ), 
  y_to = c(
    rep(0, times = frame_num), rep(1, times = frame_num), 
    tan(theta_i), 
    sin(theta_i), sin(theta_i), 
    rep(0, times = frame_num), sin(theta_i), 
    tan(theta_i), 
    rep(1, times = frame_num)
  ), 
  type = c(
    "bold", "normal", 
    "normal", 
    "normal", "normal", 
    "thin", "normal", 
    "bold", 
    "thin") |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) |> 
    rep(each = frame_num), # # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 9) |> # (9は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　線分ごとに`frame_num`個の座標を格納します。\
　また、関数ラベルを描画する線分を`label_flag`列に指定しておきます。関数ごとに、ラベルを表示する1つの線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 90, 90, 0, 0, 0) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1) |> 
      rep(each = frame_num), 
    v = c(-0.5, 1, -0.5, 1, 0.5, 0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　`anim_function_line_df`から`label_flag`列が`TRUE`の行(線分)を取り出して、`fnc, frame_label`列でグループ化して関数(線分)とフレームごとに、中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = type)) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")
# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 800)
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

　$\theta = 0, \pi$ のとき $\sin \theta = 0$ なので、原点と円周上の点を結ぶ線分が水平になり直線 $y = 1$ と平行なため交点ができず、$\cot \theta$ を描画(定義)できないのが分かります。\
\


#### パターン2

<details><summary>・作図コード(クリックで展開)</summary>

　半径を示す線分を描画するためのデータフレームを作成します。

```{r}
# 半径の線分の座標を格納
anim_radius_df <- tibble::tibble(
  x_to = c(
    rep(1, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num)
  ), 
  y_to =  c(
    rep(0, times = frame_num), 
    sin(theta_i), 
    ifelse(sin(theta_i) >= 0, yes = 1, no = 0)
  ), 
  type = c("normal", "normal", "thin") |> 
    rep(each = frame_num), # 太さ用
  frame_label = frame_label_vec |> 
    rep(times = 3) |> # (3は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_radius_df
```

　先ほどと同様に、半径を示す線分と補助線用の線分の座標を格納します。\

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
anim_function_line_df <- tibble::tibble(
  fnc = c("cot", "tan", "sin", "sin", "cos", "cos", "exsec", "excsc") |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    cos(theta_i), 
    cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(1, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  y_from = c(
    sin(theta_i), 
    sin(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    sin(theta_i), ifelse(sin(theta_i) >= 0, yes = 1, no = -1), 
    rep(0, times = frame_num), 
    rep(1, times = frame_num)
  ), 
  x_to = c(
    rep(0, times = frame_num), 
    1/cos(theta_i), 
    rep(0, times = frame_num), abs(sin(theta_i))*cos(theta_i), 
    cos(theta_i), abs(sin(theta_i))*cos(theta_i), 
    1/cos(theta_i), 
    rep(0, times = frame_num)
  ), 
  y_to = c(
    1/sin(theta_i), 
    rep(0, times = frame_num), 
    sin(theta_i), abs(sin(theta_i))*sin(theta_i), 
    sin(theta_i), abs(sin(theta_i))*sin(theta_i), 
    rep(0, times = frame_num), 
    1/sin(theta_i)
  ), 
  type = c("normal", "normal", "bold", "normal", "normal", "normal", "normal", "thin") |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE) |> 
    rep(each = frame_num), # # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 8) |> # (8は線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
)
anim_function_line_df
```

　線分の座標を格納します。\

　関数名をラベルとして描画するためのデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(0, 0, 90, 0, 0, 90) |> 
      rep(each = frame_num), 
    h = c(-0.2, -0.2, 0.5, 0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(0.5, 0.5, -0.5, -0.5, 1, 1) |> 
      rep(each = frame_num), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　ラベルを表示する線分の中点の座標を計算して、ラベル用の文字列などを格納します。\

</details>

　単位円上に三角関数の直線を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
x_size <- 2
y_size <- 2

# 単位円上の三角関数直線のアニメーションを作図
anim <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_vline(xintercept = 0, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_segment(data = anim_radius_df, 
               mapping = aes(x = 0, y = 0, xend = x_to, yend = y_to, size = type)) + # 半径直線
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
gganimate::animate(plot = anim, nframes = frame_num, fps = 100, width = 800, height = 800)
```

　こちらの図だと、原点と円周上の点を結ぶ線分が垂直になり、その垂線が直線 $x = 0$ と平行なため交点ができず、$\cot \theta$ を描画(定義)できないのが分かります。\
\


## 単位円上の点とcot関数曲線の関係の可視化

　最後は、単位円上におけるcot関数の値(直線)と、cot関数の曲線の関係をグラフで確認します。\
\


### グラフの作成

　変数を固定したcot関数をグラフで確認します。\
\

　変数の値(スカラ)を設定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 3/4 * pi

# 曲線上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta), 
  cot_t = 1/tan(theta)
)
point_df
```

　曲線上の点の座標計算に用いる変数(ラジアン) $\theta$ を`theta`として値を指定します。\

<details><summary>・作図コード(クリックで展開)</summary>

　「単位円上のcot関数の可視化」の「パターン1」のコードで4つのデータフレームを作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# 角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)

# 半径の線分の座標を格納
radius_df <- tibble::tibble(
  x_from = c(0, 0, 0, 1/tan(theta)), 
  y_from = c(0, 0, 0, 0), 
  x_to = c(1, cos(theta), 0, 1/tan(theta)), 
  y_to = c(0, sin(theta), 1, 1), 
  type = c("normal", "normal", "thin", "thin") # 太さ用
)

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# 関数ラベルの座標を格納
function_label_df <- tibble::tibble(
  fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0.5 / tan(theta), 
    1, 
    0, 
    0.5 * cos(theta), 
    0.5 * (cos(theta) + 1), 
    0.5 * (cos(theta) + 1/tan(theta))
  ), 
  y = c(
    1, 
    0.5 * tan(theta), 
    0.5 * sin(theta), 
    0, 
    0.5 * (sin(theta) + tan(theta)), 
    0.5 * (sin(theta) + 1)
  ), 
  angle = c(0, 90, 90, 0, 0, 0), 
  h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
  v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
  fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
)

```

</details>

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcot関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "cot", "cot", "cot", 
    "tan", 
    "sin", "sin", 
    "cos", "cos", 
    "exsec", 
    "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 0, 
    1, 
    0, cos(theta), 
    0, 0, 
    cos(theta), 
    cos(theta)
  ), 
  y_from = c(
    0, 1, 0, 
    0, 
    0, 0, 
    0, sin(theta), 
    sin(theta), 
    sin(theta)
  ), 
  x_to = c(
    1/tan(theta), 1/tan(theta), 0, 
    1, 
    0, cos(theta), 
    cos(theta), cos(theta), 
    1, 
    1/tan(theta)
  ), 
  y_to = c(
    0, 1, 1/tan(theta), 
    tan(theta), 
    sin(theta), sin(theta), 
    0, sin(theta), 
    tan(theta), 
    1
  ), 
  linewidth = c(
    "bold", "normal", "bold", 
    "normal", 
    "normal", "normal", 
    "thin", "normal", 
    "bold", 
    "thin"), # 太さ用
  linetype = c(
    "main", "main", "sub", 
    "main", 
    "main", "main", 
    "main", "main", 
    "main", 
    "main") # 線タイプ用
)
function_line_df
```

　「単位円上のcot関数の可視化」のときのコードに、cot直線の1つを90°回転(軸を変換)した線分の座標を格納します。\

　軸の変換前後の点を描画するためのデータフレームを作成します。

```{r}
# 変換曲線の先端の座標を格納
adapt_point_df <- tibble::tibble(
  x = c(1/tan(theta), 0), 
  y = c(0, 1/tan(theta))
)
adapt_point_df
```

　x軸・y軸の値をそれぞれ $0, \cot \theta$ とする2点の座標を格納します。\

　x軸の値を90度回転する曲線を描画するためのデータフレームを作成します。

```{r}
# 軸変換曲線の描画用
adapt_line_df <- tibble::tibble(
  rad = ifelse(
    test = rep(tan(theta) > 0, times = 100), 
    yes = seq(from = 0, to = 0.5*pi, length.out = 100), 
    no = seq(from = pi, to = 1.5*pi, length.out = 100)
  ), 
  x = abs(1/tan(theta)) * cos(rad), 
  y = abs(1/tan(theta)) * sin(rad)
)
adapt_line_df <- tibble::tibble(
  rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
  x = 1/tan(theta) * cos(rad), 
  y = 1/tan(theta) * sin(rad)
)
adapt_line_df
```

　軸を変換する軌道として、半径が $|\cot \theta|$ の弧を描画します。全体値 $|x|$ は`abs()`で計算できます。\
　$\cot \theta \geq 0$ のとき($\tan \theta \geq 0$ のとき)x軸の正の部分からy軸の正の部分への変化を示すため $0 \leq t \leq \frac{\pi}{2}$ のラジアン、$\cos \theta \lt 0$ のときx軸の負の部分からy軸の負の部分への変化を示すため $\pi \leq t \leq \frac{3 \pi}{2}$ のラジアンを用いて、弧のx軸の値 $x = |\cot \theta| \cos t$ とy軸の値 $y = |\cot \theta| \sin t$ を計算します。\
　または、$- \sin x = \sin (x + \pi), - \cot x = \cot (x + \pi)$ なのを利用して、$\theta$ の値に関わらず、$0 \leq t \leq \frac{\pi}{2}$ のラジアンを用いて、$x = \cos \theta \cos t$、$y = \cos \theta \sin t$ でも弧の座標を計算できます。\

　単位円における点とcot曲線上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_min  <- 2
axis_max  <- 5
axis_size <- ceiling(abs(1/tan(theta))) |> 
  max(axis_min) |> 
  min(axis_max)

# cot曲線との対応線の座標を格納
l <- 0.5
segment_circle_df <- tibble::tibble(
  x = 0, 
  x_to = axis_size+l, 
  y = 1/tan(theta)
)
segment_circle_df
```

　単位円における点からy軸の反対側へ水平線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "tan~theta==", round(tan(theta), digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
  ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
  ")"
)

# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(data = adapt_point_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # cot関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = type)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = linewidth, linetype = linetype)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 変換曲線
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y), 
               size = 1, linetype = "dotted") + # cot曲線との対応線
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcot関数の可視化」のときと同様に、作図します。\
\

　cot関数の曲線を描画するためのデータフレームを作成します。

```{r}
# cot関数を計算
cot_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  cot_t = 1/tan(t)
) |> 
  dplyr::mutate(
    cot_t = dplyr::if_else(
      condition = (cot_t >= -axis_size & cot_t <= axis_size), 
      true = cot_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
cot_df
```

　「cot関数の作図」のときと同様にして、曲線の座標を計算します。\

　cot曲線上の点と単位円における点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# cot直線との対応線の座標を格納
l <- 0.7
d <- 1.1
segment_cot_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(1/tan(theta), 1/tan(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-axis_size*d, 1/tan(theta))
)
segment_cot_df
```

　曲線上の点からx軸とy軸へ垂線と水平線を引くように座標を指定します。\

　x軸目盛を設定するためのベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「cot関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　cot関数曲線のグラフを作成します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 関数ラベル用の文字列を作成
cot_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ")"
)

# cot関数曲線を作図
cot_graph <- ggplot() + 
  geom_line(data = cot_df, 
            mapping = aes(x = t, y = cot_t), 
            size = 1, na.rm = TRUE) + # cot曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = cot_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_cot_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # cot直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "cotangent function", 
       subtitle = parse(text = cot_label), 
       x = expression(theta), 
       y = expression(cot~theta))
cot_graph
```

　「cot関数の作図」のときと同様に、作図します。\
\

</details>

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
patchwork::wrap_plots(circle_graph, cot_graph)
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

　2つのグラフで、単位円における点の値とcot曲線上の点のy軸の値と、なす角の値とx軸の値がそれぞれ一致するのが分かります。\
\


#### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcot関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　三角関数を直線として描画するためのデータフレームを作成します。

```{r}
# 関数直線の線分の座標を格納
function_line_df <- tibble::tibble(
  fnc = c(
    "cot", "cot", 
    "tan", 
    "sin", "sin", 
    "cos", "cos", 
    "exsec", 
    "excsc") |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 
    1, 
    0, cos(theta), 
    0, 0, 
    cos(theta), 
    cos(theta)
  ), 
  y_from = c(
    0, 1, 
    0, 
    0, 0, 
    0, sin(theta), 
    sin(theta), 
    sin(theta)
  ), 
  x_to = c(
    1/tan(theta), 1/tan(theta), 
    1, 
    0, cos(theta), 
    cos(theta), cos(theta), 
    1, 
    1/tan(theta)
  ), 
  y_to = c(
    0, 1, 
    tan(theta), 
    sin(theta), sin(theta), 
    0, sin(theta), 
    tan(theta), 
    1
  ), 
  type = c(
    "bold", "normal", 
    "normal", 
    "normal", "normal", 
    "thin", "normal", 
    "bold", 
    "thin") # 太さ用
)
function_line_df
```

　「単位円上のcot関数の可視化」のときのコードで線分の座標を格納します。\

　単位円における点と軸の変換図上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_min  <- 2
axis_max  <- 5
axis_size <- ceiling(abs(1/tan(theta))) |> 
  max(axis_min) |> 
  min(axis_max)

# 軸変換曲線との対応線の座標を格納
l <- 0.4
segment_circle_df <- tibble::tibble(
  x = 1/tan(theta), 
  y = 0, 
  y_to = -axis_size-l
)
segment_circle_df
```

　単位円上の点からx軸へ垂直線を引くように座標を指定します。\

　単位円上に三角関数の直線を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 単位円上の三角関数直線を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_point(mapping = aes(x = 1/tan(theta), y = 0), 
             size = 4) + # cot関数の点
  geom_segment(data = radius_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             size = type)) + # 半径直線
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # 角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # 角ラベル
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = type)) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x, yend = y_to), 
               size = 1, linetype = "dotted") + # 軸変換曲線との対応線
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  theme(legend.position = "left") + # 凡例の位置
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「単位円上のcot関数の可視化」のときと同様に、作図します。\
\

　x軸の値を90度回転する線を描画するためのデータフレームを作成します。

```{r}
# cot関数の軸変換曲線の座標を計算
adapt_line_df <- tibble::tibble(
  rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
  x = axis_size + (axis_size-1/tan(theta)) * cos(rad), 
  y = axis_size + (axis_size-1/tan(theta)) * sin(rad)
) |> 
  dplyr::mutate(
    x = dplyr::if_else(
      condition = x <= axis_size, 
      true = x, 
      false = NA_real_
    ), 
    y = dplyr::if_else(
      condition = y <= axis_size, 
      true = y, 
      false = NA_real_
    )
  ) # 描画領域外の値を欠損値に置換
adapt_line_df
```

　グラフのサイズを`axis_size`の2倍としました。`axis_size`を $S$ で表します。軸を変換する軌道として、中心の座標が $(S, S)$ で半径が $r = S - \cot \theta$ の弧を描画します。また、弧の中心が図の右上隅になるようにします。\
　$0 \leq t \leq \frac{\pi}{2}$ を用いて、弧のx軸の値 $x = S + r \cos t$ とy軸の値 $y = S + r \sin t$ を計算します。\
　円の座標計算については「円周の作図」を参照してください。\

　軸の変換図のグリッド線を描画するためのデータフレームを作成します。

```{r}
# 軸変換図のグリッド線の描画用
d <- 0.5
adapt_grid_df <- tidyr::expand_grid(
  d = seq(from = d, to = 2*axis_size, by = d), # グリッド線の位置
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = axis_size + d * cos(rad), 
    y = axis_size + d * sin(rad)
  )
adapt_grid_df
```

　軸の変換曲線と同様に、グリッド線として、等間隔の半径の複数の曲線を描画します。この例では、半径を $0 \lt r \leq 2 S$ の範囲の $0.5$ 間隔の値とします。\
　半径 $r$ の値を指定して`d`列、ラジアン $t$ の値を作成して`rad`列とします。`d, rad`列の全ての組み合わせを`expand_grid()`で作成することで、半径ごとに曲線用のラジアンを複製します。\
　弧の座標を $x = S + r \cos t$、$y = S + r \sin t$ で計算します。\

　軸の変換図上の点とcot曲線上の点・単位円上の点を結ぶ補助線(の半分)を描画するためのデータフレームを作成します。

```{r}
# cot曲線・直線との対応線の座標を格納
l <- 0.9
segment_adapt_df <- tibble::tibble(
  x = c(1/tan(theta), axis_size), 
  y = c(axis_size, 1/tan(theta)), 
  x_to = c(1/tan(theta), axis_size+l), 
  y_to = c(axis_size+l, 1/tan(theta))
)
segment_adapt_df
```

　曲線の両端からx軸とy軸の反対側へ水平線と垂直線を引くように座標を指定します。\

　軸の変換図を作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 軸の変換曲線を作図
adapt_graph <- ggplot() + 
  geom_line(data = adapt_grid_df, 
            mapping = aes(x = x, y = y, group = d), 
            color = "white") + # グリッド線
  geom_line(data = adapt_line_df, 
            mapping = aes(x = x, y = y), 
            size = 1, linetype = "dotted") + # 軸変換曲線
  geom_point(data = segment_adapt_df, 
             mapping = aes(x = x, y = y), 
             size = 4) + # cot関数の点
  geom_segment(data = segment_adapt_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # cot直線・曲線との対応線
  #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(x = "x", y = "x")
adapt_graph
```

　軸の変換曲線とグリッド線をそれぞれ`geom_line()`で描画します。\
\

　「パターン1」のときのコードで、cot関数曲線のグラフを作成します。

```{r, echo=FALSE, fig.width=8, fig.height=6, dpi=100}
### 資料作成用:(値の変更)

# cot直線との対応線の座標を格納
l <- 1
d <- 1.1
segment_cot_df <- tibble::tibble(
  x = c(theta, theta), 
  y = c(1/tan(theta), 1/tan(theta)), 
  x_to = c(theta, -l), 
  y_to = c(-axis_size*d, 1/tan(theta))
)

# cot関数曲線を作図
cot_graph <- ggplot() + 
  geom_line(data = cot_df, 
            mapping = aes(x = t, y = cot_t), 
            size = 1, na.rm = TRUE) + # cot曲線
  geom_point(data = point_df, 
             mapping = aes(x = t, y = cot_t), 
             size = 4) + # 曲線上の点
  geom_segment(data = segment_cot_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
               size = 1, linetype = "dotted") + # cot直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "cotangent function", 
       subtitle = parse(text = cot_label), 
       x = expression(theta), 
       y = expression(cot~theta))
cot_graph
```

\ 

</details>

　3つのグラフを並べて描画します。

```{r, fig.width=15, fig.height=12, dpi=100}
# 縦横比を計算
w_per_h <- pi / axis_size

# 並べて描画
patchwork::wrap_plots(
  circle_graph, patchwork::plot_spacer(), 
  adapt_graph, cot_graph, 
  nrow = 2, ncol = 2, widths = c(1, w_per_h, 1, w_per_h), heights = c(1, 1, 1, 1)
)
```

　グラフを配置しない位置を`plot_spacer()`で指定します。\

　分かりやすい方の図を参考にしてください。\
\


### アニメーションの作成

　続いて、変数の値を変化させたアニメーションで確認します。\
\


#### 1周期

　円周上を1周した際のcot関数の直線と曲線上の点の関係を可視化します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 60

# 変数の値を作成
theta_i <- seq(from = 0, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、円周上と曲線上の点の座標計算に用いるの変数(ラジアン)として $0 \leq \theta \leq 2 \pi$ の範囲で`frame_num`個の等間隔の値を作成します。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcot関数を可視化します。\
\


<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# グラフサイズ用の値を設定
axis_size <- 3

# cot関数を計算
cot_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  cot_t = 1/tan(t)
) |> 
  dplyr::mutate(
    cot_t = dplyr::if_else(
      condition = (cot_t >= -axis_size & cot_t <= axis_size), 
      true = cot_t, 
      false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    cot_t = 1/tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0, 1/tan(theta)), 
    y_from = c(0, 0, 0, 0), 
    x_to = c(1, cos(theta), 0, 1/tan(theta)), 
    y_to = c(0, sin(theta), 1, 1), 
    type = c("normal", "normal", "thin", "thin") # 太さ用
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "cot", "cot", "cot", 
      "tan", 
      "sin", "sin", 
      "cos", "cos", 
      "exsec", 
      "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 0, 
      1, 
      0, cos(theta), 
      0, 0, 
      cos(theta), 
      cos(theta)
    ), 
    y_from = c(
      0, 1, 0, 
      0, 
      0, 0, 
      0, sin(theta), 
      sin(theta), 
      sin(theta)
    ), 
    x_to = c(
      1/tan(theta), 1/tan(theta), 0, 
      1, 
      0, cos(theta), 
      cos(theta), cos(theta), 
      1, 
      1/tan(theta)
    ), 
    y_to = c(
      0, 1, 1/tan(theta), 
      tan(theta), 
      sin(theta), sin(theta), 
      0, sin(theta), 
      tan(theta), 
      1
    ), 
    linewidth = c(
      "bold", "normal", "bold", 
      "normal", 
      "normal", "normal", 
      "thin", "normal", 
      "bold", 
      "thin"), # 太さ用
    linetype = c(
      "main", "main", "sub", 
      "main", 
      "main", "main", 
      "main", "main", 
      "main", 
      "main") # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / tan(theta), 
      1, 
      0, 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1), 
      0.5 * (cos(theta) + 1/tan(theta))
    ), 
    y = c(
      1, 
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta)), 
      0.5 * (sin(theta) + 1)
    ), 
    angle = c(0, 90, 90, 0, 0, 0), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
    v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1/tan(theta), 0), 
    y = c(0, 1/tan(theta))
  )
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = 1/tan(theta) * cos(rad), 
    y = 1/tan(theta) * sin(rad)
  )
  
  # cot曲線との対応線の座標を格納
  l <- 0.5
  segment_circle_df <- tibble::tibble(
    x = 0, 
    x_to = axis_size+l, 
    y = 1/tan(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cot関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = type)) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = linewidth, linetype = linetype)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # cot曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # cot直線との対応線の座標を格納
  l <- 0.9
  d <- 1.1
  segment_cot_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/tan(theta), 1/tan(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-axis_size*d, 1/tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cot_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # cot関数曲線を作図
  cot_graph <- ggplot() + 
    geom_line(data = cot_df, 
              mapping = aes(x = t, y = cot_t), 
              size = 1, na.rm = TRUE) + # cot曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cot_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cot_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cotangent function", 
         subtitle = parse(text = cot_label), 
         x = expression(theta), 
         y = expression(cot~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(circle_graph, cot_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 800, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　変数の値ごとに「グラフの作成」のときと同様に処理します。作成したグラフを`ggsave()`で保存します。\

</details>

　cot関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cot_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cot_1cycle.gif)

　全てのファイルパスを作成して、`image_read()`で画像ファイルを読み込んで、`image_animate()`でgif画像に変換して、`image_write_gif()`でgifファイルとして書き出します。`delay`引数に1秒当たりのフレーム数の逆数を指定します。\

　$\tan \theta = 0$ となる $\theta = 0, \pi, 2 \pi$ とき、cot関数の線分の方向($\cot \theta$ の符号)が変わり、cot関数の曲線が不連続になるのが分かります。\
\


##### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcot関数とtan関数を並べて可視化します。tan関数の作図については「tan関数の可視化」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# グラフサイズ用の値を設定
axis_size <- 3
w_per_h <- pi / axis_size

# tan・cot関数を計算
curve_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 1000), 
  tan_t = tan(t), 
  cot_t = 1/tan(t)
) |> 
  dplyr::mutate(
    tan_t = dplyr::if_else(
      condition = (tan_t >= -axis_size & tan_t <= axis_size), 
      true = tan_t, 
      false = NA_real_
    ), 
    cot_t = dplyr::if_else(
      condition = (cot_t >= -axis_size & cot_t <= axis_size), 
      true = cot_t, 
      false = NA_real_
    )
  ) # 閾値外の値を欠損値に置換

# 目盛ラベル用の文字列を作成
denom <- 6
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

# 軸変換図のグリッド線の描画用
d <- 1
adapt_grid_df <- tidyr::expand_grid(
  d = seq(from = d, to = 2*axis_size, by = d), # グリッド線の位置
  rad = seq(from = pi, to = 1.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = axis_size + d * cos(rad), 
    y = axis_size + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    tan_t = tan(theta), 
    cot_t = 1/tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0, 1/tan(theta)), 
    y_from = c(0, 0, 0, 0), 
    x_to = c(1, cos(theta), 0, 1/tan(theta)), 
    y_to = c(0, sin(theta), 1, 1), 
    type = c("normal", "normal", "thin", "thin") # 太さ用
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "cot", "cot", 
      "tan", 
      "sin", "sin", 
      "cos", "cos", 
      "exsec", 
      "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 
      1, 
      0, cos(theta), 
      0, 0, 
      cos(theta), 
      cos(theta)
    ), 
    y_from = c(
      0, 1, 
      0, 
      0, 0, 
      0, sin(theta), 
      sin(theta), 
      sin(theta)
    ), 
    x_to = c(
      1/tan(theta), 1/tan(theta), 
      1, 
      0, cos(theta), 
      cos(theta), cos(theta), 
      1, 
      1/tan(theta)
    ), 
    y_to = c(
      0, 1, 
      tan(theta), 
      sin(theta), sin(theta), 
      0, sin(theta), 
      tan(theta), 
      1
    ), 
    type = c(
      "bold", "normal", 
      "normal", 
      "normal", "normal", 
      "thin", "normal", 
      "bold", 
      "thin") # 太さ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / tan(theta), 
      1, 
      0, 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1), 
      0.5 * (cos(theta) + 1/tan(theta))
    ), 
    y = c(
      1, 
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta)), 
      0.5 * (sin(theta) + 1)
    ), 
    angle = c(0, 90, 90, 0, 0, 0), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
    v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
  )
  
  # 軸変換曲線との対応線の座標を格納
  l <- 0.9
  segment_circle_df <- tibble::tibble(
    x = c(1/tan(theta), 1), 
    y = c(0, tan(theta)), 
    x_to = c(1/tan(theta), axis_size+l), 
    y_to = c(-axis_size-l, tan(theta))
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = segment_circle_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # tan・cot関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = type)) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = type)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 軸変換曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    theme(legend.position = "left") + # 凡例の位置
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## tan関数曲線の作図処理
  
  # tan直線との対応線の座標を格納
  l <- 0.9
  d <- 1.1
  segment_tan_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(-axis_size*d, tan(theta)), 
    x_to = c(theta, -l), 
    y_to = c(-axis_size*d-l, tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  tan_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # tan関数曲線を作図
  tan_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = tan_t), 
              size = 1, na.rm = TRUE) + # tan曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = tan_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_tan_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # tan直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "tangent function", 
         subtitle = parse(text = tan_label), 
         x = expression(theta), 
         y = expression(tan~theta))
  
  ## 軸変換図の作図処理
  
  # cot関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = pi, to = 1.5*pi, length.out = 100), 
    x = axis_size + (axis_size-1/tan(theta)) * cos(rad), 
    y = axis_size + (axis_size-1/tan(theta)) * sin(rad)
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(
        condition = x <= axis_size, 
        true = x, 
        false = NA_real_
      ), 
      y = dplyr::if_else(
        condition = y <= axis_size, 
        true = y, 
        false = NA_real_
      )
    ) # 描画領域外の値を欠損値に置換
  
  # cot曲線・直線との対応線の座標を格納
  l <- 1.2
  segment_adapt_df <- tibble::tibble(
    x = c(1/tan(theta), axis_size), 
    y = c(axis_size, 1/tan(theta)), 
    x_to = c(1/tan(theta), axis_size+l), 
    y_to = c(axis_size+l, 1/tan(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cot関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cot関数曲線の作図処理
  
  # 変換曲線との対応線の座標を格納
  l <- 0.9
  d <- 1.1
  segment_cot_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(axis_size*d, 1/tan(theta)), 
    x_to = c(theta, -l), 
    y_to = c(axis_size*d+l, 1/tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cot_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # cot関数曲線を作図
  cot_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cot_t), 
              size = 1, na.rm = TRUE) + # cot曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cot_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cot_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(0, 2*pi), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cotangent function", 
         subtitle = parse(text = cot_label), 
         x = expression(theta), 
         y = expression(cot~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    circle_graph, tan_graph, 
    adapt_graph, cot_graph, 
    nrow = 2, ncol = 2, widths = c(1, w_per_h, 1, w_per_h), heights = c(1, 1, 1, 1)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「グラフの作成のパターン2」の右上のスペースにsin関数曲線を配置します。また、「1周期のパターン1」と同様に処理します。\

</details>

　cot関数とtan関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cot_tan_1cycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cot_tan_1cycle.gif)

\ 


#### n周期

　円周上を複数回周回した際のcot関数の直線と曲線上の点の関係を可視化することで、周期性を確認します。\
\

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 120

# 変数の値を作成
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、`frame_num`個の $\theta$ の値を作成します。`theta_i`の範囲が $2 \pi$ の倍数だと、アニメーションの最後と最初のフレームの繋がりが良くなります。\
\

　「グラフの作成」のときと同様に、2つの方法で図示します。\
\


##### パターン1

　1つ目の方法では、単位円の図上で横軸を縦軸に変換してcot関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# グラフサイズ用の値を設定
axis_size <- 3

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    cot_t = 1/tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0, 1/tan(theta)), 
    y_from = c(0, 0, 0, 0), 
    x_to = c(1, cos(theta), 0, 1/tan(theta)), 
    y_to = c(0, sin(theta), 1, 1), 
    type = c("normal", "normal", "thin", "thin") # 太さ用
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "cot", "cot", "cot", 
      "tan", 
      "sin", "sin", 
      "cos", "cos", 
      "exsec", 
      "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 0, 
      1, 
      0, cos(theta), 
      0, 0, 
      cos(theta), 
      cos(theta)
    ), 
    y_from = c(
      0, 1, 0, 
      0, 
      0, 0, 
      0, sin(theta), 
      sin(theta), 
      sin(theta)
    ), 
    x_to = c(
      1/tan(theta), 1/tan(theta), 0, 
      1, 
      0, cos(theta), 
      cos(theta), cos(theta), 
      1, 
      1/tan(theta)
    ), 
    y_to = c(
      0, 1, 1/tan(theta), 
      tan(theta), 
      sin(theta), sin(theta), 
      0, sin(theta), 
      tan(theta), 
      1
    ), 
    linewidth = c(
      "bold", "normal", "bold", 
      "normal", 
      "normal", "normal", 
      "thin", "normal", 
      "bold", 
      "thin"), # 太さ用
    linetype = c(
      "main", "main", "sub", 
      "main", 
      "main", "main", 
      "main", "main", 
      "main", 
      "main") # 線タイプ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / tan(theta), 
      1, 
      0, 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1), 
      0.5 * (cos(theta) + 1/tan(theta))
    ), 
    y = c(
      1, 
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta)), 
      0.5 * (sin(theta) + 1)
    ), 
    angle = c(0, 90, 90, 0, 0, 0), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
    v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
  )
  
  # 変換曲線の先端の座標を格納
  adapt_point_df <- tibble::tibble(
    x = c(1/tan(theta), 0), 
    y = c(0, 1/tan(theta))
  )
  
  # 軸変換曲線の描画用
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = 1/tan(theta) * cos(rad), 
    y = 1/tan(theta) * sin(rad)
  )
  
  # cot曲線との対応線の座標を格納
  l <- 0.9
  segment_circle_df <- tibble::tibble(
    x = 0, 
    x_to = -axis_size-l, 
    y = 1/tan(theta)
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = adapt_point_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cot関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = type)) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = linewidth, linetype = linetype)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = h, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_path(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 変換曲線
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y), 
                 size = 1, linetype = "dotted") + # cot曲線との対応線
    scale_linetype_manual(breaks = c("main", "sub"), 
                          values = c("solid", "twodash"), guide ="none") + # (線が重なる対策)
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 関数曲線の作図処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
  
  # cot関数を計算
  cot_df <- tibble::tibble(
    t = theta_vec, 
    cot_t = 1/tan(t)
  ) |> 
    dplyr::mutate(
      cot_t = dplyr::if_else(
        condition = (cot_t >= -axis_size & cot_t <= axis_size), 
        true = cot_t, 
        false = NA_real_
      ) # 閾値外の値を欠損値に置換
    )
  
  # cot直線との対応線の座標を格納
  l <- 0.5
  d <- 1.1
  segment_cot_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(1/tan(theta), 1/tan(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-axis_size*d, 1/tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cot_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # cot関数曲線を作図
  cot_graph <- ggplot() + 
    geom_line(data = cot_df, 
              mapping = aes(x = t, y = cot_t), 
              size = 1, na.rm = TRUE) + # cot曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cot_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cot_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cotangent function", 
         subtitle = parse(text = cot_label), 
         x = expression(theta), 
         y = expression(cot~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(cot_graph, circle_graph)
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 800, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　cot関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cot_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cot_ncycle.gif)

　先ほどと同様にして、gifファイルを作成します。\

　単位円上の点が半周する $\pi$ の間隔で、曲線が同じ形になるのが分かります。\
\


##### パターン2

　2つ目の方法では、横軸を縦軸に変換する図を挟んでcot関数とtan関数を並べて可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　`theta_i`から順番に値を取り出してグラフを作成し、画像ファイルとして書き出す処理を繰り返します。

```{r, eval=FALSE}
# 一時保存フォルダを指定
dir_path <- "../figure/tmp_folder"

# 関数ラベルのレベルを指定
fnc_level_vec <- c("cot", "tan", "sin", "cos", "exsec", "excsc")

# グラフサイズ用の値を設定
axis_size <- 3
w_per_h <- pi / axis_size

# 軸変換図のグリッド線の描画用
d <- 1
adapt_grid_df <- tidyr::expand_grid(
  d = seq(from = d, to = 2*axis_size, by = d), # グリッド線の位置
  rad = seq(from = 0, to = 0.5*pi, length.out = 100)
) |> # グリッド線の数に応じてラジアンを複製
  dplyr::mutate(
    x = -axis_size + d * cos(rad), 
    y = -axis_size + d * sin(rad)
  )

# 変数ごとに作図
for(i in 1:frame_num) {
  
  # i番目の値を取得
  theta <- theta_i[i]
  
  # 曲線上の点の座標を計算
  point_df <- tibble::tibble(
    t = theta, 
    sin_t = sin(theta), 
    cos_t = cos(theta), 
    tan_t = tan(theta), 
    cot_t = 1/tan(theta)
  )
  
  ## 単位円上の関数直線の作図処理
  
  # 角マークの座標を計算
  d <- 0.15
  angle_mark_df <- tibble::tibble(
    t = seq(from = 0, to = theta, length.out = 100), 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 角ラベルの座標を計算
  d <- 0.25
  angle_label_df <- tibble::tibble(
    t = 0.5 * theta, 
    x = d * cos(t), 
    y = d * sin(t)
  )
  
  # 半径の線分の座標を格納
  radius_df <- tibble::tibble(
    x_from = c(0, 0, 0, 1/tan(theta)), 
    y_from = c(0, 0, 0, 0), 
    x_to = c(1, cos(theta), 0, 1/tan(theta)), 
    y_to = c(0, sin(theta), 1, 1), 
    type = c("normal", "normal", "thin", "thin") # 太さ用
  )
  
  # 関数直線の線分の座標を格納
  function_line_df <- tibble::tibble(
    fnc = c(
      "cot", "cot", 
      "tan", 
      "sin", "sin", 
      "cos", "cos", 
      "exsec", 
      "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x_from = c(
      0, 0, 
      1, 
      0, cos(theta), 
      0, 0, 
      cos(theta), 
      cos(theta)
    ), 
    y_from = c(
      0, 1, 
      0, 
      0, 0, 
      0, sin(theta), 
      sin(theta), 
      sin(theta)
    ), 
    x_to = c(
      1/tan(theta), 1/tan(theta), 
      1, 
      0, cos(theta), 
      cos(theta), cos(theta), 
      1, 
      1/tan(theta)
    ), 
    y_to = c(
      0, 1, 
      tan(theta), 
      sin(theta), sin(theta), 
      0, sin(theta), 
      tan(theta), 
      1
    ), 
    type = c(
      "bold", "normal", 
      "normal", 
      "normal", "normal", 
      "thin", "normal", 
      "bold", 
      "thin") # 太さ用
  )
  
  # 関数ラベルの座標を格納
  function_label_df <- tibble::tibble(
    fnc = c("cot", "tan", "sin", "cos", "exsec", "excsc") |> 
      factor(levels = fnc_level_vec), # 色用
    x = c(
      0.5 / tan(theta), 
      1, 
      0, 
      0.5 * cos(theta), 
      0.5 * (cos(theta) + 1), 
      0.5 * (cos(theta) + 1/tan(theta))
    ), 
    y = c(
      1, 
      0.5 * tan(theta), 
      0.5 * sin(theta), 
      0, 
      0.5 * (sin(theta) + tan(theta)), 
      0.5 * (sin(theta) + 1)
    ), 
    angle = c(0, 90, 90, 0, 0, 0), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.1, -0.1), 
    v = c(-0.5, 1, -0.5, 1, 0.5, 0.5), 
    fnc_label = c("cot~theta", "tan~theta", "sin~theta", "cos~theta", "exsec~theta", "excsc~theta") # 関数ラベル
  )
  
  # 軸変換曲線との対応線の座標を格納
  l <- 0.9
  segment_circle_df <- tibble::tibble(
    x = c(1/tan(theta), 1), 
    y = c(0, tan(theta)), 
    x_to = c(1/tan(theta), -axis_size-l), 
    y_to = c(axis_size+l, tan(theta))
  )
  
  # 変数ラベル用の文字列を作成
  variable_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", sin~theta==", round(sin(theta), digits = 2), 
    ", cos~theta==", round(cos(theta), digits = 2), 
    ", exsec~theta==", round(1/cos(theta)-1, digits = 2), 
    ", excsc~theta==", round(1/sin(theta)-1, digits = 2), 
    ")"
  )
  
  # 単位円上の三角関数直線を作図
  circle_graph <- ggplot() + 
    geom_path(data = circle_df, 
              mapping = aes(x = x, y = y), 
              size = 1) + # 円周
    geom_segment(data = radian_lable_df, 
                 mapping = aes(x = 0, y = 0, xend = x, yend = y), 
                 color = "white") + # 角度目盛グリッド
    geom_text(data = radian_lable_df, 
              mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
              size = 2) + # 角度目盛指示線
    geom_text(data = radian_lable_df, 
              mapping = aes(x = label_x, y = label_y, label = rad_label, hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
    geom_hline(yintercept = 1, linetype = "dashed") + # cot直線用の補助線
    geom_point(data = point_df, 
               mapping = aes(x = cos_t, y = sin_t), 
               size = 4) + # 円周上の点
    geom_point(data = segment_circle_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # tan・cot関数の点
    geom_segment(data = radius_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               size = type)) + # 半径直線
    geom_path(data = angle_mark_df, 
              mapping = aes(x = x, y = y), 
              size = 0.5) + # 角マーク
    geom_text(data = angle_label_df, 
              mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
              size = 5) + # 角ラベル
    geom_segment(data = function_line_df, 
                 mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                               color = fnc, size = type)) + # 関数直線
    geom_text(data = function_label_df, 
              mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                            hjust = 0.5, vjust = v, angle = angle), parse = TRUE, show.legend = FALSE) + # 関数ラベル
    geom_segment(data = segment_circle_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # 軸変換曲線との対応線
    scale_size_manual(breaks = c("normal", "bold", "thin"), 
                      values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "circular functions", 
         subtitle = parse(text = variable_label), 
         color = "function", 
         x = "x", y = "y")
  
  ## 変数の作成処理
  
  # 作図用の変数の値を作成
  theta_size <- 2 * pi
  theta_min  <- theta - theta_size
  theta_vec  <- seq(from = max(min(theta_i), theta_min), to = theta, length.out = 1000)
  
  # 目盛ラベル用の文字列を作成
  denom <- 6
  numer_vec <- seq(
    from = floor(theta_min / pi * denom), 
    to = ceiling(theta / pi * denom), 
    by = 1
  )
  label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")

  # tan・cot関数を計算
  curve_df <- tibble::tibble(
    t = theta_vec, 
    tan_t = tan(t), 
    cot_t = 1/tan(t)
  ) |> 
    dplyr::mutate(
      tan_t = dplyr::if_else(
        condition = (tan_t >= -axis_size & tan_t <= axis_size), 
        true = tan_t, 
        false = NA_real_
      ), 
      cot_t = dplyr::if_else(
        condition = (cot_t >= -axis_size & cot_t <= axis_size), 
        true = cot_t, 
        false = NA_real_
      )
    ) # 閾値外の値を欠損値に置換
  
  ## tan関数曲線の作図処理
  
  # tan直線との対応線の座標を格納
  l <- 0.9
  d <- 1.1
  segment_tan_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(axis_size*d, tan(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(axis_size*d+l, tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  tan_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", tan~theta==", round(tan(theta), digits = 2), 
    ")"
  )
  
  # tan関数曲線を作図
  tan_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = tan_t), 
              size = 1, na.rm = TRUE) + # tan曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = tan_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_tan_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # tan直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "tangent function", 
         subtitle = parse(text = tan_label), 
         x = expression(theta), 
         y = expression(tan~theta))
  
  ## 軸変換図の作図処理
  
  # cot関数の軸変換曲線の座標を計算
  adapt_line_df <- tibble::tibble(
    rad = seq(from = 0, to = 0.5*pi, length.out = 100), 
    x = -axis_size + (axis_size+1/tan(theta)) * cos(rad), 
    y = -axis_size + (axis_size+1/tan(theta)) * sin(rad)
  ) |> 
    dplyr::mutate(
      x = dplyr::if_else(
        condition = x >= -axis_size, 
        true = x, 
        false = NA_real_
      ), 
      y = dplyr::if_else(
        condition = y >= -axis_size, 
        true = y, 
        false = NA_real_
      )
    ) # 描画領域外の値を欠損値に置換
  
  # cot曲線・直線との対応線の座標を格納
  l <- 1.2
  segment_adapt_df <- tibble::tibble(
    x = c(1/tan(theta), -axis_size), 
    y = c(-axis_size, 1/tan(theta)), 
    x_to = c(1/tan(theta), -axis_size-l), 
    y_to = c(-axis_size-l, 1/tan(theta))
  )
  
  # 軸の変換曲線を作図
  adapt_graph <- ggplot() + 
    geom_line(data = adapt_grid_df, 
              mapping = aes(x = x, y = y, group = d), 
              color = "white") + # グリッド線
    geom_line(data = adapt_line_df, 
              mapping = aes(x = x, y = y), 
              size = 1, linetype = "dotted") + # 軸変換曲線
    geom_point(data = segment_adapt_df, 
               mapping = aes(x = x, y = y), 
               size = 4) + # cot関数の点
    geom_segment(data = segment_adapt_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線・曲線との対応線
    #theme(panel.grid = element_blank()) + # 元のグリッド線を非表示
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(x = "x", y = "x")
  
  ## cot関数曲線の作図処理
  
  # 変換曲線との対応線の座標を格納
  l <- 0.9
  d <- 1.1
  segment_cot_df <- tibble::tibble(
    x = c(theta, theta), 
    y = c(-axis_size*d, 1/tan(theta)), 
    x_to = c(theta, theta+l), 
    y_to = c(-axis_size*d-l, 1/tan(theta))
  )
  
  # 関数ラベル用の文字列を作成
  cot_label <- paste0(
    "list(", 
    "theta==", round(theta/pi, digits = 2), "*pi", 
    ", cot~theta==", round(1/tan(theta), digits = 2), 
    ")"
  )
  
  # cot関数曲線を作図
  cot_graph <- ggplot() + 
    geom_line(data = curve_df, 
              mapping = aes(x = t, y = cot_t), 
              size = 1, na.rm = TRUE) + # cot曲線
    geom_point(data = point_df, 
               mapping = aes(x = t, y = cot_t), 
               size = 4) + # 曲線上の点
    geom_segment(data = segment_cot_df, 
                 mapping = aes(x = x, y = y, xend = x_to, yend = y_to), 
                 size = 1, linetype = "dotted") + # cot直線との対応線
    geom_vline(xintercept = theta, size = 1, linetype = "dotted") + # x軸との対応線
    scale_x_continuous(breaks = numer_vec/denom*pi, 
                       labels = parse(text = label_vec)) + # 角度目盛ラベル
    coord_fixed(ratio = 1, clip = "off", 
                xlim = c(theta_min, theta), ylim = c(-axis_size, axis_size)) + # 描画領域
    labs(title = "cotangent function", 
         subtitle = parse(text = cot_label), 
         x = expression(theta), 
         y = expression(cot~theta))
  
  # 並べて描画
  graph <- patchwork::wrap_plots(
    cot_graph, adapt_graph, 
    tan_graph, circle_graph, 
    nrow = 2, ncol = 2, widths = c(w_per_h, 1, w_per_h, 1), heights = c(1, 1, 1, 1)
  )
  
  # ファイルを書き出し
  file_path <- paste0(dir_path, "/", stringr::str_pad(i, width = nchar(frame_num), pad = "0"), ".png")
  ggplot2::ggsave(filename = file_path, plot = graph, width = 1500, height = 1500, units = "px", dpi = 100)
  
  # 途中経過を表示
  message("\r", i, " / ", frame_num, appendLF = FALSE)
}
```

　「1周期」のときと同様に処理します。こちらは、軸目盛の関係から上下左右の図を入れ替えます。そのため、対応線の方向などが変わっています。\

</details>

　cot関数とtan関数のアニメーションを作成します。

```{r, eval=FALSE}
# gif画像を作成
paste0(dir_path, "/", stringr::str_pad(1:frame_num, width = nchar(frame_num), pad = "0"), ".png") |> # ファイルパスを作成
  magick::image_read() |> # 画像ファイルを読込
  magick::image_animate(fps = 1, dispose = "previous") |> # gif画像を作成
  magick::image_write_gif(path = "../figure/curves/cot_tan_ncycle.gif", delay = 0.1) -> tmp_path # gifファイル書き出し
```

![](../figure/curves/cot_tan_ncycle.gif)

\ 

　この記事では、cot関数を可視化しました。次の記事では、ここまでで扱った6つの関数を可視化します。\
\


# 円関数(三角関数)の可視化

　三角関数(trigonometric functions)・円関数(circular functions)の6つの関数(sin関数・cos関数・tan関数・cot関数・sec関数・csc関数)をグラフで確認します。各関数についてはそれぞれの記事を参照してください。\
　(この記事では信仰上の理由により、三角関数ではなく円関数と呼びます。)\
\

　Rを使って作図を行います。\

<details><summary>・作図コード(クリックで展開)</summary>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
library(patchwork)
library(magick)
```

```{r, echo=FALSE}
### 資料作成用:(チェック用)

library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`を読み込む必要があります。\
　また、ネイティブパイプ演算子`|>`を使っています。`magrittr`パッケージのパイプ演算子`%>%`に置き換えても処理できますが、その場合は`magrittr`も読み込む必要があります。\

</details>

\ 


## 定義式の確認

　まずは、4つの円関数の定義式を確認します。\
\

　円関数は、それぞれsin関数またはcos関数を用いて、次の式で定義されます。

$$
\begin{aligned}
\tan x
   &= \frac{\sin x}{\cos x}
\\
\cot x
   &= \frac{1}{\tan x}
    = \frac{\cos x}{\sin x}
\\
\sec x
   &= \frac{1}{\cos x}
\\
\csc x
   &= \frac{1}{\sin x}
\end{aligned}
$$

　ただし、$i$ を整数として $x = i \pi$ のとき $\sin x = \tan x = 0$ なので、$\csc x, \cot x$ は定義できません。また、$x = \frac{2 i + 1}{2} \pi$ のとき $\cos x = 0$ なので、$\tan x, \sec x$ は定義できません。$\pi$ は円周率で、変数 $x$ は弧度法の角度(ラジアン)です。\
\


## 円関数の作図

　次に、6つの円関数のグラフを作成します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　変数の範囲を指定します。

```{r}
# 変数(ラジアン)の範囲を指定
theta_vec <- seq(from = -2.5*pi, to = 2.5*pi, length.out = 1000)
head(theta_vec)
```

　曲線の座標計算用の変数(ラジアン) $\theta$ を作成して`theta_vec`とします。円周率 $\pi$ は`pi`で扱えます。\

　関数曲線の描画用のデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("sin", "cos", "tan", "csc", "sec", "cot")

# 閾値を指定
threshold <- 4

# 関数曲線の座標を計算
function_curve_df <- tibble::tibble(
  t = theta_vec |> 
    rep(times = length(fnc_level_vec)), # 関数の数に応じて変数を複製
  f_t = c(
    sin(theta_vec), 
    cos(theta_vec), 
    tan(theta_vec), 
    1/sin(theta_vec), 
    1/cos(theta_vec), 
    1/tan(theta_vec)
  ), 
  fnc = c("sin", "cos", "tan", "csc", "sec", "cot") |> 
    rep(each = length(theta_vec)) |> 
    factor(levels = fnc_level_vec), # 色用
  fnc_pair = c("sin", "cos", "tan", "sin", "cos", "tan") |> 
    rep(each = length(theta_vec)) |> 
    factor(levels = c("sin", "cos", "tan")), # 色用
  fnc_type = c("original", "original", "original", "reciprocal", "reciprocal", "reciprocal") |> 
    rep(each = length(theta_vec)) # 線種用
) |> 
  dplyr::mutate(
    f_t = dplyr::if_else(
      (f_t >= -threshold & f_t <= threshold), true = f_t, false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
function_curve_df
```

　変数 $\theta$ の値と関数 $f(\theta)$ の値をデータフレームに格納します。csc関数は`sin()`、sec関数は`cos()`、cot関数は`tan()`を使って計算できます。\
　$\theta = i \pi$ や $\theta = \frac{2 i + 1}{2} \pi$ ($i$ は整数)付近で $-\infty$ または $\infty$ に近付くので、閾値`threshold`を指定しておき、`-threshold`未満または`threshold`より大きい場合は(数値型の)欠損値`NA`に置き換えます。\

　x軸の角度目盛の描画用のベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 2

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(
  from = floor(min(theta_vec) / pi * denom), 
  to   = ceiling(max(theta_vec) / pi * denom), 
  by = 1
)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　角度(ラジアン) $\theta$ に関する軸目盛ラベルを $\frac{i}{n} \pi$ ($i, n$ は整数)の形で表示することにします。\
　$n$ を`denom`として整数を指定します。$n$ は、半周期 $\pi$ の範囲における目盛の数に対応します。`theta_vec`に対して、$\theta = \frac{\pi}{n} i$ を $i$ について整理した $i = \frac{n}{\pi} \theta$ を計算して、最小値(の小数部分を`floor()`で切り捨てた値)から最大値(の小数部分を`ceiling()`で切り上げた値)までの整数を作成して`numer_vec`とします。\
　`numer_vec, denom`を使って目盛ラベル用の文字列を作成します。ギリシャ文字などの記号や数式を表示する場合は、`expression()`の記法を用います。オブジェクト(プログラム上の変数)の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。`frac(分子, 分母)`で分数、`~`でスペースを表示します。\

　漸近線の描画用のベクトルを作成します。

```{r}
# 漸近線のプロット位置を作成
asymptote_even_vec <- seq(
  from = floor(min(theta_vec) / pi) + 0.5, 
  to   = floor(max(theta_vec) / pi) + 0.5, 
  by = 1
) * pi
asymptote_odd_vec <- seq(
  from = floor(min(theta_vec) / pi) + 1, 
  to   = floor(max(theta_vec) / pi), 
  by = 1
) * pi

# 漸近線の座標を格納
asymptote_df <- tibble::tibble(
  value = c(
    asymptote_even_vec, 
    asymptote_odd_vec
  ), 
  type = c(
    rep("even", times = length(asymptote_even_vec)), 
    rep("odd", times = length(asymptote_odd_vec))
  ) # 線種用
)
asymptote_df
```

　$\theta = i \pi$ ($\pi$ の倍数)のとき $\csc x, \cot x$、$\theta = \frac{2 i + 1}{2} \pi$ ($\pi$ の倍数でない $\frac{\pi}{2}$ の倍数)のとき $\tan x, \sec x$ が発散するので、`theta_vec`の範囲内の $i \pi, \frac{2 i}{2} \pi$ の値を(上手いこと)作成して、データフレームに格納します。\

　円関数のグラフを作成します。

```{r, fig.width=12, fig.height=6, dpi=100}
# 軸目盛のプロット位置を計算
break_vec <- numer_vec / denom * pi

# 関数曲線を作図
curve_graph <- ggplot() + 
  geom_vline(data = asymptote_df, 
             mapping = aes(xintercept = value, linetype = type)) + # 漸近線
  geom_line(data = function_curve_df, 
            mapping = aes(x = t, y = f_t, color = fnc), na.rm = TRUE, 
            size = 1, alpha = 0.8) + # 関数曲線
  scale_x_continuous(breaks = break_vec, labels = round(break_vec, digits = 2), 
                     sec.axis = sec_axis(trans = ~., 
                                         breaks = break_vec, labels = parse(text = label_vec))) + # 目盛ラベル
  scale_linetype_manual(breaks = c("even", "odd"), 
                        values = c("dotdash", "twodash"), 
                        labels = c(expression(i*pi), expression(frac(2*i+1, 2)*pi)), 
                        name = "asymptote") + # (2種類の漸近線用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "circular functions", 
       color = "function", 
       x = expression(theta), 
       y = expression(f(theta)))
#curve_graph
```

```{r, fig.width=12, fig.height=6, dpi=100}
# 関数曲線を作図
curve_pair_graph <- ggplot() + 
  geom_vline(data = asymptote_df, 
             mapping = aes(xintercept = value), 
             linetype = "dotdash") + # 漸近線
  geom_line(data = function_curve_df, 
            mapping = aes(x = t, y = f_t, color = fnc_pair, linetype = fnc_type), na.rm = TRUE, 
            size = 1, alpha = 0.8) + # 関数曲線
  scale_x_continuous(breaks = break_vec, labels = round(break_vec, digits = 2), 
                     sec.axis = sec_axis(trans = ~., 
                                         breaks = break_vec, labels = parse(text = label_vec))) + # 目盛ラベル
  scale_linetype_manual(breaks = c("original", "reciprocal"), 
                        values = c("solid", "dashed"), 
                        labels = c(expression(f(x)), expression(frac(1, f(x)))), 
                        name = "function") + # (2種類の漸近線用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "circular functions", 
       color = "function", 
       x = expression(theta), 
       y = expression(f(theta)))
#curve_pair_graph
```

</details>

```{r, echo=FALSE, fig.width=12, fig.height=6, dpi=100}
### 資料作成用:(出力)

curve_graph
curve_pair_graph
```

　x軸を変数(ラジアン) $\theta$、y軸を各関数 $f(\theta)$ として曲線を描画します。また、基本となる関数 $\sin \theta, \cos, \theta, \tan \theta$ を実線、それぞれの逆数 $\csc \theta, \sec \theta, \cot \theta$ を破線で示します。\
　x軸が $i \pi$ の点($0$ の前後 $\pi$ 間隔) $\frac{2 i + 1}{2} \pi$ の点($\frac{\pi}{2}$ の前後 $\pi$ 間隔)に漸近線を破線で描画します。\
　元の関数と逆数とで何となくひっくり返したような形で、元の関数が0のとき漸近線(不連続)になるのが分かります。\
\


## 単位円の作図

　続いて、円関数の可視化に利用する単位円(unit circle)のグラフを確認します。円やラジアン(弧度法の角度)、度数法と弧度法の関係については「円周の作図」を参照してください。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　単位円の描画用のデータフレームを作成します。

```{r}
# 半径を指定
r <- 1

# 円周の座標を計算
circle_df <- tibble::tibble(
  t = seq(from = 0, to = 2*pi, length.out = 601), # ラジアン
  x = r * cos(t), 
  y = r * sin(t)
)
circle_df
```

　単位円の円周の座標計算用のラジアンとして $0 \leq t \leq 2 \pi$ の範囲の値を作成して、x軸の値 $x = \cos t$ とy軸の値 $y = \sin t$ を計算します。\

　角度目盛の描画用のデータフレームを作成します。

```{r}
# 半円の目盛の数(分母の値)を指定
denom <- 6

# 角度目盛の描画用
d <- 1.1
radian_lable_df <- tibble::tibble(
  nomer = seq(from = 0, to = 2*denom-1, by = 1), # 目盛の通し番号(分子の値)を作成
  t_deg = nomer / denom * 180, # 度数法
  t_rad = nomer / denom * pi,  # 弧度法
  x = r * cos(t_rad), 
  y = r * sin(t_rad), 
  label_x = d * x, 
  label_y = d * y, 
  rad_label = paste0("frac(", nomer, ", ", denom, ")~pi"), # ラジアンラベル
  h = 1 - (x * 0.5 + 0.5), 
  v = 1 - (y * 0.5 + 0.5)
)
radian_lable_df
```

　目盛指示線や目盛グリッド用の座標を`x, y`列、目盛ラベル用の座標を`label_x, label_y`列とします。ラベルの表示位置を`d`で調整します。\

　円周と角度目盛のグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# グラフサイズを指定
axis_size <- 1.5

# 円周を作図
circle_graph <- ggplot() + 
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               linetype = "dotted") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), 
            label = "|", size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "unit circle", 
       subtitle = parse(text = paste0("r==", r)), 
       x = expression(x == r~cos~theta), 
       y = expression(y == r~sin~theta))
#circle_graph
```

</details>

```{r, echo=FALSE, fig.width=6, fig.height=6, dpi=100}
### 資料作成用:(出力)

circle_graph
```

　このグラフ上に円関数の値を直線として描画します。\
\


## なす角と円関数の関係

　次は、単位円上におけるなす角と円関数(sin・cos・tan・cot・sec・csc)の関係をグラフで可視化します。関数の値を線分の長さと座標の正負に対応させます。\
\


### グラフの作成

　変数を固定した円関数をグラフで確認します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　変数の値を指定して、円周上の点の描画用のデータフレームを作成します。

```{r}
# なす角(変数)を指定
theta <- 1/6 * pi

# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)
point_df
```

　単位円におけるなす角(ラジアン) $\theta$ を`theta`として値を指定します。ただし、`theta`が`0`のとき、計算結果に`Inf`や`-Inf`が含まれるため、意図しないグラフになります(理論上は`pi`などのときにも発散しますが、プログラム上の誤差により`Inf`になりません)。発散時の対策については「アニメーションの作成」を参照してください。\

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をデータフレームに格納します。\

　なす角マークの描画用のデータフレームを作成します。

```{r}
# なす角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_mark_df
```

　なす角 $\theta$ を示すなす角マークを描画するために、$0 \leq t \leq \theta$ のラジアンを作成して、円弧の座標を計算します。サイズの調整用の値(半径)を`d`とします。\

　なす角ラベルの描画用のデータフレームを作成します。

```{r}
# なす角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
angle_label_df
```

　なす角マークの中点にラベルを配置するために、$t = \frac{\theta}{2}$ のラジアンを作成して、円弧上の点の座標を計算します。表示位置の調整用の値(原点からのノルム)を`d`とします。\

</details>

\ 

　ここまでは、共通の処理です。ここからは、2つの方法で図示します。\
\


#### パターン1

　1つ目の方法では、原点と円周上の点を結ぶ線分を斜辺として各関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径と円関数を示す線分の描画用のデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("r", "sin", "cos", "tan", "cot", "sec", "csc")

# 反転フラグを設定
sin_flag <- sin(theta) >= 0
cos_flag <- cos(theta) >= 0

# 関数直線の線分の座標を計算
function_line_df <- tibble::tibble(
  fnc = c(
    "r", "r", "r", "r", "r", 
    "sin", "sin", 
    "cos", "cos", 
    "tan", "tan", 
    "cot", "cot", "cot", "cot", 
    "sec", "sec", 
    "csc", "csc"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 0, 
    0, cos(theta), 
    0, 0, 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    0, 0, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 0), 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 
    0, ifelse(test = cos_flag, yes = NA, no = 0)
  ), 
  y_from = c(
    0, 0, 0, ifelse(test = cos_flag, yes = NA, no = 0), 0, 
    0, 0, 
    0, sin(theta), 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 
    0, 1, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 1), 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 
    0, ifelse(test = cos_flag, yes = NA, no = 0)
  ), 
  x_to = c(
    1, cos(theta), 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 0, 
    0, cos(theta), 
    cos(theta), cos(theta), 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    1/tan(theta), 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    ifelse(test = cos_flag, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flag, yes = NA, no = 1/tan(theta))
  ), 
  y_to = c(
    0, sin(theta), 1, ifelse(test = cos_flag, yes = NA, no = 1), 1, 
    sin(theta), sin(theta), 
    0, sin(theta), 
    tan(theta), ifelse(test = sin_flag, yes = NA, no = -tan(theta)), 
    0, 1, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 1), 
    ifelse(test = sin_flag, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flag, yes = NA, no = tan(theta)), 
    1, ifelse(test = cos_flag, yes = NA, no = 1)
  ), 
  width = c(
    "normal", "normal", "thin", "thin", "thin", 
    "normal", "normal", 
    "bold", "normal", 
    "normal", "normal", 
    "thin", "normal", "thin", "normal", 
    "bold", "bold", 
    "thin", "thin"
  ), # 太さ用
  type = c(
    "main", "main", "sub", "sub", "sub", 
    "main", "main", 
    "main", "main", 
    "main", "sub", 
    "main", "main", "sub", "sub", 
    "main", "sub", 
    "main", "sub"
  ) # 線種用
)
function_line_df
```

　関数を区別するための`fnc`列の因子レベルを`fnc_level_vec`として指定しておきます。因子レベルは、線分の描画順(重なり順)や色付け順に影響します。\
　各線分の始点の座標を`x_from, y_from`列、終点の座標を`x_to, y_to`列として、完成図を見ながら頑張って指定します。詳しくはそれぞれの関数の記事を参照してください。\

　関数名(ラベル)の描画用のデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
function_label_df <- tibble::tibble(
  fnc = c(
    "sin", 
    "cos", 
    "tan", "tan", 
    "cot", "cot", 
    "sec", "sec", 
    "csc", "csc"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    0, 
    0.5 * cos(theta), 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    0.5 / tan(theta), ifelse(test = cos_flag, yes = NA, no = -0.5/tan(theta)), 
    0.5, ifelse(test = sin_flag, yes = NA, no = 0.5), 
    0.5 / ifelse(test = cos_flag, yes = tan(theta), no = -tan(theta)), ifelse(test = cos_flag, yes = NA, no = 0.5/tan(theta))
  ), 
  y = c(
    0.5 * sin(theta), 
    0, 
    0.5 * tan(theta), ifelse(test = sin_flag, yes = NA, no = -0.5*tan(theta)), 
    1, ifelse(test = cos_flag, yes = NA, no = 1), 
    0.5 * ifelse(test = sin_flag, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flag, yes = NA, no = 0.5*tan(theta)), 
    0.5, ifelse(test = cos_flag, yes = NA, no = 0.5)
  ), 
  angle = c(
    90, 
    0, 
    90, 90, 
    0, 0, 
    0, 0, 
    0, 0
  ), 
  h = c(
    0.5, 
    0.5, 
    0.5, 0.5, 
    0.5, 0.5, 
    1.2, 1.2, 
    -0.2,-0.2
  ), 
  v = c(
    -0.5, 
    1, 
    1, 1, 
    -0.5, -0.5, 
    0.5, 0.5, 
    0.5, 0.5
  ), 
  fnc_label = c(
    "sin~theta", 
    "cos~theta", 
    "tan~theta", "-tan~theta", 
    "cot~theta", "-cot~theta", 
    "sec~theta", "-sec~theta", 
    "csc~theta", "-csc~theta"
  ) # 関数ラベル
)
function_label_df
```

　この例では、関数を示す線分の中点に関数名を表示するため、中点の座標とラベル用の文字列などを格納します。\
　ラベルの表示角度を`angle`列、表示角度に応じた左右の表示位置を`h`列、上下の表示位置を`v`列として値を指定します。\

　変数と関数の値(ラベル)の表示用の文字列を作成します。

```{r}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ", sec~theta==", round(1/cos(theta), digits = 2), 
  ", csc~theta==", round(1/sin(theta), digits = 2), 
  ")"
)
variable_label
```

　`==`で等号、`list(変数1, 変数2)`で複数の(数式上の)変数を並べて表示します。(プログラム上の)変数の値を使う場合は、文字列として作成しておき`parse()`の`text`引数に渡します。\

　単位円上に円関数の線分を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
axis_lower <- 1.5
x_min <- min(-axis_lower, 1/tan(theta))
x_max <- max(axis_lower, 1/tan(theta))
y_min <- min(-axis_lower, tan(theta))
y_max <- max(axis_lower, tan(theta))

# 単位円上に関数直線を作図
fnc_line_graph <- ggplot() + 
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # なす角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # なす角ラベル
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_hline(yintercept = 1, linetype = "dashed") + # 補助線
  geom_vline(xintercept = 1, linetype = "dashed") + # 補助線
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_color_manual(breaks = fnc_level_vec, 
                     values = c("black", scales::hue_pal()(length(fnc_level_vec)-1))) + # (半径直線を黒色にしたい)
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線を描き分けたい)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
#fnc_line_graph
```

　`geom_segment()`で線分を描画して、各関数の値を直線で示します。\
　`geom_label()`でラベル(文字列)を描画します。\

</details>

```{r, echo=FALSE, fig.width=8, fig.height=8, dpi=100}
### 資料作成用:(出力)

fnc_line_graph
```

　「x軸線の正の部分(原点 $(0, 0)$ と点 $(0, 1)$ を結ぶ線分)」と「原点と円周上の点を結ぶ線分」のなす角を $\theta$ とします。単位円の円周上の点の座標は $(\cos \theta, \sin \theta)$ なので、sin関数はy軸の値(高さ)、cos関数はx軸の値(横幅)に対応します。他の関数についても円周上の点(なす角)によって決まります。詳しくはそれぞれの関数の記事を参照してください。\
\


#### パターン2

　2つ目の方法では、原点と円周上の点を結ぶ線分を底辺として各関数を可視化します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　半径と円関数を示す線分の描画用のデータフレームを作成します。

```{r}
# 関数直線の線分の座標を計算
function_line_df <- tibble::tibble(
  fnc = c(
    "r", "r", 
    "sin", 
    "cos", 
    "tan", 
    "cot", 
    "sec", 
    "csc"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 
    cos(theta), 
    0, 
    cos(theta), 
    cos(theta), 
    0, 
    0
  ), 
  y_from = c(
    0, 0, 
    0, 
    sin(theta), 
    sin(theta), 
    sin(theta), 
    0, 
    0
  ), 
  x_to = c(
    1, cos(theta), 
    cos(theta), 
    cos(theta), 
    1/cos(theta), 
    0, 
    1/cos(theta), 
    0
  ), 
  y_to = c(
    0, sin(theta), 
    sin(theta), 
    sin(theta), 
    0, 
    1/sin(theta), 
    0, 
    1/sin(theta)
  )
)
function_line_df
```

　「パターン1」のときと同様に、半径と関数の線分の座標を格納します。\

　関数名(ラベル)の描画用のデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
function_label_df <- tibble::tibble(
  fnc = c("sin", "cos", "tan", "cot", "sec", "csc") |> 
    factor(levels = fnc_level_vec), # 色用
  x = c(
    cos(theta), 
    0.5 * cos(theta), 
    0.5 * (1/cos(theta) + cos(theta)), 
    0.5 * cos(theta), 
    0.5 / cos(theta), 
    0
  ), 
  y = c(
    0.5 * sin(theta), 
    sin(theta), 
    0.5 * sin(theta), 
    0.5 * (1/sin(theta) + sin(theta)), 
    0, 
    0.5 / sin(theta)
  ), 
  angle = c(90, 0, 0, 0, 0, 90), 
  h = c(0.5, 0.5, -0.2, -0.2, 0.5, 0.5), 
  v = c(-0.5, -0.5, 0.5, 0.5, 1, 1), 
  fnc_label = c("sin~theta", "cos~theta", "tan~theta", "cot~theta", "sec~theta", "csc~theta") # 関数ラベル
)
function_label_df
```

　線分の中点の座標とラベル用の文字列などを格納します。\

　単位円上に円関数の線分を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8, dpi=100}
# グラフサイズ用の値を設定
axis_lower <- 1.5
x_min <- min(-axis_lower, 1/cos(theta))
x_max <- max(axis_lower, 1/cos(theta))
y_min <- min(-axis_lower, 1/sin(theta))
y_max <- max(axis_lower, 1/sin(theta))

# 単位円上に関数直線を作図
fnc_line_graph <- ggplot() + 
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # なす角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # なす角ラベル
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_hline(yintercept = 0, linetype = "dashed") + # 補助線
  geom_vline(xintercept = 0, linetype = "dashed") + # 補助線
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, show.legend = FALSE) + # 関数ラベル
  scale_color_manual(breaks = fnc_level_vec, 
                     values = c("black", scales::hue_pal()(length(fnc_level_vec)-1))) + # (半径直線を黒色にしたい)
  coord_fixed(ratio = 1, 
              xlim = c(x_min, x_max), ylim = c(y_min, y_max)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
#fnc_line_graph
```

</details>

```{r, echo=FALSE, fig.width=8, fig.height=8, dpi=100}
### 資料作成用:(出力)

fnc_line_graph
```

　こちらの図は、原点と点 $(\cos \theta, \sin \theta)$ を結ぶ線分を底辺、x軸線やy軸線の一部を斜辺としたときのパターン1の図と言えます。文字通り首を捻って見てください。相似関係が分かりやすいように補助線を入れた図については、それぞれの関数の記事を参照してください。\
\


### アニメーションの作成

　続いて、変数の値を変化させた円関数をアニメーションで確認します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　フレーム数を指定して、変数として用いる値を作成します。

```{r}
# フレーム数を指定
frame_num <- 180

# なす角(変数)の範囲を指定
theta_i <- seq(from = -2*pi, to = 2*pi, length.out = frame_num+1)[1:frame_num]
head(theta_i)
```

　フレーム数`frame_num`を指定して、単位円におけるなす角(ラジアン) $\theta$ の値を等間隔に`frame_num`個作成します。最小値(`form`引数)と最大値(`to`引数)の範囲を $2 \pi$ の倍数にし`frame_num + 1`個の等間隔の値を作成して、最後の値を除くと最後のフレームと最初のフレームのグラフが繋がります。\

　フレーム切替用のラベルの文字列ベクトルを作成します。

```{r}
# 変数ラベル用の文字列を作成
frame_label_vec <- paste0(
  "θ = ", round(theta_i/pi, digits = 2), " π", 
  ", sin θ = ", round(sin(theta_i), digits = 2), 
  ", cos θ = ", round(cos(theta_i), digits = 2), 
  ", tan θ = ", round(tan(theta_i), digits = 2), 
  ", cot θ = ", round(1/tan(theta_i), digits = 2), 
  ", sec θ = ", round(1/cos(theta_i), digits = 2), 
  ", csc θ = ", round(1/sin(theta_i), digits = 2)
)
head(frame_label_vec)
```

　この例では、フレームごとの変数と関数の値を表示するために、`theta_i`を用いた文字列をフレーム切替用のラベル列として使います。フレーム番号として、通し番号を用いても作図できます。\

　円周上の点の描画用のデータフレームを作成します。

```{r}
# 単位円上の点の座標を計算
anim_point_df <- tibble::tibble(
  t = theta_i, 
  sin_t = sin(theta_i), 
  cos_t = cos(theta_i), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_point_df
```

　$\theta$ の値と $\sin \theta, \cos \theta$ の値をフレームラベルと共に格納します。\

　なす角マークの描画用のデータフレームを作成します。

```{r}
# なす角マークの座標を計算
d <- 0.15
anim_angle_mark_df <- tibble::tibble(
  frame_i = 1:frame_num # フレーム番号
) |> 
  dplyr::group_by(frame_i) |> # ラジアンの作成用
  dplyr::summarise(
    t = seq(from = 0, to = theta_i[frame_i], length.out = 100), .groups = "drop"
  ) |> # なす角以下のラジアンを作成
  dplyr::mutate(
    x = d * cos(t), 
    y = d * sin(t), 
    frame_label = frame_label_vec[frame_i] |> 
      factor(levels = frame_label_vec) # フレーム切替用ラベル
  )
anim_angle_mark_df
```

　フレーム番号(とフレームラベル)を格納しフレーム列でグループ化して、フレーム(変数の値)ごとに`summarise()`を使って`0`からなす角`theta_n[frame_i]`までの値(ラジアン)を作成して、円弧の座標を計算します。\

　なす角ラベルの描画用のデータフレームを作成します。

```{r}
# なす角ラベルの座標を計算
d <- 0.21
anim_angle_label_df <- tibble::tibble(
  frame_i = 1:frame_num, # フレーム番号
  t = 0.5 * theta_i, 
  x = d * cos(t), 
  y = d * sin(t), 
  frame_label = factor(frame_label_vec, levels = frame_label_vec) # フレーム切替用ラベル
)
anim_angle_label_df
```

　フレームごとに、なす角マークの中点にラベルを配置するように、円弧上の点の座標を計算します。\
\

</details>

　ここまでは、共通の処理です。ここからは、「グラフの作成」のときと同様に2つの方法で図示します。\
\


#### パターン1

<details><summary>・作図コード(クリックで展開)</summary>

　半径と円関数を示す線分の描画用のデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("r", "sin", "cos", "tan", "cot", "sec", "csc")

# 反転フラグを設定
sin_flag_i <- sin(theta_i) >= 0
cos_flag_i <- cos(theta_i) >= 0

# 関数直線の線分の座標を計算
anim_function_line_df <- tibble::tibble(
  fnc = c(
    "r", "r", "r", "r", "r", 
    "sin", "sin", 
    "cos", "cos", 
    "tan", "tan", 
    "cot", "cot", "cot", "cot", 
    "sec", "sec", 
    "csc", "csc"
  ) |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 1/tan(theta_i), ifelse(test = cos_flag_i, yes = NA, no = -1/tan(theta_i)), rep(0, times = frame_num), 
    rep(0, times = frame_num), cos(theta_i), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(1, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 1), 
    rep(0, times = frame_num), rep(0, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0), ifelse(test = cos_flag_i, yes = NA, no = 0), 
    rep(0, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 0), 
    rep(0, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0)
  ), 
  y_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), rep(0, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0), rep(0, times = frame_num), 
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), sin(theta_i), 
    rep(0, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 0), 
    rep(0, times = frame_num), rep(1, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0), ifelse(test = cos_flag_i, yes = NA, no = 1), 
    rep(0, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 0), 
    rep(0, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0)
  ), 
  x_to = c(
    rep(1, times = frame_num), cos(theta_i), 1/tan(theta_i), ifelse(test = cos_flag_i, yes = NA, no = -1/tan(theta_i)), rep(0, times = frame_num), 
    rep(0, times = frame_num), cos(theta_i), 
    cos(theta_i), cos(theta_i), 
    rep(1, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 1), 
    1/tan(theta_i), 1/tan(theta_i), ifelse(test = cos_flag_i, yes = NA, no = -1/tan(theta_i)), ifelse(test = cos_flag_i, yes = NA, no = -1/tan(theta_i)), 
    rep(1, times = frame_num), ifelse(test = sin_flag_i, yes = NA, no = 1), 
    ifelse(test = cos_flag_i, yes = 1/tan(theta_i), no = -1/tan(theta_i)), ifelse(test = cos_flag_i, yes = NA, no = 1/tan(theta_i))
  ), 
  y_to = c(
    rep(0, times = frame_num), sin(theta_i), rep(1, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 1), rep(1, times = frame_num), 
    sin(theta_i), sin(theta_i), 
    rep(0, times = frame_num), sin(theta_i), 
    tan(theta_i), ifelse(test = sin_flag_i, yes = NA, no = -tan(theta_i)), 
    rep(0, times = frame_num), rep(1, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 0), ifelse(test = cos_flag_i, yes = NA, no = 1), 
    ifelse(test = sin_flag_i, yes = tan(theta_i), no = -tan(theta_i)), ifelse(test = sin_flag_i, yes = NA, no = tan(theta_i)), 
    rep(1, times = frame_num), ifelse(test = cos_flag_i, yes = NA, no = 1)
  ), 
  width = c(
    "normal", "normal", "thin", "thin", "thin", 
    "normal", "normal", 
    "bold", "normal", 
    "normal", "normal", 
    "thin", "normal", "thin", "normal", 
    "bold", "bold", 
    "thin", "thin"
  ) |> 
    rep(each = frame_num), # 太さ用
  type = c(
    "main", "main", "sub", "sub", "sub", 
    "main", "main", 
    "main", "main", 
    "main", "sub", 
    "main", "main", "sub", "sub", 
    "main", "sub", 
    "main", "sub"
  ) |> 
    rep(each = frame_num), # 太さ用
  label_flag = c(
    FALSE, FALSE, FALSE, FALSE, FALSE, 
    TRUE, FALSE, 
    TRUE, FALSE, 
    TRUE, FALSE, 
    FALSE, TRUE, FALSE, FALSE, 
    TRUE, FALSE, 
    TRUE, FALSE
  ) |> 
    rep(each = frame_num), # # 関数ラベル用
  frame_label = frame_label_vec |> 
    rep(times = 19) |> # (線分の数)
    factor(levels = frame_label_vec) # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    x_from = dplyr::case_when(x_from == Inf ~ 1e+10, x_from == -Inf ~ -1e+10, TRUE ~ x_from), 
    x_to   = dplyr::case_when(x_to == Inf ~ 1e+10, x_to == -Inf ~ -1e+10, TRUE ~ x_to)
  ) # 発散した場合は大きな値に置換
anim_function_line_df
```

　線分ごとに`frame_num`個の座標を格納します。\
　関数ラベルを表示する線分を1つ`label_flag`列に指定します。ラベルを表示する線分を`TRUE`、それ以外を`FALSE`とします。\

　関数名(ラベル)の描画用のデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 0, 90, 0, 0, 0) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.2, -0.2) |> 
      rep(each = frame_num), 
    v = c(-0.5, 1, 1, -0.5, 0.5, 0.5) |> 
      rep(each = frame_num), 
    fnc_label = c("sin~theta", "cos~theta", "tan~theta", "cot~theta", "sec~theta", "csc~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　線分の座標`anim_function_line_df`から`label_flag`列が`TRUE`の行(線分)を取り出して、関数列とフレーム列でグループ化して、関数(線分)とフレームごとに中点の座標を`median()`で計算します。\
　また、ラベル用の文字列などの列を追加します。\

　単位円上に円関数の線分を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
axis_size <- 2

# 単位円上の関数直線のアニメーションを作図
graphs <- ggplot() + 
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # なす角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # なす角ラベル
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_hline(yintercept = 1, linetype = "dashed") + # 補助線
  geom_vline(xintercept = 1, linetype = "dashed") + # 補助線
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_color_manual(breaks = fnc_level_vec, 
                     values = c("black", scales::hue_pal()(length(fnc_level_vec)-1))) + # (半径直線を黒色にしたい)
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線を描き分けたい)
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
anim <- gganimate::animate(plot = graphs, nframes = frame_num, fps = 100, width = 800, height = 800)
#anim
```

　`gganimate`パッケージを利用して、アニメーション(gif画像)を作成します。\
　`transition_manual()`のフレーム制御の引数`frames`にフレーム(変数)ラベル列`frame_label`を指定して、グラフを作成します。\
　`animate()`の`plot`引数にグラフオブジェクト、`nframes`引数にフレーム数`frame_num`を指定して、gif画像を作成します。また、`fps`引数に1秒当たりのフレーム数を指定できます。\

</details>

```{r, echo=FALSE}
### 資料作成用:(出力)

anim
```

　$\theta = 0, \pi$ のとき $\sin \theta = 0$ なので、原点と円周上の点を結ぶ線分が水平になり直線 $y = 1$ と平行なため交点ができず、$\cot \theta, \csc \theta$ を描画(定義)できないのが分かります。また、$\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ のとき $\cos \theta = 0$ なので、原点と円周上の点を結ぶ線分が垂直になり直線 $x = 1$ と平行なため交点ができず、$\tan \theta, \sec \theta$ を描画(定義)できないのが分かります。\
\


#### パターン2

<details><summary>・作図コード(クリックで展開)</summary>

　半径と円関数を示す線分の描画用のデータフレームを作成します。

```{r}
# 関数直線の線分の座標を計算
anim_function_line_df <- tibble::tibble(
  fnc = c(
    "r", "r", 
    "sin", "cos", "tan", "cot", "sec", "csc"
  ) |> 
    rep(each = frame_num) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    cos(theta_i), 
    cos(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  y_from = c(
    rep(0, times = frame_num), rep(0, times = frame_num), 
    rep(0, times = frame_num), 
    sin(theta_i), 
    sin(theta_i), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    rep(0, times = frame_num)
  ), 
  x_to = c(
    rep(1, times = frame_num), cos(theta_i), 
    cos(theta_i), 
    cos(theta_i), 
    1/cos(theta_i), 
    rep(0, times = frame_num), 
    1/cos(theta_i), 
    rep(0, times = frame_num)
  ), 
  y_to = c(
    rep(0, times = frame_num), sin(theta_i), 
    sin(theta_i), 
    sin(theta_i), 
    rep(0, times = frame_num), 
    1/sin(theta_i), 
    rep(0, times = frame_num), 
    1/sin(theta_i)
  ), 
  frame_label = frame_label_vec |> 
    rep(times = 8) |> # (線分の数)
    factor(levels = frame_label_vec), # フレーム切替用ラベル
) |> 
  dplyr::mutate(
    y_to = dplyr::if_else(condition = y_to == Inf, true = 1e+10, false = y_to)
  ) # 発散した場合は大きな値に置換
anim_function_line_df
```

　「パターン1」のときと同様に、半径と関数の線分の座標を格納します。\

　関数名(ラベル)の描画用のデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
anim_function_label_df <- anim_function_line_df |> 
  dplyr::filter(fnc != "r") |> # 関数を抽出
  dplyr::group_by(fnc, frame_label) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 0, 0, 0, 0, 90) |> 
      rep(each = frame_num), 
    h = c(0.5, 0.5, -0.2, -0.2, 0.5, 0.5) |> 
      rep(each = frame_num), 
    v = c(-0.5, -0.5, 0.5, 0.5, 1, 1) |> 
      rep(each = frame_num), 
    fnc_label = c("sin~theta", "cos~theta", "tan~theta", "cot~theta", "sec~theta", "csc~theta") |> 
      rep(each = frame_num) # 関数ラベル
  )
anim_function_label_df
```

　関数ごとに1つの行(線分)を取り出して、それぞれ中点の座標を計算して、ラベル用の文字列などを格納します。\

　単位円上に円関数の線分を重ねたアニメーションを作成します。

```{r, eval=TRUE}
# グラフサイズ用の値を指定
axis_size <- 2

# 単位円上の関数直線のアニメーションを作図
graphs <- ggplot() + 
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_path(data = anim_angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # なす角マーク
  geom_text(data = anim_angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # なす角ラベル
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_point(data = anim_point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_hline(yintercept = 0, linetype = "dashed") + # 補助線
  geom_vline(xintercept = 0, linetype = "dashed") + # 補助線
  geom_segment(data = anim_function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, color = fnc), 
               size = 1) + # 関数直線
  geom_text(data = anim_function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, show.legend = FALSE) + # 関数ラベル
  gganimate::transition_manual(frames = frame_label) + # フレーム
  scale_color_manual(breaks = fnc_level_vec, 
                     values = c("black", scales::hue_pal()(length(fnc_level_vec)-1))) + # (半径直線を黒色にしたい)
  coord_fixed(ratio = 1, 
              xlim = c(-axis_size, axis_size), ylim = c(-axis_size, axis_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = "{current_frame}", 
       color = "function", 
       x = "x", y = "y")

# gif画像を作成
anim <- gganimate::animate(plot = graphs, nframes = frame_num, fps = 100, width = 800, height = 800)
#anim
```

</details>

```{r, echo=FALSE}
### 資料作成用:(出力)

anim
```

　こちらの図だと、$\theta = 0, \pi$ のとき、原点と円周上の点を結ぶ線分の垂線が垂直になり直線 $x = 0$ と平行なため交点ができず、$\cot \theta, \csc \theta$ を描画(定義)できないのが分かります。また、$\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ のとき、原点と円周上の点を結ぶ線分の垂線が水平になり直線 $y = 0$ と平行なため交点ができず、$\tan \theta, \sec \theta$ を描画(定義)できないのが分かります。\
\


## なす角と関数曲線の関係

　最後は、単位円上におけるなす角と円関数(sin・cos・tan・cot・sec・csc)の曲線の関係をグラフで可視化します。\
\


### グラフの作成

　変数を固定した円関数をグラフで確認します。\
\

<details><summary>・作図コード(クリックで展開)</summary>

　変数の値を指定します。

```{r}
# 単位円上の点用のラジアンを指定
theta <- 5/4 * pi
theta
```

　単位円におけるなす角(ラジアン) $\theta$ を`theta`として値を指定します。ただし、`theta`が`0`のとき、計算結果に`Inf`や`-Inf`が含まれるため、意図しないグラフになります。発散時の対策については「アニメーションの作成」を参照してください。\

　「なす角と円関数の関係」の「パターン1」のコードで3つのデータフレーム(`point_df`・`angle_mark_df`・`angle_label_df`)を作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 単位円上の点の座標を計算
point_df <- tibble::tibble(
  t = theta, 
  sin_t = sin(theta), 
  cos_t = cos(theta)
)

# なす角マークの座標を計算
d <- 0.15
angle_mark_df <- tibble::tibble(
  t = seq(from = 0, to = theta, length.out = 100), 
  x = d * cos(t), 
  y = d * sin(t)
)

# なす角ラベルの座標を計算
d <- 0.21
angle_label_df <- tibble::tibble(
  t = 0.5 * theta, 
  x = d * cos(t), 
  y = d * sin(t)
)
```

　半径と円関数を示す線分の描画用のデータフレームを作成します。

```{r}
# 関数ラベルのレベルを指定
fnc_level_vec <- c("r", "sin", "cos", "tan", "cot", "sec", "csc")

# 反転フラグを設定
sin_flag <- sin(theta) >= 0
cos_flag <- cos(theta) >= 0

# 関数直線の線分の座標を計算
function_line_df <- tibble::tibble(
  fnc = c(
    "r", "r", "r", "r", 
    "sin", "sin", 
    "cos", "cos", "cos", 
    "tan", "tan", 
    "cot", "cot", "cot", "cot", "cot", 
    "sec", "sec", "sec", 
    "csc", "csc", "csc"
  ) |> 
    factor(levels = fnc_level_vec), # 色用
  x_from = c(
    0, 0, 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 
    0, cos(theta), 
    0, 0, 0, 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    0, 0, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 0), 0, 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 0, 
    0, ifelse(test = cos_flag, yes = NA, no = 0), 0
  ), 
  y_from = c(
    0, 0, 0, ifelse(test = cos_flag, yes = NA, no = 0), 
    0, 0, 
    0, sin(theta), 0, 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 
    0, 1, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 1), 0, 
    0, ifelse(test = sin_flag, yes = NA, no = 0), 0, 
    0, ifelse(test = cos_flag, yes = NA, no = 0), 0
  ), 
  x_to = c(
    1, cos(theta), 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 
    0, cos(theta), 
    cos(theta), cos(theta), 0, 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 
    1/tan(theta), 1/tan(theta), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), ifelse(test = cos_flag, yes = NA, no = -1/tan(theta)), 0, 
    1, ifelse(test = sin_flag, yes = NA, no = 1), 0, 
    ifelse(test = cos_flag, yes = 1/tan(theta), no = -1/tan(theta)), ifelse(test = cos_flag, yes = NA, no = 1/tan(theta)), 0
  ), 
  y_to = c(
    0, sin(theta), 1, ifelse(test = cos_flag, yes = NA, no = 1), 
    sin(theta), sin(theta), 
    0, sin(theta), cos(theta), 
    tan(theta), ifelse(test = sin_flag, yes = NA, no = -tan(theta)), 
    0, 1, ifelse(test = cos_flag, yes = NA, no = 0), ifelse(test = cos_flag, yes = NA, no = 1), 1/tan(theta), 
    ifelse(test = sin_flag, yes = tan(theta), no = -tan(theta)), ifelse(test = sin_flag, yes = NA, no = tan(theta)), 1/cos(theta), 
    1, ifelse(test = cos_flag, yes = NA, no = 1), 1/sin(theta)
  ), 
  width = c(
    "normal", "normal", "thin", "thin", 
    "normal", "normal", 
    "bold", "normal", "thin", 
    "normal", "normal", 
    "thin", "normal", "thin", "normal", "thin", 
    "bold", "bold", "thin", 
    "thin", "thin", "thin"
  ), # 太さ用
  type = c(
    "main", "main", "main", "main", 
    "main", "main", 
    "main", "main", "sub", 
    "main", "sub", 
    "main", "main", "sub", "sub", "sub", 
    "main", "sub", "sub", 
    "main", "sub", "sub"
    ), # 線種用
  label_flag = c(
    FALSE, FALSE, FALSE, FALSE, 
    TRUE, FALSE, 
    TRUE, FALSE, FALSE, 
    TRUE, FALSE, 
    TRUE, FALSE, FALSE, FALSE, FALSE, 
    TRUE, FALSE, FALSE, 
    TRUE, FALSE, FALSE
  ) # 関数ラベル用
)
function_line_df
```

　「なす角と円関数の関係」のときのコードに、cos・cot・sec・csc関数の線分の1つを垂直線に回転した線分の座標を追加します。\

　関数名(ラベル)の描画用のデータフレームを作成します。

```{r}
# 関数ラベルの座標を計算
function_label_df <- function_line_df |> 
  dplyr::filter(label_flag) |> # ラベル付けする線分を抽出
  dplyr::group_by(fnc) |> # 中点の計算用
  dplyr::summarise(
    x = median(c(x_from, x_to)), 
    y = median(c(y_from, y_to)), .groups = "drop"
  ) |> # 線分の中点に配置
  tibble::add_column(
    angle = c(90, 0, 90, 0, 0, 0), 
    h = c(0.5, 0.5, 0.5, 0.5, 1.2, -0.2), 
    v = c(-0.5, 1, 1, -0.5, 0.5, 0.5), 
    fnc_label = c("sin~theta", "cos~theta", "tan~theta", "cot~theta", "sec~theta", "csc~theta") # 関数ラベル
  )
function_label_df
```

　関数ごとに1つの行(線分)を取り出して、それぞれ中点の座標を計算して、ラベル用の文字列などを格納します。\

　関数直線を垂直線になるように回転する軌道の描画用のデータフレームを作成します。

```{r}
# sec・csc直線の角度を設定
if(cos(theta) >= 0) {
  theta_sec <- acos(cos(theta))
} else {
  theta_sec <- pi + acos(cos(theta))
}
if(sin(theta) >= 0) {
  theta_csc <- asin(sin(theta))
} else {
  theta_csc <- pi + asin(sin(theta))
}

# 軸変換曲線の座標を計算
num <- 100
adapt_curve_df <- tibble::tibble(
  fnc = c(
    rep("cos", times = num), 
    rep("cot", times = num), 
    rep("sec", times = num), 
    rep("csc", times = num)
  ), # 色用
  rad = c(
    seq(from = 0, to = 0.5*pi, length.out = num), 
    seq(from = 0, to = 0.5*pi, length.out = num), 
    seq(from = theta_sec, to = ifelse(test = cos(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), length.out = num), 
    seq(from = theta_csc, to = ifelse(test = sin(theta) >= 0, yes = 0.5*pi, no = 1.5*pi), length.out = num)
  ), 
  d = c(
    rep(cos(theta), times = num), 
    rep(1/tan(theta), times = num), 
    rep(abs(1/cos(theta)), times = num), 
    rep(abs(1/sin(theta)), times = num)
  ), 
  x = d * cos(rad), 
  y = d * sin(rad)
)
adapt_curve_df
```

　軸を変換する軌道として、半径が各関数の絶対値 $|f(\theta)|$ の円弧を描画します。全体値 $|x|$ は`abs()`で計算できます。詳しくはそれぞれの関数の記事を参照してください。\

　単位円における点と関数曲線上の点を結ぶ補助線(の一部)の描画用のデータフレームを作成します。

```{r}
# グラフサイズ用の値を設定
axis_lower <- 1.5
axis_upper <- 4
x_size <- c(1/sin(theta), 1/tan(theta)) |> # csc・cot
  abs() |> # 絶対値
  ceiling() |> # 切り上げ
  max(axis_lower) |> # 下限
  min(axis_upper) # 上限
y_size <- c(1/cos(theta), 1/sin(theta), 1/tan(theta)) |> # sec・csc・cot
  abs() |> # 絶対値
  ceiling() |> # 切り上げ
  max(axis_lower) |> # 下限
  min(axis_upper) # 上限

# 関数曲線との対応線の座標を計算
l <- 0.5
segment_circle_df <- tibble::tibble(
  fnc = c("sin", "cos", "tan", "sec", "csc", "cot") |> 
    factor(levels = fnc_level_vec), # 色用
  #x = c(0, 0, 0, 0, 0, 0), # y軸線上に並べる場合
  x = c(cos(theta), 0, 1, 0, 0, 0), 
  y = c(sin(theta), cos(theta), tan(theta), 1/cos(theta), 1/sin(theta), 1/tan(theta)), 
  x_to = x_size+l, 
  y_to = y
)
segment_circle_df
```

　単位円図における点からy軸線の反対側へ水平線を引くように線分の座標を指定します。\

　単位円上に円関数の線分を重ねたグラフを作成します。

```{r, fig.width=6, fig.height=6, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta/pi, digits = 2), "*pi", 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ")"
)

# 単位円上に関数直線を作図
circle_graph <- ggplot() + 
  geom_segment(data = radian_lable_df, 
               mapping = aes(x = 0, y = 0, xend = x, yend = y), 
               color = "white") + # 角度目盛グリッド
  geom_text(data = radian_lable_df, 
            mapping = aes(x = x, y = y, angle = t_deg+90), label = "|", 
            size = 2) + # 角度目盛指示線
  geom_text(data = radian_lable_df, 
            mapping = aes(x = label_x, y = label_y, label = rad_label, 
                          hjust = h, vjust = v), parse = TRUE) + # 角度目盛ラベル
  geom_path(data = angle_mark_df, 
            mapping = aes(x = x, y = y), 
            size = 0.5) + # なす角マーク
  geom_text(data = angle_label_df, 
            mapping = aes(x = x, y = y), label = "theta", parse = TRUE, 
            size = 5) + # なす角ラベル
  geom_path(data = circle_df, 
            mapping = aes(x = x, y = y), 
            size = 1) + # 円周
  geom_point(data = point_df, 
             mapping = aes(x = cos_t, y = sin_t), 
             size = 4) + # 円周上の点
  geom_hline(yintercept = 1, linetype = "dashed") + # 補助線
  geom_vline(xintercept = 1, linetype = "dashed") + # 補助線
  geom_segment(data = function_line_df, 
               mapping = aes(x = x_from, y = y_from, xend = x_to, yend = y_to, 
                             color = fnc, size = width, linetype = type), na.rm = TRUE) + # 関数直線
  geom_text(data = function_label_df, 
            mapping = aes(x = x, y = y, label = fnc_label, color = fnc, 
                          hjust = h, vjust = v, angle = angle), 
            parse = TRUE, na.rm = TRUE, show.legend = FALSE) + # 関数ラベル
  geom_path(data = adapt_curve_df, 
            mapping = aes(x = x, y = y, color = fnc), 
            size = 1, linetype = "dotted", show.legend = FALSE) + # 変換曲線
  geom_point(data = segment_circle_df, 
             mapping = aes(x = x, y = y, color = fnc), 
             size = 4, alpha = 0.5) + # 変換点
  geom_segment(data = segment_circle_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y, color = fnc), 
               size = 1, linetype = "dotted", show.legend = FALSE) + # 関数曲線との対応線
  scale_color_manual(breaks = fnc_level_vec, 
                     values = c("black", scales::hue_pal()(length(fnc_level_vec)-1))) + # (半径直線を黒色にしたい)
  scale_size_manual(breaks = c("normal", "bold", "thin"), 
                    values = c(1, 1.6, 0.8), guide = "none") + # (線が重なる対策)
  scale_linetype_manual(breaks = c("main", "sub"), 
                        values = c("solid", "twodash"), guide = "none") + # (補助線を描き分けたい)
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(-x_size, x_size), ylim = c(-y_size, y_size)) + # 描画領域
  labs(title = "circular functions", 
       subtitle = parse(text = variable_label), 
       color = "function", 
       x = "x", y = "y")
circle_graph
```

　「なす角と円関数の関係」のときと同様に、単位円と関数直線を描画します。\
\

　関数曲線の描画用のデータフレームを作成します。

```{r}
# 関数曲線用のラジアンを指定
theta_vec <- seq(from = 0, to = 2*pi, length.out = 1000)

# 円関数を計算
function_curve_df <- tibble::tibble(
  fnc = c("sin", "cos", "tan", "cot", "sec", "csc") |> 
    rep(each = length(theta_vec)) |> 
    factor(levels = fnc_level_vec), # 色用
  t = theta_vec |> 
    rep(times = 6), # (関数の数)
  f_t = c(
    sin(theta_vec), 
    cos(theta_vec), 
    tan(theta_vec), 
    1/tan(theta_vec), 
    1/cos(theta_vec), 
    1/sin(theta_vec)
  )
) |> 
  dplyr::mutate(
    f_t = dplyr::if_else(
      (f_t >= -y_size & f_t <= y_size), true = f_t, false = NA_real_
    ) # 閾値外の値を欠損値に置換
  )
function_curve_df
```

　「円関数の作図」のときと同様に、各円関数を計算します。\

　関数曲線上の点と単位円における点を結ぶ補助線(の一部)の描画用のデータフレームを作成します。

```{r}
# 関数直線との対応線の座標を計算
l <- 0.7
segment_curve_df <- tibble::tibble(
  fnc = c("sin", "cos", "tan", "cot", "sec", "csc") |> 
    factor(levels = fnc_level_vec), 
  x = theta, 
  y = c(sin(theta), cos(theta), tan(theta), 1/tan(theta), 1/cos(theta), 1/sin(theta)), 
  x_to = -l, 
  y_to = y
)
segment_curve_df
```

　曲線上の点からy軸線へ水平線を引くように線分の座標を指定します。\

　x軸目盛の設定用のベクトルを作成します。

```{r}
# 半周期の目盛の数(分母の値)を指定
denom <- 6

# 目盛の通し番号(分子の値)を作成
numer_vec <- seq(from = 0, to = 2*pi / pi * denom, by = 1)

# 目盛ラベル用の文字列を作成
label_vec <- paste0(c("", "-")[(numer_vec < 0)+1], "frac(", abs(numer_vec), ", ", denom, ")~pi")
head(numer_vec); head(label_vec)
```

　「円関数の作図」のときと同様にして、目盛ラベル用の値と文字列を作成します。\

　関数曲線のグラフを作成します。

```{r, fig.width=10, fig.height=5, dpi=100}
# 変数ラベル用の文字列を作成
variable_label <- paste0(
  "list(", 
  "theta==", round(theta, digits = 2), 
  ", sin~theta==", round(sin(theta), digits = 2), 
  ", cos~theta==", round(cos(theta), digits = 2), 
  ", tan~theta==", round(tan(theta), digits = 2), 
  ", cot~theta==", round(1/tan(theta), digits = 2), 
  ", sec~theta==", round(1/cos(theta), digits = 2), 
  ", csc~theta==", round(1/sin(theta), digits = 2), 
  ")"
)

# 関数曲線を作図
curve_graph <- ggplot() + 
  geom_vline(xintercept = theta, linetype = "dashed") + # 変数垂線
  geom_line(data = function_curve_df, 
            mapping = aes(x = t, y = f_t, color = fnc), na.rm = TRUE, 
            size = 1) + # 関数曲線
  geom_point(data = segment_curve_df, 
             mapping = aes(x = x, y = y, color = fnc), 
             size = 4, alpha = 0.5) + # 曲線上の点
  geom_segment(data = segment_curve_df, 
               mapping = aes(x = x, y = y, xend = x_to, yend = y, color = fnc), 
               size = 1, linetype = "dotted") + # 関数直線との対応線
  scale_x_continuous(breaks = numer_vec/denom*pi, 
                     labels = parse(text = label_vec)) + # 角度目盛ラベル
  coord_fixed(ratio = 1, clip = "off", 
              xlim = c(0, 2*pi), ylim = c(-y_size, y_size)) + # 描画領域
  theme(legend.position = "none") + # 図の体裁
  labs(title = "", 
       subtitle = parse(text = variable_label), 
       x = expression(theta), 
       y = expression(f(theta)))
curve_graph
```

　「円関数の作図」のときと同様に、関数曲線を描画します。\
\

　2つのグラフを並べて描画します。

```{r, fig.width=16, fig.height=8, dpi=100}
# 並べて描画
graph <- patchwork::wrap_plots(circle_graph, curve_graph, guides = "collect")
#graph
```

　`patchwork`パッケージの`wrap_plots()`を使ってグラフを並べます。\

</details>

```{r, echo=FALSE, fig.width=16, fig.height=8, dpi=100}
### 資料作成用:(出力)

graph
```

　2つのグラフで、単位円図における各関数を表す線分の「長さと座標の正負」と曲線上の点の「y軸の値」が対応するのが分かります。また、なす角の値とx軸の値が一致します。\
\


### アニメーションの作成

　続いて、変数の値を変化させた円関数をアニメーションで確認します。詳しくは「circular.R」を参照してください。\
\


#### 1周

　円周上を1周した際の円関数の線分と曲線上の点の関係を可視化します。\
\

![](../figure/curves/circular_1cycle.gif)

　$\sin \theta = 0$ となる $\theta = 0, \pi, 2 \pi$ とき、cot関数とcsc関数の線分の象限($\cot \theta, \csc \theta$ の符号)が変わり、cot関数とcsc関数の曲線が不連続になるのが分かります。また、$\cos \theta = 0$ となる $\theta = \frac{1}{2} \pi, \frac{3}{2} \pi$ とき、tan関数とsec関数の線分の象限($\tan \theta, \sec \theta$ の符号)が変わり、tan関数とsec関数の曲線が不連続になるのが分かります。\
\


#### n周

　円周上を複数回周回した際の円関数の線分と曲線上の点の関係を可視化します。\
\

![](../figure/curves/circular_ncycle.gif)

　単位円上の点が1周する $2 \pi$ (tan関数の場合は半周する $\pi$)の間隔で、それぞれの関数の曲線が同じ形になるのが分かります。\
\

　この記事では、6つの円関数を可視化しました。\
\


# 参考書籍


- 『三角関数(改定第3版)』(Newton別冊)ニュートンプレス,2022年.

\ 


